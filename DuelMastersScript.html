<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DM TCG Editor v1.0 - Logic Updated</title>
    <style>
        :root {
            --card-width: 50px;
            --card-height: 70px;
            --bg-color: #dcdcdc;
            --p1-color: #e3f2fd;
            --p2-color: #fce4ec;
            --timeline-width: 320px;
            --highlight-color: #f1c40f;
        }

        * { box-sizing: border-box; }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #toolbar {
            height: 45px;
            background: #2c3e50;
            color: white;
            display: flex;
            align-items: center;
            padding: 0 10px;
            gap: 10px;
            flex-shrink: 0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 50;
        }

        #draft-bar {
            background: #e67e22;
            color: white;
            padding: 5px 10px;
            display: none;
            align-items: center;
            justify-content: space-between;
            font-size: 0.9rem;
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        #draft-bar label {
            display: flex; align-items: center; gap: 5px; cursor: pointer; user-select: none;
            background: rgba(0,0,0,0.1); padding: 2px 8px; border-radius: 4px;
        }

        #point-bar {
            background: #8e44ad;
            color: white;
            padding: 5px 10px;
            display: none;
            align-items: center;
            justify-content: space-between;
            font-size: 0.9rem;
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        #card-action-panel {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(44, 62, 80, 0.95);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            display: none;
            gap: 10px;
            align-items: center;
            z-index: 1000;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            backdrop-filter: blur(5px);
            border: 1px solid #555;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 95vw;
        }
        
        button {
            background: #34495e;
            color: white;
            border: 1px solid #566573;
            padding: 4px 10px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 0.85rem;
            transition: all 0.2s;
        }
        button:hover { background: #4e6479; transform: translateY(-1px); }
        button:active { transform: translateY(1px); }
        
        button.primary { background: #2ecc71; border-color: #27ae60; font-weight: bold; }
        button.primary:hover { background: #27ae60; }
        
        button.danger { background: #c0392b; border-color: #e74c3c; }
        button.danger:hover { background: #e74c3c; }

        input[type="text"], input[type="number"] {
            padding: 4px;
            border-radius: 4px;
            border: 1px solid #ccc;
            font-size: 0.85rem;
        }

        #workspace {
            display: flex;
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        #svg-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; 
            z-index: 999; 
        }
        
        .arrow-line {
            stroke: rgba(231, 76, 60, 0.8);
            stroke-width: 4;
            stroke-dasharray: 10, 5;
            animation: dash 1s linear infinite;
            marker-end: url(#arrowhead);
            fill: none;
        }
        @keyframes dash { to { stroke-dashoffset: -15; } }

        #ability-stack-zone {
            width: 100px;
            background: #bdc3c7;
            border-right: 2px solid #7f8c8d;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            z-index: 10;
        }

        #ability-stack-zone.rotated-view {
            flex-direction: column-reverse;
        }

        .ability-column {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 5px 0;
            overflow-y: auto;
            position: relative;
            gap: 5px;
        }

        #ability-zone-p2 { background: rgba(252, 228, 236, 0.5); }
        #ability-zone-p1 { background: rgba(227, 242, 253, 0.5); }

        #ability-stack-zone:not(.rotated-view) #ability-zone-p2 { border-bottom: 2px dashed #7f8c8d; }
        #ability-stack-zone.rotated-view #ability-zone-p1 { border-bottom: 2px dashed #7f8c8d; }

        .ability-label {
            font-size: 0.7rem;
            font-weight: bold;
            color: #555;
            margin-bottom: 5px;
            opacity: 0.7;
        }

        #game-board-container {
            flex: 1;
            background: #95a5a6;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow: hidden; 
        }

        #main-board {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            background: white;
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
        }

        /* Turn Indicators */
        .turn-bar {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 12px;
            background: #95a5a6;
            z-index: 50;
            transition: all 0.5s ease;
            border-right: 1px solid rgba(0,0,0,0.1);
        }
        
        #player1-area.active-turn .turn-bar {
            background: #3498db;
            box-shadow: 0 0 15px 2px rgba(52, 152, 219, 0.8);
            animation: pulse-blue 2s infinite;
        }
        
        #player2-area.active-turn .turn-bar {
            background: #e91e63;
            box-shadow: 0 0 15px 2px rgba(233, 30, 99, 0.8);
            animation: pulse-red 2s infinite;
        }
        
        @keyframes pulse-blue {
            0% { box-shadow: 0 0 10px 2px rgba(52, 152, 219, 0.5); }
            50% { box-shadow: 0 0 20px 5px rgba(52, 152, 219, 0.9); }
            100% { box-shadow: 0 0 10px 2px rgba(52, 152, 219, 0.5); }
        }

        @keyframes pulse-red {
            0% { box-shadow: 0 0 10px 2px rgba(233, 30, 99, 0.5); }
            50% { box-shadow: 0 0 20px 5px rgba(233, 30, 99, 0.9); }
            100% { box-shadow: 0 0 10px 2px rgba(233, 30, 99, 0.5); }
        }

        #reveal-zone {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            min-width: 200px;
            min-height: 120px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px dashed #f1c40f;
            border-radius: 10px;
            z-index: 300; 
            display: none;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
            padding: 30px 20px 20px 20px; 
            transition: opacity 0.3s;
            box-shadow: 0 0 20px rgba(241, 196, 15, 0.3);
        }
        
        #reveal-zone .zone-label {
            top: 5px;
            left: 10px;
            width: auto;
            transform: none;
            color: #f1c40f;
            text-shadow: none;
            font-size: 1rem;
            pointer-events: none;
        }

        #timeline-panel {
            width: var(--timeline-width);
            background: #ecf0f1;
            border-left: 1px solid #bdc3c7;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            z-index: 20;
        }

        #timeline-header {
            padding: 8px;
            background: #34495e;
            color: white;
            font-weight: bold;
            text-align: center;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
        }

        #action-list {
            flex: 1;
            overflow-y: auto;
            list-style: none;
            padding: 0;
            margin: 0;
            padding-bottom: 20px;
        }

        .timeline-gap {
            height: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            position: relative;
        }
        .timeline-gap:hover::after {
            content: "+";
            background: #3498db;
            color: white;
            width: 20px; height: 20px;
            border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            font-weight: bold;
            font-size: 14px;
            position: absolute;
            z-index: 5;
        }
        .timeline-gap::before {
            content: "";
            height: 2px;
            background: #ccc;
            width: 80%;
            position: absolute;
        }

        .action-item {
            padding: 8px 10px;
            border-bottom: 1px solid #dcdcdc;
            cursor: pointer;
            font-size: 0.85rem;
            display: flex;
            flex-direction: column;
            gap: 5px;
            background: #fdfdfd;
            border-left: 4px solid transparent;
        }
        .action-item:hover { background: #f0f4f7; }
        .action-item.active { background: #e8f6fd; border-left-color: #2980b9;}
        .action-item.editing { background: #fff3e0; border-left-color: #e67e22; }

        .action-item.p1-action { border-left: 4px solid #3498db; background: rgba(52, 152, 219, 0.05); }
        .action-item.p1-action.active { background: rgba(52, 152, 219, 0.2); }
        
        .action-item.p2-action { border-left: 4px solid #e91e63; background: rgba(233, 30, 99, 0.05); }
        .action-item.p2-action.active { background: rgba(233, 30, 99, 0.2); }

        .action-header { display: flex; align-items: center; width: 100%; justify-content: space-between; }
        .action-index { font-weight: bold; margin-right: 6px; min-width: 18px; text-align: right; color: #7f8c8d;}
        .action-desc { flex: 1; white-space: pre-wrap; word-break: break-all; font-weight: 500;}
        
        .action-controls {
            display: flex; gap: 5px; margin-top: 5px; padding-left: 24px; opacity: 0.4; transition: opacity 0.2s;
        }
        .action-item:hover .action-controls, .action-item.active .action-controls { opacity: 1; }
        
        .mini-btn { font-size: 0.75rem; padding: 3px 8px; background: #bdc3c7; border: none; color: #2c3e50; border-radius: 3px; cursor: pointer;}
        .mini-btn:hover { background: #95a5a6; color: white; }
        .mini-btn.play-from { background: #2ecc71; color: white; }
        .mini-btn.play-from:hover { background: #27ae60; }
        .mini-btn.play-step { background: #3498db; color: white; }
        .mini-btn.play-step:hover { background: #2980b9; }
        .mini-btn.edit { background: #f39c12; color: white; }
        .mini-btn.edit:hover { background: #e67e22; }
        .mini-btn.delete-all { background: #c0392b; color: white; font-weight:bold; padding: 2px 6px; border-radius:3px; cursor:pointer; border:none;}

        .icon-btn { background: none; border: none; cursor: pointer; padding: 2px; opacity: 0.5; font-size: 1rem; }
        .icon-btn:hover { opacity: 1; transform: scale(1.1); }
        .icon-btn.delete { color: #c0392b; }

        .player-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 2px;
            position: relative;
            padding-left: 15px; /* Space for turn bar */
        }

        #player2-area {
            background-color: var(--p2-color);
            border-bottom: 2px dashed #999;
        }
        
        #player2-area .bottom-row { order: -1; }
        #player2-area .mana-zone { order: 0; }
        #player2-area .shield-zone { order: 1; }
        #player2-area .battle-zone { order: 2; }
        
        #player1-area { background-color: var(--p1-color); }

        .zone {
            border: 1px solid rgba(0,0,0,0.15);
            margin: 1px;
            display: flex;
            align-items: center;
            position: relative;
            min-height: var(--card-height);
            border-radius: 3px;
        }
        
        .zone.target-highlight {
            background-color: rgba(46, 204, 113, 0.4);
            border: 2px dashed #27ae60;
            box-shadow: inset 0 0 10px rgba(46, 204, 113, 0.5);
            cursor: copy;
            z-index: 100;
        }
        
        /* Zone Glows (New Feature) */
        .zone.glow-red { box-shadow: inset 0 0 20px rgba(255, 0, 0, 0.5); border: 2px solid red; }
        .zone.glow-yellow { box-shadow: inset 0 0 20px rgba(255, 215, 0, 0.5); border: 2px solid gold; }
        .zone.glow-green { box-shadow: inset 0 0 20px rgba(0, 255, 0, 0.5); border: 2px solid lime; }
        .zone.glow-blue { box-shadow: inset 0 0 20px rgba(0, 191, 255, 0.5); border: 2px solid deepskyblue; }
        .zone.glow-black { box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5); border: 2px solid black; }
        .zone.glow-white { box-shadow: inset 0 0 20px rgba(255, 255, 255, 0.8); border: 2px solid white; }
        .zone.glow-rainbow { animation: zone-rainbow 2s linear infinite; }
        @keyframes zone-rainbow {
            0% { border-color: red; box-shadow: inset 0 0 20px rgba(255,0,0,0.5); }
            50% { border-color: blue; box-shadow: inset 0 0 20px rgba(0,255,0,0.5); }
            100% { border-color: red; box-shadow: inset 0 0 20px rgba(255,0,0,0.5); }
        }

        .zone.point-target-highlight {
            background-color: rgba(142, 68, 173, 0.2);
            border: 2px dashed #9b59b6;
            cursor: crosshair;
            z-index: 100;
        }
        .card.point-target-highlight {
            box-shadow: 0 0 10px 5px rgba(155, 89, 182, 0.8);
            z-index: 101;
            cursor: crosshair;
        }
        .card.point-target-selected {
            box-shadow: 0 0 15px 8px #8e44ad;
            border: 2px solid #8e44ad;
        }

        .zone-label {
            position: absolute; font-size: 0.8rem; color: rgba(0,0,0,0.25);
            font-weight: 900; pointer-events: none; z-index: 0; width: 100%; text-align: center;
            top: 50%; transform: translateY(-50%); text-transform: uppercase;
        }

        .bottom-row { display: flex; height: var(--card-height); margin-top: auto; }
        .hand-zone { flex: 1; overflow-x: auto; padding: 2px; scrollbar-width: thin;}
        .side-zone-group { width: 170px; display: flex; gap: 3px; padding-left: 3px; flex-shrink: 0; }
        
        .stacked { flex: 1; justify-content: center; cursor: zoom-in; background: rgba(0,0,0,0.1); border: 1px solid rgba(0,0,0,0.3); }
        .mana-zone { height: calc(var(--card-height) * 0.6); background: rgba(0,0,0,0.05); }
        .shield-zone { height: calc(var(--card-height) * 0.85); justify-content: center; gap: 5px; }
        .battle-zone { flex: 1; background: rgba(255,255,255,0.6); justify-content: center; gap: 4px; padding: 5px; }

        .card-group {
            position: relative;
            /* Changed from fixed width to auto/min-width to support God Link/Puzzle stacking */
            width: auto; 
            min-width: var(--card-width);
            height: var(--card-height);
            margin: 0 5px; /* Increased margin for better separation */
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.3s;
        }

        .card-group:hover {
            z-index: 500;
        }
        .card-group:hover .card {
            transition: top 0.3s, z-index 0s;
        }
        /* Hover Fan-out - modified to respect Puzzle links */
        .card-group:hover .stack-base { top: 0px !important; z-index: 100; }
        /* Only fan out vertical stacks if not puzzling */
        .card-group:hover .stack-top:not(.puzzle-link) { top: -40px !important; z-index: 101; }
        .card-group:hover .stack-shift-up { top: -50px !important; z-index: 101; }
        .card-group:hover .stack-shift-down { top: -30px !important; z-index: 101; }
        .card-group:hover .stack-bottom { top: 40px !important; z-index: 102; box-shadow: 0 0 10px rgba(0,0,0,0.5); }

        .card {
            width: var(--card-width); height: var(--card-height);
            background-color: white; border: 1px solid #333; border-radius: 3px;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            position: relative; font-size: 9px; cursor: pointer;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.4); user-select: none;
            transition: box-shadow 0.2s, border-color 0.2s; 
            z-index: 1; flex-shrink: 0; overflow: hidden;
            will-change: transform, top, left;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }
        
        .card.has-image { border: none; }
        .card.has-image[class*="glow-"] { border: 1px solid transparent; }
        .card.has-image .card-text { display: none; }

        .card.interactive { transition: transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1); }
        .card:hover { z-index: 200; box-shadow: 0 4px 10px rgba(0,0,0,0.3); }
        .card.selected { box-shadow: 0 0 0 3px #f1c40f, 0 0 8px #f1c40f; z-index: 100; }
        .card.face-down { 
            background: #2c3e50;
            background-image: radial-gradient(circle, #34495e 10%, transparent 10%);
            background-size: 15px 15px; border: 1px solid white; color: transparent; 
        }
        
        .card-note {
            position: absolute; top: 1px; left: 2px; right: 2px;
            background: #f1c40f; color: black; font-size: 8px; text-align: center;
            border: 1px solid #d35400; z-index: 5;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
            pointer-events: none; border-radius: 2px; box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }

        /* Stacking classes */
        .stack-base { z-index: 10; position: absolute; }
        .stack-top { z-index: 20; position: absolute; }
        .stack-bottom { z-index: 5; position: absolute; }
        .stack-shift-up { z-index: 20; position: absolute; }
        .stack-shift-down { z-index: 20; position: absolute; }
        .stack-bottom-exposed { z-index: 5; position: absolute; }
        .stack-top-offset { z-index: 20; position: absolute; }
        
        /* New Puzzle/Link Stacking Classes */
        .puzzle-link { /* Generic marker */ }
        .stack-puzzle-top { z-index: 20; position: absolute; }
        .stack-puzzle-bottom { z-index: 20; position: absolute; }
        .stack-puzzle-left { z-index: 20; position: absolute; }
        .stack-puzzle-right { z-index: 20; position: absolute; }

        .glow-red { box-shadow: 0 0 8px 4px rgba(255, 0, 0, 0.8) !important; border-color: red !important; }
        .glow-yellow { box-shadow: 0 0 8px 4px rgba(255, 215, 0, 0.8) !important; border-color: gold !important; }
        .glow-green { box-shadow: 0 0 8px 4px rgba(0, 255, 0, 0.8) !important; border-color: lime !important; }
        .glow-blue { box-shadow: 0 0 8px 4px rgba(0, 191, 255, 0.8) !important; border-color: deepskyblue !important; }
        .glow-black { box-shadow: 0 0 8px 4px rgba(0, 0, 0, 0.8) !important; border-color: black !important; }
        .glow-white { box-shadow: 0 0 8px 4px rgba(255, 255, 255, 0.9) !important; border-color: white !important; }
        .glow-rainbow { animation: rainbow 2s linear infinite !important; }
        
        @keyframes rainbow {
            0% { box-shadow: 0 0 8px 4px rgba(255, 0, 0, 0.8); border-color: red; }
            50% { box-shadow: 0 0 8px 4px rgba(0, 255, 0, 0.8); border-color: blue; }
            100% { box-shadow: 0 0 8px 4px rgba(255, 0, 0, 0.8); border-color: red; }
        }

        .ability-card { width: 80px; height: 35px; flex-direction: row; font-size: 8px; transform: none !important; cursor: pointer; overflow: hidden; }
        .ability-card .card-text { font-size: 8px; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; max-width: 90%; }
        .ability-card .card-power { display: none; }

        .card-power { 
            position: absolute; bottom: 0; left: 0; width: 100%;
            background: rgba(255,255,255,0.9); border-top: 1px solid #000; 
            text-align: center; font-weight: bold; font-size: 9px; color: black;
        }
        .card-text { padding: 2px; text-align: center; line-height: 1.1; font-weight: 500;}

        .count-badge {
            position: absolute; top: -6px; right: -6px;
            background: #e74c3c; color: white;
            border-radius: 50%; width: 20px; height: 20px;
            display: flex; justify-content: center; align-items: center;
            font-size: 10px; font-weight: bold; z-index: 50;
            border: 1px solid white; box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .modal {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); z-index: 2000;
            justify-content: center; align-items: center; backdrop-filter: blur(2px);
        }
        .modal-content {
            background: white; border-radius: 8px; box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            padding: 20px; display: flex; flex-direction: column;
            animation: slideUp 0.3s ease;
        }
        
        #setup-modal { display: none; }
        #setup-modal .modal-content { width: 320px; gap: 15px; }
        .input-group { display: flex; justify-content: space-between; align-items: center; }
        .input-group label { font-weight: bold; font-size: 0.9rem; }
        .input-group input { width: 60px; text-align: center; }

        #card-selector-modal .modal-content { width: 85%; max-width: 900px; height: 85%; }
        #modal-body { flex: 1; overflow-y: auto; display: flex; flex-wrap: wrap; gap: 12px; padding: 15px; background: #f8f9fa; border-radius: 4px; align-content: flex-start; }
        /* Style for cards in selector list that have images */
        #modal-body .card.has-image-icon { background-size: cover; background-position: center; color: transparent; text-shadow: none; }

        #position-selector-modal .modal-content { width: 90%; max-width: 600px; height: auto; max-height: 80vh; display: flex; flex-direction: column; }
		
		/* å®¹å™¨ï¼šç¸®å°é–“è·è®“ç¸«éš™æ„Ÿæ›´æ˜é¡¯ */
        #position-list {
            flex: 1; 
            overflow-y: auto; 
            display: flex; 
            flex-wrap: wrap; 
            gap: 2px;            /* [ä¿®æ”¹] é–“è·ç¸®å°ï¼Œè®“æ’æ§½ç·Šè²¼å¡ç‰‡ */
            padding: 10px; 
            background: #eee; 
            border-radius: 4px; 
            min-height: 0;
            align-content: flex-start;
        }

		/* æ’æ§½ï¼šå¼·åˆ¶è¨­å®šç‚ºæ¥µçª„çš„ç¸«éš™ (ç´„ 14px) */
        .position-slot {
            /* å¼·åˆ¶å›ºå®šå¯¬åº¦ï¼Œä¸è®“ Flex æˆ–å…§å®¹æ’é–‹ */
            width: 14px !important;
            min-width: 14px !important; 
            max-width: 14px !important;
            height: var(--card-height);
            
            /* éš±è—æº¢å‡ºçš„æ–‡å­— (Top/Bottom/+) */
            overflow: hidden; 
            
            background: rgba(0, 0, 0, 0.1); 
            border: 1px dashed #999;
            border-radius: 2px;
            
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s;
            
            /* è®“é€™å€‹å…ƒç´ ä¸æœƒè¢«å£“ç¸®æˆ–æ”¾å¤§ */
            flex-shrink: 0;
            flex-grow: 0;
            
            /* éš±è—æ–‡å­—é¡è‰² */
            color: transparent; 
        }
        
        /* æ»‘é¼ ç§»ä¸Šå»æ™‚ï¼šè®Šå¯¬ã€è®Šè‰²ï¼Œæ–¹ä¾¿æ“ä½œ */
        .position-slot:hover { 
            /* Hover æ™‚å±•é–‹åˆ°ä¸€åŠå¡ç‰‡å¯¬ï¼Œæ–¹ä¾¿ç¢ºèª */
            width: 25px !important; 
            min-width: 25px !important;
            max-width: 25px !important;
            
            background: #3498db; 
            border-color: #2980b9; 
            z-index: 100;
            box-shadow: 0 0 5px rgba(52, 152, 219, 0.8);
            
            /* Hover æ™‚é¡¯ç¤ºä¸€é»æ–‡å­—æç¤º (å¦‚æœé¡è‰²ä¸æ˜¯é€æ˜çš„è©±) */
            /* color: white; */ 
        }

        /* ç‚ºäº†å€åˆ†é ­å°¾ï¼Œæˆ‘å€‘å¯ä»¥åˆ©ç”¨ JS è³¦äºˆçš„ title å±¬æ€§ä¾†åšæ¨£å¼ (é¸ç”¨)
           æˆ–æ˜¯ä¿æŒçµ±ä¸€çš„ç¸«éš™æ¨£å¼ï¼Œè®“ä½¿ç”¨è€…ä¾è³´ç›´è¦º (æœ€å·¦=åº•ï¼Œæœ€å³=é ‚) */
        
        /* 2. åƒè€ƒå¡æ¨£å¼ï¼šå°ºå¯¸åŒå¡ç‰‡ï¼Œä½œç‚ºè¦–è¦ºåƒè€ƒ */
        .position-card-ref {
            width: var(--card-width); 
            height: var(--card-height);
            border: 1px solid #7f8c8d;
            border-radius: 3px;
            background-color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.6rem;
            color: #333;
            pointer-events: none; /* ç¦æ­¢é»æ“Šå¡ç‰‡æœ¬èº«ï¼Œå¼·è¿«é»æ“Šæ’æ§½ */
            flex-shrink: 0;
            background-size: cover;
            background-position: center;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.2);
            overflow: hidden;
            opacity: 0.85;
        }

        /* [é¸ç”¨] åœ¨å¡ç‰‡å³å´åŠ ä¸€å€‹å¾®å°çš„ç®­é ­æŒ‡ç¤ºé †åº */
        .position-card-ref::after {
            content: "âœ";
            position: absolute;
            right: -8px; 
            top: 50%;
            transform: translateY(-50%);
            font-size: 8px;
            color: #999;
            z-index: 5;
            display: none; /* å¦‚æœè¦ºå¾—ç•«é¢å¤ªäº‚å¯ä»¥ä¿æŒéš±è— */
        }
        
        #stack-gui {
            display: grid;
            grid-template-columns: repeat(3, 1fr); /* Changed to 3 columns to fit more options */
            gap: 10px;
            margin-top: 10px;
            overflow-y: auto;
        }
        .stack-option {
            background: #f8f9fa; border: 2px solid #ddd;
            border-radius: 8px; padding: 10px;
            text-align: center; cursor: pointer;
            transition: all 0.2s;
            display: flex; flex-direction: column; align-items: center; gap: 5px;
            font-size: 0.8rem;
        }
        .stack-option:hover { border-color: #3498db; background: #ebf5fb; transform: translateY(-2px); box-shadow: 0 3px 8px rgba(0,0,0,0.1); }
        .stack-icon {
            width: 30px; height: 40px; background: #ccc; border: 1px solid #999;
            position: relative; display: block; margin-bottom: 5px;
        }
        /* Existing Icons */
        .icon-top .child { position: absolute; top:0; left:0; width:100%; height:100%; background:#3498db; border:1px solid white; z-index:2; opacity:0.8; }
        .icon-bottom .child { position: absolute; top:0; left:0; width:100%; height:100%; background:#2c3e50; border:1px solid white; z-index:-1; }
        .icon-up .child { position: absolute; top:-15px; left:0; width:100%; height:100%; background:#e67e22; border:1px solid white; z-index:2; opacity:0.9; }
        .icon-down .child { position: absolute; top:15px; left:0; width:100%; height:100%; background:#9b59b6; border:1px solid white; z-index:2; opacity:0.9; }
        .icon-bottom-exp .child { position: absolute; top:20px; left:0; width:100%; height:100%; background:#27ae60; border:1px solid white; z-index:-1; opacity: 0.9; }
        
        /* New Puzzle Icons */
        .icon-p-top .child { position: absolute; top:-38px; left:0; width:100%; height:100%; background:#e74c3c; border:1px solid white; z-index:2; }
        .icon-p-bottom .child { position: absolute; top:38px; left:0; width:100%; height:100%; background:#e74c3c; border:1px solid white; z-index:2; }
        .icon-p-left .child { position: absolute; top:0; left:-28px; width:100%; height:100%; background:#e74c3c; border:1px solid white; z-index:2; }
        .icon-p-right .child { position: absolute; top:0; left:28px; width:100%; height:100%; background:#e74c3c; border:1px solid white; z-index:2; }

        .rotated-view #main-board { transform: rotate(180deg); }

		/* --- ä¿®æ”¹éƒ¨åˆ†ï¼šå°‡ä½ç½®é¸æ“‡å™¨æ”¹ç‚ºç¶²æ ¼ä½ˆå±€ (ä»¿ç…§ UI A) --- */
        #position-list {
            flex: 1; 
            overflow-y: auto; 
            display: flex; 
            flex-wrap: wrap; /* å…è¨±æ›è¡Œ */
            gap: 8px;        /* é–“è· */
            padding: 15px; 
            background: #eee; 
            border-radius: 4px; 
            min-height: 0;
            align-content: flex-start;
            justify-content: flex-start; /* é å·¦å°é½Šï¼Œç¬¦åˆé–±è®€é †åº */
        }

        /* æ’æ§½æ¨£å¼ï¼šçœ‹èµ·ä¾†åƒä¸€å¼µè™›ç·šå¡ç‰‡ */
        .position-slot {
            width: var(--card-width); 
            height: var(--card-height);
            background: rgba(255, 255, 255, 0.5); 
            border: 2px dashed #999;
            border-radius: 4px;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-size: 0.7rem;
            color: #555;
            cursor: pointer;
            transition: all 0.2s;
            flex-shrink: 0;
            position: relative;
        }
        
        .position-slot:hover { 
            background: #dff9fb; 
            border-color: #2980b9; 
            color: #2980b9; 
            font-weight: bold;
            transform: scale(1.05);
            z-index: 10;
        }
        
        /* åƒè€ƒå¡æ¨£å¼ï¼šé¡¯ç¤ºåœ¨æ’æ§½ä¸­é–“ï¼Œåƒ…ä¾›åƒè€ƒï¼Œä¸å¯é»æ“Š */
        .position-card-ref {
            width: var(--card-width); 
            height: var(--card-height);
            border: 1px solid #ccc;
            border-radius: 3px;
            background-color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.6rem;
            color: #aaa;
            opacity: 0.7; /* ç¨å¾®æ·¡åŒ–ï¼Œå€åˆ†å¯é»æ“Šå€åŸŸ */
            pointer-events: none; /* ç¦æ­¢é»æ“Š */
            flex-shrink: 0;
            background-size: cover;
            background-position: center;
            box-shadow: 1px 1px 2px rgba(0,0,0,0.1);
            overflow: hidden;
            text-align: center;
            padding: 2px;
        }
        
        /* ç‚ºäº†è®“è¦–è¦ºå‹•ç·šæ›´æ¸…æ¥šï¼Œæˆ‘å€‘å¯ä»¥åŠ ä¸€å€‹å°ç®­é ­æˆ–ç·šæ¢ (é¸æ“‡æ€§) */
        .position-card-ref::after {
            content: "â–¶";
            position: absolute;
            right: -12px;
            top: 50%;
            transform: translateY(-50%);
            color: #ccc;
            font-size: 8px;
            display: none; /* æš«æ™‚éš±è—ï¼Œé¿å…å¤ªäº‚ */
        }
		
		/* --- [æ–°å¢] çˆªç—•ç‰¹æ•ˆæ¨£å¼ --- */
		.claw-overlay {
			position: absolute;
			top: 0; left: 0; width: 100%; height: 100%;
			pointer-events: none; /* è®“æ»‘é¼ å¯ä»¥ç©¿é€é»æ“Šå¡ç‰‡ */
			z-index: 50;
			display: flex;
			justify-content: center;
			align-items: center;
			opacity: 0.9;
		}

		.claw-svg {
			width: 80%;
			height: 80%;
			overflow: visible;
		}

		.claw-path {
			fill: none;
			stroke: #c0392b; /* è¡€ç´…è‰² */
			stroke-width: 8;
			stroke-linecap: round;
			filter: drop-shadow(1px 1px 2px rgba(0,0,0,0.5));
		}

		/* æ’­æ”¾æ™‚çš„å‹•ç•« Class */
		.claw-anim .claw-path {
			stroke-dasharray: 100;
			stroke-dashoffset: 100;
			animation: scratch-anim 0.3s cubic-bezier(0.25, 1, 0.5, 1) forwards;
		}

		/* è®“ä¸‰æ¢çˆªç—•æœ‰æ™‚é–“å·®ï¼Œçœ‹èµ·ä¾†æ›´åƒæŠ“æ“Š */
		.claw-anim .p1 { animation-delay: 0s; }
		.claw-anim .p2 { animation-delay: 0.1s; }
		.claw-anim .p3 { animation-delay: 0.05s; }

		@keyframes scratch-anim {
			to { stroke-dashoffset: 0; }
		}
		
		/* --- [æ–°å¢] å‹åˆ©æ…¶ç¥å‹•ç•« --- */
        #win-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; /* è®“æ»‘é¼ å¯ç©¿é€ */
            z-index: 2000;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.4);
            overflow: hidden;
        }

        .win-text {
            font-size: 5rem;
            font-weight: 900;
            text-transform: uppercase;
            color: #f1c40f;
            text-shadow: 0 0 20px rgba(0,0,0,0.8), 3px 3px 0 #c0392b;
            transform: scale(0);
            animation: win-pop 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }

        .win-sub {
            font-size: 2rem;
            color: white;
            margin-top: 10px;
            opacity: 0;
            animation: slideUp 0.5s ease 0.5s forwards;
            text-shadow: 0 0 5px black;
        }
        
        /* ç°¡å–®çš„å½©å¸¶ç‰¹æ•ˆ (ä½¿ç”¨å½å…ƒç´ æ¨¡æ“¬) */
        .confetti {
            position: absolute;
            width: 10px; height: 10px;
            background-color: #f00;
            animation: confetti-fall 3s linear infinite;
        }

        @keyframes win-pop {
            0% { transform: scale(0) rotate(-15deg); opacity: 0; }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }
        
        @keyframes confetti-fall {
            0% { transform: translateY(-100px) rotate(0deg); opacity: 1; }
            100% { transform: translateY(800px) rotate(720deg); opacity: 0; }
        }
		
        @keyframes slideUp { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
    </style>
</head>
<body>

<svg id="svg-layer">
    <defs>
        <marker id="arrowhead" markerWidth="12" markerHeight="12" refX="10" refY="6" orient="auto" markerUnits="userSpaceOnUse">
            <path d="M0,0 L12,6 L0,12" fill="#e74c3c" />
        </marker>
    </defs>
</svg>

<div id="toolbar">
    <div style="font-weight: 800; font-size: 1.1rem; margin-right: 10px; color: #f1c40f;">DM Editor</div>
    <button onclick="openSetupModal()">Setup / Clear</button>
    <button onclick="rotateBoard()">ğŸ”„ æ›äºº (Switch Turn)</button>
    <div style="width: 1px; height: 20px; background: #555; margin: 0 5px;"></div>
    <button onclick="resetBoard(1)" title="é‡ç½® P1 ç›¤é¢">P1 é‡ç½®</button>
    <button onclick="resetBoard(2)" title="é‡ç½® P2 ç›¤é¢">P2 é‡ç½®</button>
	<button onclick="triggerWin(1)" style="background:#f39c12; border-color:#d35400;">ğŸ† 1P Win</button>
    <button onclick="triggerWin(2)" style="background:#f39c12; border-color:#d35400;">ğŸ† 2P Win</button>
    <div style="flex:1"></div>
    <button onclick="document.getElementById('import-input').click()">åŒ¯å…¥ (Import)</button>
    <input type="file" id="import-input" style="display:none" onchange="importData(this)">
    <button onclick="exportData()">åŒ¯å‡º (Export)</button>
</div>

<div id="draft-bar">
    <span>âš ï¸ ç·¨è¼¯ä¸­... (å·²ç´¯ç© <span id="draft-count">0</span> å€‹æ“ä½œ)</span>
    <label title="é–‹å•Ÿæ­¤é¸é …å¾Œï¼Œæœ¬æ¬¡ç·¨è¼¯çš„çµæœå°‡æœƒå½±éŸ¿å¾ŒçºŒæ‰€æœ‰æ­¥é©Ÿçš„ç‹€æ…‹ (å¯èƒ½å°è‡´ä¸å¯é æœŸçš„çµæœ)">
        <input type="checkbox" id="propagate-check"> ğŸ”— é€£å‹•æ›´æ–°å¾ŒçºŒ
    </label>
    <div style="display:flex; gap:10px;">
        <button onclick="cancelDraft()" class="danger">å–æ¶ˆ</button>
        <button onclick="saveDraft()" class="primary">ğŸ’¾ å„²å­˜æ­¤æ­¥</button>
    </div>
</div>

<div id="point-bar">
    <span>ğŸ‘‰ æŒ‡å‘æ¨¡å¼ï¼šè«‹é¸æ“‡ç›®æ¨™ (å¯é¸æ“‡ä»»æ„å¡ç‰‡æˆ–å€åŸŸ)</span>
    <div style="display:flex; gap:10px;">
        <span id="point-target-info" style="font-size:0.8rem; align-self:center;"></span>
        <button id="btn-confirm-point" class="primary" style="display:none;" onclick="confirmPointTargets()">âœ… ç¢ºèªæŒ‡å‘</button>
        <button onclick="cancelPointMode()" class="danger">å–æ¶ˆ</button>
    </div>
</div>

<div id="workspace">
    <div id="ability-stack-zone">
        <div id="ability-zone-p2" class="ability-column">
            <div class="ability-label">P2 èƒ½åŠ› (å¾…è™•ç†)</div>
        </div>
        <div id="ability-zone-p1" class="ability-column">
            <div class="ability-label">P1 èƒ½åŠ› (å¾…è™•ç†)</div>
        </div>
    </div>

    <div id="game-board-container">
        <div id="main-board">
            
            <div id="reveal-zone" class="zone" data-zone="reveal-zone">
                <span class="zone-label">å±•ç¤ºå€ (Reveal Zone)</span>
                <button class="mini-btn danger" style="position:absolute; top:5px; right:5px;" onclick="closeRevealZone()">âœ•</button>
            </div>

            <div id="player2-area" class="player-area">
                <div class="turn-bar"></div>
                <div class="battle-zone zone" data-zone="p2-battle" onclick="handleZoneClick('p2-battle')"><span class="zone-label">P2 æˆ°é¬¥å ´</span></div>
                <div class="shield-zone zone" data-zone="p2-shield" onclick="handleZoneClick('p2-shield')"><span class="zone-label">P2 è­·ç›¾å€</span></div>
                <div class="mana-zone zone" data-zone="p2-mana" onclick="handleZoneClick('p2-mana')"><span class="zone-label">P2 é­”åŠ›å€</span></div>
                <div class="bottom-row">
                    <div class="hand-zone zone" data-zone="p2-hand" onclick="handleZoneClick('p2-hand')"><span class="zone-label">P2 æ‰‹ç‰Œ</span></div>
                    <div class="side-zone-group">
                        <div class="hyper-zone zone stacked" data-zone="p2-hyper" onclick="handleZoneClick('p2-hyper')"><span class="zone-label">è¶…æ¬¡å…ƒ</span></div>
                        <div class="grave-zone zone stacked" data-zone="p2-grave" onclick="handleZoneClick('p2-grave')"><span class="zone-label">å¢“åœ°</span></div>
                        <div class="deck-zone zone stacked" data-zone="p2-deck" onclick="handleZoneClick('p2-deck')"><span class="zone-label">ç‰Œåº«</span></div>
                    </div>
                </div>
            </div>

            <div id="player1-area" class="player-area">
                <div class="turn-bar"></div>
                <div class="battle-zone zone" data-zone="p1-battle" onclick="handleZoneClick('p1-battle')"><span class="zone-label">P1 æˆ°é¬¥å ´</span></div>
                <div class="shield-zone zone" data-zone="p1-shield" onclick="handleZoneClick('p1-shield')"><span class="zone-label">P1 è­·ç›¾å€</span></div>
                <div class="mana-zone zone" data-zone="p1-mana" onclick="handleZoneClick('p1-mana')"><span class="zone-label">P1 é­”åŠ›å€</span></div>
                <div class="bottom-row">
                    <div class="hand-zone zone" data-zone="p1-hand" onclick="handleZoneClick('p1-hand')"><span class="zone-label">P1 æ‰‹ç‰Œ</span></div>
                    <div class="side-zone-group">
                        <div class="deck-zone zone stacked" data-zone="p1-deck" onclick="handleZoneClick('p1-deck')"><span class="zone-label">ç‰Œåº«</span></div>
                        <div class="grave-zone zone stacked" data-zone="p1-grave" onclick="handleZoneClick('p1-grave')"><span class="zone-label">å¢“åœ°</span></div>
                        <div class="hyper-zone zone stacked" data-zone="p1-hyper" onclick="handleZoneClick('p1-hyper')"><span class="zone-label">è¶…æ¬¡å…ƒ</span></div>
                    </div>
                </div>
            </div>

        </div>
    </div>

    <div id="timeline-panel">
        <div id="timeline-header">
            <span style="flex:1;">Action Log</span>
            <small style="font-weight:normal; opacity:0.8; margin-right:5px;" id="step-counter">0/0</small>
            <button class="mini-btn delete-all" onclick="deleteAllActions()" title="åˆªé™¤æ‰€æœ‰å‹•ä½œä¸¦é‡æ–°è¨­å®š">ğŸ—‘ï¸é‡è¨­</button>
        </div>
        <ul id="action-list"></ul>
        <div style="padding: 10px; background: #ecf0f1; border-top:1px solid #bdc3c7;">
            <div style="display: flex; gap:5px; justify-content: center; margin-bottom: 5px;">
                <button onclick="prevStep()">â—€</button>
                <button onclick="togglePlay()" id="btn-play">â–¶ æ’­æ”¾</button>
                <button onclick="nextStep()">â–¶</button>
            </div>
        </div>
    </div>
</div>

<div id="card-action-panel">
    <button id="btn-rotate-l" onclick="rotateCard(-90)">â†¶</button>
    <button id="btn-rotate-r" onclick="rotateCard(90)">â†·</button>
    <button id="btn-flip" onclick="flipCard()">ç¿»é¢</button>
	<button id="btn-injured" style="display:none; background:#e74c3c; border-color:#c0392b;" onclick="toggleInjured()">ğŸ’” å—å‚·</button>
    <button id="btn-glow" onclick="toggleGlow()">ğŸ’¡ç™¼å…‰</button>
    <button id="btn-unglow" style="display:none;" onclick="removeGlow()">âœ•</button>
    <button id="btn-copy-ability" onclick="copyToAbility()">âš¡èƒ½åŠ›</button>
    <button id="btn-reveal" onclick="revealCards()">ğŸ‘ï¸ å±•ç¤º</button>
    <button id="btn-point" style="display:none; background:#8e44ad; border-color:#9b59b6;" onclick="enterPointMode()">ğŸ‘‰ æŒ‡å‘</button>
    <button id="btn-end-point" style="display:none; background:#95a5a6; border-color:#7f8c8d;" onclick="endPoint()">ğŸ›‘ çµæŸæŒ‡å‘</button>
    <button onclick="pasteImageMode()">ğŸ–¼ï¸ ä¸Šåœ– (Ctrl+V)</button>
    <button id="btn-remove-image" style="display:none; background:#e74c3c;" onclick="removeImage()">âœ• åœ–</button>
    <div style="border-left:1px solid #7f8c8d; height:20px; margin:0 5px;"></div>
    <input type="text" id="rename-input" placeholder="åç¨±..." onkeydown="if(event.key==='Enter') renameCard()" style="width: 80px;">
    <button onclick="renameCard()">æ›´å</button>
    <input type="text" id="note-input" placeholder="è¨»è¨˜..." onkeydown="if(event.key==='Enter') addCardNote()" style="width: 80px;">
    <button onclick="addCardNote()">ğŸ“è¨»è¨˜</button>
    
    <div id="ability-adjust-controls" style="display:none; border-left:1px solid #7f8c8d; height:20px; margin:0 5px;"></div>
    <div id="ability-adjust-buttons" style="display:none; gap:5px; align-items:center;">
        <small>ä½ç§»:</small>
        <button onclick="adjustAbilityCard('panX', -10)">â¬…</button>
        <button onclick="adjustAbilityCard('panX', 10)">â¡</button>
        <button onclick="adjustAbilityCard('panY', -10)">â¬†</button>
        <button onclick="adjustAbilityCard('panY', 10)">â¬‡</button>
        <small>ç¸®æ”¾:</small>
        <button onclick="adjustAbilityCard('scale', 0.1)">+</button>
        <button onclick="adjustAbilityCard('scale', -0.1)">-</button>
    </div>

    <div style="border-left:1px solid #7f8c8d; height:20px; margin:0 5px;"></div>
    <button id="btn-delete-card" class="danger" style="display:none;" onclick="deleteSelectedCard()">ğŸ—‘ï¸ åˆªé™¤</button>
    <button class="danger" onclick="cancelSelection()">âœ• (ESC)</button>
</div>

<div id="setup-modal" class="modal">
    <div class="modal-content">
        <h3 style="margin-top:0; text-align:center;">é–‹å±€è¨­å®š</h3>
        <div style="background:#fff3cd; padding:5px; margin-bottom:10px; font-size:0.85rem; border-radius:4px; text-align:center;">
            æ³¨æ„ï¼šé–‹å§‹æ–°å±€æœƒæ¸…é™¤ç•¶å‰æœªåŒ¯å‡ºçš„é€²åº¦ã€‚
        </div>
        <div class="input-group">
            <label>P1 ç‰Œåº«æ•¸:</label>
            <input type="number" id="setup-p1-deck" value="40" min="40" max="60">
        </div>
        <div class="input-group">
            <label>P1 è¶…æ¬¡å…ƒ:</label>
            <input type="number" id="setup-p1-hyper" value="8" min="0" max="8">
        </div>
        <hr style="width:100%; border:0; border-top:1px dashed #ccc;">
        <div class="input-group">
            <label>P2 ç‰Œåº«æ•¸:</label>
            <input type="number" id="setup-p2-deck" value="40" min="40" max="60">
        </div>
        <div class="input-group">
            <label>P2 è¶…æ¬¡å…ƒ:</label>
            <input type="number" id="setup-p2-hyper" value="8" min="0" max="8">
        </div>
        <div style="margin-top:20px; display:flex; justify-content:space-between;">
            <button onclick="clearStorage()" style="background:#7f8c8d;">æ¸…é™¤å­˜æª”</button>
            <button onclick="finishSetup()" class="primary">é–‹å§‹éŠæˆ² (Start)</button>
        </div>
    </div>
</div>

<div id="card-selector-modal" class="modal">
    <div class="modal-content">
        <div style="display:flex; justify-content:space-between; margin-bottom:10px;">
            <span id="modal-title" style="font-weight:bold; font-size:1.2rem;">Zone</span>
            <button onclick="closeSelectorModal()" style="border:none; background:none; font-size:1.5rem;">âœ•</button>
        </div>
        <div id="modal-body"></div>
        <div style="margin-top:15px; display:flex; gap:10px; justify-content:flex-end;">
            <button onclick="actionShuffleZone()" style="background:#8e44ad;">æ´—ç‰Œæ­¤å€</button>
            <button onclick="prepareMove(true)" style="background:#d35400;">æ´—ç‰Œé¸å–ç‰Œä¸¦ç§»å‹•...</button>
            <button onclick="revealFromSelector()" style="background:#3498db;">ğŸ‘ï¸ å±•ç¤º</button>
            <button onclick="prepareMove(false)" style="background:#2980b9;">ç§»å‹•é¸å–ç‰Œ...</button>
        </div>
    </div>
</div>

<div id="position-selector-modal" class="modal">
    <div class="modal-content">
        <div id="pos-modal-title" style="font-weight:bold; font-size:1.2rem; margin-bottom:10px;">å †ç–Šæ“ä½œ</div>
        <div style="margin-bottom:10px; font-size:0.9rem; color:#666;">è«‹é»æ“Šåœ–ç¤ºé¸æ“‡å †ç–Šæ–¹å¼ï¼š</div>
        
        <div id="stack-gui">
            <div class="stack-option" onclick="confirmStackMove('top')">
                <div class="stack-icon icon-top"><div class="child"></div></div>
                <span>ç–Šåœ¨ä¸Šæ–¹<br>(Cover Top)</span>
            </div>
            <div class="stack-option" onclick="confirmStackMove('bottom')">
                <div class="stack-icon icon-bottom"><div class="child"></div></div>
                <span>ç–Šåœ¨ä¸‹æ–¹<br>(Underneath)</span>
            </div>
            <div class="stack-option" onclick="confirmStackMove('puzzle_top')">
                <div class="stack-icon icon-p-top"><div class="child"></div></div>
                <span>æ‹¼åœ¨ä¸Šæ–¹<br>(Puzzle Top)</span>
            </div>
            <div class="stack-option" onclick="confirmStackMove('puzzle_bottom')">
                <div class="stack-icon icon-p-bottom"><div class="child"></div></div>
                <span>æ‹¼åœ¨ä¸‹æ–¹<br>(Puzzle Btm)</span>
            </div>
             <div class="stack-option" onclick="confirmStackMove('puzzle_left')">
                <div class="stack-icon icon-p-left"><div class="child"></div></div>
                <span>æ‹¼åœ¨å·¦é‚Š<br>(Puzzle Left)</span>
            </div>
             <div class="stack-option" onclick="confirmStackMove('puzzle_right')">
                <div class="stack-icon icon-p-right"><div class="child"></div></div>
                <span>æ‹¼åœ¨å³é‚Š<br>(Puzzle Right)</span>
            </div>
            
            <div class="stack-option" onclick="confirmStackMove('shift_up')">
                <div class="stack-icon icon-up"><div class="child"></div></div>
                <span>ä¸Šæ–¹ (éœ²å‡ºåº•)<br>(Shift Up)</span>
            </div>
            <div class="stack-option" onclick="confirmStackMove('shift_down')">
                <div class="stack-icon icon-down"><div class="child"></div></div>
                <span>ä¸Šæ–¹ (éœ²å‡ºé ‚)<br>(Shift Down)</span>
            </div>
            <div class="stack-option" onclick="confirmStackMove('bottom_exposed')">
                <div class="stack-icon icon-bottom-exp"><div class="child"></div></div>
                <span>ä¸‹æ–¹ (éœ²å‡ºåº•)<br>(Bottom Exposed)</span>
            </div>
        </div>
        <div id="position-list" style="display:none;"></div> 
        <div style="margin-top:15px; text-align:right;">
            <button onclick="closePositionModal()" class="danger">å–æ¶ˆ</button>
        </div>
    </div>
</div>

<div id="import-conflict-modal" class="modal">
    <div class="modal-content" style="width: 400px; text-align: center;">
        <h3>ç™¼ç¾å¤–éƒ¨åŠ‡æœ¬</h3>
        <p>ç¶²å€åƒæ•¸åŒ…å«åŠ‡æœ¬æª”ï¼Œä½†åµæ¸¬åˆ°æ‚¨æœ‰æœªå„²å­˜çš„æœ¬åœ°é€²åº¦ã€‚</p>
        <p>è«‹å•è¦å¦‚ä½•è™•ç†ï¼Ÿ</p>
        <div style="display: flex; flex-direction: column; gap: 10px; margin-top: 15px;">
            <button onclick="resolveImportConflict('cancel')" style="padding: 10px;">âŒ ä¸åŒ¯å…¥ (ä½¿ç”¨æœ¬åœ°å­˜æª”)</button>
            <button onclick="resolveImportConflict('save')" style="padding: 10px; background: #2ecc71;">ğŸ’¾ å­˜æª”ç„¶å¾ŒåŒ¯å…¥</button>
            <button onclick="resolveImportConflict('overwrite')" style="padding: 10px; background: #e74c3c;">âš ï¸ ä¸å­˜æª”ç›´æ¥åŒ¯å…¥</button>
        </div>
    </div>
</div>
<script>
    class Card {
        constructor(id, ownerId, text, zone) {
            this.id = id;
            this.ownerId = ownerId;
            this.text = text;
            this.zone = zone;
            this.faceUp = false;
            this.rotation = 0; 
            this.power = 0;
            this.image = null;
            this.isHyper = false;
            this.glow = null; 
            this.parentId = null; 
            this.stackType = null; // top, bottom, shift_up, puzzle_right, etc.
            this.note = "";
            this.imageKey = 'img_' + id;
            this.backImageKey = 'img_back_' + id;
            this.sourceId = null; // New: Link to source card (for Ability cards)
        }
    }

    class GameState {
        constructor() {
            this.cards = [];
            this.turnPlayer = 1;
            // Removed phase per requirement
            this.globalRotation = false; 
            this.cardIdCounter = 1;
        }
    }

    class Action {
        constructor(description) {
            this.id = Date.now() + Math.random();
            this.description = description;
            this.operations = []; 
        }
    }

    let history = [];
    let currentIndex = -1;
    let initialState = null;
    let isDrafting = false;
    let draftOperations = []; 
    let insertIndex = -1; 
    let tempState = null; 
    let selectedCardsInModal = []; 
    let pendingMove = null; 
    let playInterval = null;
    let lastRenderedState = null;
    let editModeType = 'INSERT';
    
    let isPointing = false;
    let pointerId = null;
    let pointTargets = []; 
    let currentStackTargetId = null;
	
	let lastAnimatedStep = -1; // [è£œä¸Šé€™è¡Œ] ç”¨æ–¼è¨˜éŒ„å‹•ç•«ç‹€æ…‹ï¼Œé¿å…é‡è¤‡æ’­æ”¾
	let winOverlayTimeout = null; // [æ–°å¢] ç”¨ä¾†è¨˜éŒ„å‹åˆ©ç•«é¢çš„è‡ªå‹•é—œé–‰è¨ˆæ™‚å™¨
    
    let globalImageRegistry = {}; 
    let globalAbilityStyleRegistry = {}; 
    let storageQuotaExceeded = false; 
    let hasAlertedQuota = false;    
    let pendingImportData = null;

    const STORAGE_KEY = 'dm_editor_data_v1'; // Updated Key
    const STORAGE_EXPIRY = 7 * 24 * 60 * 60 * 1000; 

	document.addEventListener('keydown', (e) => {
        // è™•ç† Ctrl+Z (æˆ– Mac çš„ Cmd+Z)
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {
            if (isDrafting) {
                e.preventDefault(); // é˜»æ­¢ç€è¦½å™¨åŸæœ¬çš„å¾©åŸå‹•ä½œ
                undoLastDraftOp();
                return;
            }
        }

        // è™•ç† ESC
        if (e.key === 'Escape') {
            const cardModal = document.getElementById('card-selector-modal');
            const posModal = document.getElementById('position-selector-modal');
            
            if (posModal && posModal.style.display === 'flex') {
                closePositionModal();
            } else if (cardModal && cardModal.style.display === 'flex') {
                closeSelectorModal();
            } else if (isPointing) {
                cancelPointMode();
            } else {
                cancelSelection();
            }
        }
    });  
  
    // Paste Image Handling
    document.addEventListener('paste', (e) => {
        if (!pendingMove || pendingMove.cardIds.length !== 1) return;
        
        const items = (e.clipboardData || e.originalEvent.clipboardData).items;
        for (let index in items) {
            const item = items[index];
            if (item.kind === 'file' && item.type.startsWith('image/')) {
                const blob = item.getAsFile();
                const reader = new FileReader();
                reader.onload = (event) => {
                    processImage(event.target.result);
                };
                reader.readAsDataURL(blob);
                break;
            }
        }
    });
    
    function pasteImageMode() {
        if (!pendingMove || pendingMove.cardIds.length !== 1) {
            alert("è«‹å…ˆé¸æ“‡ä¸€å¼µå¡ç‰‡ï¼Œç„¶å¾ŒæŒ‰ä¸‹ Ctrl+V è²¼ä¸Šåœ–ç‰‡");
            return;
        }
        window.focus();
    }
    
    function processImage(dataUrl) {
        const img = new Image();
        img.onload = () => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const targetW = 100;
            const targetH = 140;
            canvas.width = targetW;
            canvas.height = targetH;
            ctx.drawImage(img, 0, 0, targetW, targetH);
            const compressedBase64 = canvas.toDataURL('image/jpeg', 0.8);
            updateCardImageGlobal(pendingMove.cardIds[0], compressedBase64);
        };
        img.src = dataUrl;
    }
    
    function updateCardImageGlobal(cardId, base64) {
        if(!confirm("ç¢ºå®šè¦æ›¿æ›æ­¤å¡ç‰‡çš„åœ–ç‰‡å—ï¼Ÿ(é€™å°‡å½±éŸ¿æ‰€æœ‰åŠ‡æœ¬)")) return;
        
        const state = getCurrentDisplayState();
        const targetCard = state.cards.find(c => c.id === cardId);
        if(!targetCard) return;

        if (!targetCard.imageKey) {
            targetCard.imageKey = 'img_' + targetCard.id;
            targetCard.backImageKey = 'img_back_' + targetCard.id;
        }

        let keyToUpdate = targetCard.imageKey;
        if (targetCard.isHyper && !targetCard.faceUp) {
             keyToUpdate = targetCard.backImageKey;
        }

        globalImageRegistry[keyToUpdate] = base64;

        const setFlag = (s) => {
            const c = s.cards.find(x => x.id === cardId);
            if(c) {
                if (!c.imageKey) {
                    c.imageKey = 'img_' + c.id;
                    c.backImageKey = 'img_back_' + c.id;
                }
                c.image = true; 
            }
            
            s.cards.forEach(other => {
                if (!other.imageKey && other.id === cardId) { 
                     other.imageKey = 'img_' + other.id; 
                }
                
                if (other.imageKey === keyToUpdate || other.backImageKey === keyToUpdate) {
                    other.image = true;
                }
            });
        };
        
        setFlag(initialState);
        history.forEach(h => setFlag(h.state));
        if (tempState) setFlag(tempState);
        
        renderUI();
        saveToStorage();
    }
    
    function removeImage() {
        if (!pendingMove || pendingMove.cardIds.length !== 1) return;
        const cardId = pendingMove.cardIds[0];
        const state = getCurrentDisplayState();
        const card = state.cards.find(c => c.id === cardId);
        if(!card) return;

        if (!card.imageKey) {
            card.imageKey = 'img_' + card.id;
            card.backImageKey = 'img_back_' + card.id;
        }

        let keyToUpdate = card.imageKey;
        if (card.isHyper && !card.faceUp) {
             keyToUpdate = card.backImageKey;
        }
        
        if(!confirm("ç¢ºå®šç§»é™¤åœ–ç‰‡ï¼Ÿ")) return;
        
        delete globalImageRegistry[keyToUpdate];

        const unsetFlag = (s) => {
            const c = s.cards.find(x => x.id === cardId);
            if(c) c.image = false;
            
            s.cards.forEach(other => {
                if (other.imageKey === keyToUpdate || other.backImageKey === keyToUpdate) {
                    other.image = false;
                }
            });
        };

        unsetFlag(initialState);
        history.forEach(h => unsetFlag(h.state));
        if (tempState) unsetFlag(tempState);

        saveToStorage();
        renderUI();
    }

    function cloneState(state) {
        return JSON.parse(JSON.stringify(state));
    }

    function openSetupModal() {
        const modal = document.getElementById('setup-modal');
        if(modal) modal.style.display = 'flex';
    }

    function clearStorage() {
        if(confirm("ç¢ºå®šè¦æ¸…é™¤æ‰€æœ‰è‡ªå‹•å­˜æª”å—ï¼Ÿ")) {
            localStorage.removeItem(STORAGE_KEY);
            alert("å­˜æª”å·²æ¸…é™¤ã€‚");
            location.reload();
        }
    }
    
    function deleteAllActions() {
        if(!confirm("ç¢ºå®šè¦åˆªé™¤æ‰€æœ‰å‹•ä½œä¸¦é‡æ–°é–‹å§‹æ–°å±€å—ï¼Ÿ")) return;
        
        history = [];
        initialState = null;
        currentIndex = -1;
        draftOperations = [];
        isDrafting = false;
        
        localStorage.removeItem(STORAGE_KEY);
        storageQuotaExceeded = false;
        hasAlertedQuota = false;

        document.getElementById('action-list').innerHTML = '';
        document.getElementById('step-counter').innerText = '0/0';
        updateDraftBar();
        
        openSetupModal();
    }

    function finishSetup() {
        try {
            const getVal = (id, def) => {
                const el = document.getElementById(id);
                if(!el) return def;
                const val = parseInt(el.value);
                return isNaN(val) ? def : val;
            };

            const p1d = getVal('setup-p1-deck', 40);
            const p1h = getVal('setup-p1-hyper', 8);
            const p2d = getVal('setup-p2-deck', 40);
            const p2h = getVal('setup-p2-hyper', 8);
            
            initGame({p1d, p1h, p2d, p2h});
            document.getElementById('setup-modal').style.display = 'none';
        } catch (e) {
            console.error(e);
            alert("åˆå§‹åŒ–å¤±æ•—: " + e.message);
        }
    }

    function initGame(config) {
        const state = new GameState();
        globalImageRegistry = {}; 
        globalAbilityStyleRegistry = {};
        
        if(!config) config = {p1d:40, p1h:8, p2d:40, p2h:8};

        const zones = [
            {id: 'p1-deck', count: config.p1d, prefix: 'C'}, {id: 'p1-hyper', count: config.p1h, prefix: 'H', hyper:true},
            {id: 'p2-deck', count: config.p2d, prefix: 'C'}, {id: 'p2-hyper', count: config.p2h, prefix: 'H', hyper:true}
        ];
        
        state.cards = []; 
        
        zones.forEach(z => {
            for(let i=0; i<z.count; i++) {
                let c = new Card(state.cardIdCounter++, z.id.startsWith('p1')?1:2, `${z.prefix}-${i+1}`, z.id);
                if(z.hyper) { c.isHyper=true; c.faceUp=true; }
                state.cards.push(c);
            }
        });

        initialState = cloneState(state);
        history = [];
        let initAct = new Action('éŠæˆ²é–‹å§‹');
        initAct.operations.push({type: 'INIT'});
        history.push({ action: initAct, state: initialState });
        currentIndex = 0;

        isDrafting = false;
        draftOperations = [];
        updateDraftBar();
        renderUI();
        saveToStorage();
    }

    function saveToStorage() {
        try {
            const data = {
                timestamp: Date.now(),
                history: history,
                initialState: initialState,
                currentIndex: currentIndex,
                imageRegistry: globalImageRegistry,
                abilityRegistry: globalAbilityStyleRegistry 
            };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
            if (storageQuotaExceeded) {
                storageQuotaExceeded = false;
                hasAlertedQuota = false;
            }
        } catch(e) {
            console.warn("Storage save failed (Quota?)", e);
            storageQuotaExceeded = true;
            if (!hasAlertedQuota) {
                alert("âš ï¸ è‡ªå‹•å­˜æª”å¤±æ•—ï¼šå„²å­˜ç©ºé–“å·²æ»¿ã€‚\n\nå»ºè­°æ‚¨ç«‹å³ã€ŒåŒ¯å‡ºã€ä¿å­˜é€²åº¦ï¼Œå¦å‰‡é—œé–‰è¦–çª—å¾Œè³‡æ–™å°‡æœƒéºå¤±ã€‚");
                hasAlertedQuota = true;
            }
        }
    }

    function loadFromStorage() {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return false;
        try {
            const data = JSON.parse(raw);
            if (!data || !data.history || !data.initialState) return false;
            if (data.timestamp && (Date.now() - data.timestamp > STORAGE_EXPIRY)) {
                localStorage.removeItem(STORAGE_KEY);
                return false;
            }
            
            history = data.history;
            initialState = data.initialState;
            currentIndex = (typeof data.currentIndex === 'number' && data.currentIndex >= -1 && data.currentIndex < history.length) 
                           ? data.currentIndex 
                           : (history.length - 1);
                           
            globalImageRegistry = data.imageRegistry || {}; 
            globalAbilityStyleRegistry = data.abilityRegistry || {}; 
            
            try { renderUI(); } catch(e) {}
            return true;
        } catch (e) {
            return false;
        }
    }

    function getCurrentDisplayState() {
        return isDrafting ? tempState : ((currentIndex >= 0 && currentIndex < history.length) ? history[currentIndex].state : initialState);
    }

    function startDraftAtEnd() {
        startDraft(history.length);
    }

	function startDraft(index) {
        if (isDrafting) {
            if(!confirm("ç›®å‰æœ‰æœªå„²å­˜çš„è®Šæ›´ï¼Œæ˜¯å¦æ¨æ£„ä¸¦é–‹å§‹æ–°æ­¥é©Ÿï¼Ÿ")) return;
        }
        
        isDrafting = true;
        insertIndex = index;
        draftOperations = [];
        editModeType = 'INSERT';
        
        let baseIndex = index - 1;
        if (baseIndex < 0) baseIndex = 0; 
        
        tempState = cloneState(history[baseIndex].state);

        // --- [æ–°å¢] æ¸…é™¤ä¸Šä¸€å±€çš„å—å‚·ç‹€æ…‹ (ä¸ç¹¼æ‰¿) ---
        // é€™æ¨£æ–°æ­¥é©Ÿé–‹å§‹æ™‚ï¼Œå¡ç‰‡æœƒæ¢å¾©ä¹¾æ·¨
        tempState.cards.forEach(c => {
             if(c.isInjured) c.isInjured = false;
        });
        // ------------------------------------------
        
        updateDraftBar();
        renderUI();
    }

    function editAction(index) {
        if (isDrafting) {
            if(!confirm("ç›®å‰æœ‰æœªå„²å­˜çš„è®Šæ›´ï¼Œæ˜¯å¦æ¨æ£„ä¸¦ç·¨è¼¯æ­¤æ­¥é©Ÿï¼Ÿ")) return;
        }
        
        isDrafting = true;
        insertIndex = index; 
        editModeType = 'EDIT';
        
        let baseIndex = index - 1;
        if (baseIndex < 0) {
            tempState = cloneState(initialState);
        } else {
            tempState = cloneState(history[baseIndex].state);
        }
        
        const actionToEdit = history[index].action;
        draftOperations = [...actionToEdit.operations];
        
        draftOperations.forEach(op => applyOperation(tempState, op));
        
        updateDraftBar();
        renderUI();
    }

    function addOperation(op) {
        if (!isDrafting) startDraftAtEnd();
        applyOperation(tempState, op);
        draftOperations.push(op);
        updateDraftBar();
        renderUI();
    }

	// --- æ–°å¢åŠŸèƒ½: é‚„åŸä¸Šä¸€æ­¥ (Ctrl+Z) ---
    function undoLastDraftOp() {
        if (!isDrafting) return;
        if (draftOperations.length === 0) return;

        // 1. ç§»é™¤ Draft ä¸­çš„æœ€å¾Œä¸€å€‹æ“ä½œ
        draftOperations.pop();

        // 2. é‡æ–°è¨ˆç®— tempState
        // å¿…é ˆå¾ Draft é–‹å§‹å‰çš„ç‹€æ…‹ (Base State) é‡æ–°å¥—ç”¨å‰©é¤˜çš„æ“ä½œ
        let baseIndex = insertIndex - 1;
        let baseState;
        
        if (baseIndex < 0) {
            baseState = cloneState(initialState);
        } else {
            // å–å‡ºé€²å…¥ç·¨è¼¯æ¨¡å¼å‰çš„ç‹€æ…‹å¿«ç…§
            baseState = cloneState(history[baseIndex].state);
        }

        // é‡ç½® tempState ç‚ºåˆå§‹ç‹€æ…‹
        tempState = baseState;

        // ä¾åºé‡æ–°åŸ·è¡Œå‰©é¤˜çš„æ‰€æœ‰æ“ä½œ
        draftOperations.forEach(op => applyOperation(tempState, op));

        // 3. æ›´æ–°ä»‹é¢
        updateDraftBar();
        renderUI();
        
        // è‹¥å‰›å¥½é‚„åŸäº†ç§»å‹•æ“ä½œï¼Œå–æ¶ˆç›®å‰çš„é¸å–ç‹€æ…‹ä»¥é¿å… UI éŒ¯äº‚
        cancelSelection(); 
    }
	
    function saveDraft(customDesc) {
        if (draftOperations.length === 0) {
            isDrafting = false;
            updateDraftBar();
            renderUI();
            return;
        }

        let desc = customDesc;
        if (!desc && editModeType === 'EDIT' && insertIndex < history.length) {
             desc = history[insertIndex].action.description;
        }
        if (!desc) {
            const opCount = draftOperations.length;
            const firstOp = draftOperations[0];
            let map = {
                'MOVE': 'ç§»å‹•', 'SHUFFLE': 'æ´—ç‰Œ', 'ROTATE': 'æ—‹è½‰è¦–è§’', 
                'ROTATE_CARD': 'æ—‹è½‰å¡ç‰‡', 'FLIP_CARD': 'ç¿»è½‰å¡ç‰‡', 'RENAME_CARD': 'æ›´å', 
                'RESET_BOARD': 'é‡ç½®ç›¤é¢', 'SET_GLOW': 'è¨­å®šç™¼å…‰', 'CREATE_ABILITY': 'ç”¢ç”Ÿèƒ½åŠ›', 'DELETE_CARD': 'åˆªé™¤å¡ç‰‡',
                'POINT': 'æŒ‡å‘', 'ATTACK': 'æ”»æ“Š', 'ADD_NOTE': 'æ–°å¢è¨»è¨˜', 'ADJUST_STYLE': 'èª¿æ•´æ¨£å¼', 'SWITCH_TURN': 'æ›äºº'
            };
            let typeDesc = map[firstOp.type] || 'æ“ä½œ';
            if (firstOp.type === 'POINT') {
                desc = firstOp.desc || 'æŒ‡å‘';
            } else if (firstOp.type === 'ATTACK') {
                desc = firstOp.desc || 'æ”»æ“Šå®£è¨€';
            } else {
                desc = `${typeDesc} ç­‰ ${opCount} å€‹å‹•ä½œ`;
            }
        }

        const newAction = new Action(desc);
        newAction.operations = [...draftOperations];
        const finalState = cloneState(tempState);
        const newItem = { action: newAction, state: finalState };

        const propagate = document.getElementById('propagate-check').checked;

        const head = history.slice(0, insertIndex);
        let tail = [];
        
        if (editModeType === 'EDIT') {
            tail = history.slice(insertIndex + 1);
        } else {
            tail = history.slice(insertIndex);
        }

        if (propagate) {
            let runningState = cloneState(finalState);
            tail = tail.map(item => {
                try {
                    item.action.operations.forEach(op => applyOperation(runningState, op));
                } catch(e) { console.error("Propagate Error", e); }
                return { action: item.action, state: cloneState(runningState) };
            });
        }

        history = [...head, newItem, ...tail];

        isDrafting = false;
        currentIndex = insertIndex; 
        insertIndex = -1;
        draftOperations = [];
        updateDraftBar();
        renderUI();
        saveToStorage();
    }

    function cancelDraft() {
        isDrafting = false;
        draftOperations = [];
        cancelSelection();
        updateDraftBar();
        if(currentIndex >= history.length) currentIndex = history.length - 1;
        renderUI();
    }

    function updateDraftBar() {
        const bar = document.getElementById('draft-bar');
        if (isDrafting) {
            bar.style.display = 'flex';
            document.getElementById('draft-count').innerText = draftOperations.length;
        } else {
            bar.style.display = 'none';
        }
    }

    function deleteAction(index) {
        if (index === 0) return alert("ç„¡æ³•åˆªé™¤åˆå§‹ç‹€æ…‹");
        if (!confirm("ç¢ºå®šåˆªé™¤æ­¤æ­¥é©Ÿï¼Ÿ")) return;

        const head = history.slice(0, index);
        let tail = history.slice(index + 1);
        
        history = [...head, ...tail];

        lastRenderedState = null; 
        if (currentIndex >= history.length) currentIndex = history.length - 1;
        
        cancelSelection(); 
        renderUI();
        saveToStorage();
    }

function applyOperation(state, op) {
        if (op.type === 'PASS') return;
        
        // --- æ–°å¢: ç”¨æ–¼åˆ‡æ–·é€£çµçš„æ“ä½œ ---
        if (op.type === 'BREAK_LINKS') {
            const { cardIds } = op;
            state.cards.forEach(c => {
                if (cardIds.includes(c.id)) {
                    c.parentId = null;
                    c.stackType = null;
                }
                if (c.parentId && cardIds.includes(c.parentId)) {
                    c.parentId = null;
                    c.stackType = null;
                }
            });
        }
        // --- [æ–°å¢] å‹åˆ©ç‹€æ…‹ ---
        else if (op.type === 'GAME_WIN') {
            const { winnerId } = op;
            state.winner = winnerId; // åœ¨ç‹€æ…‹ä¸­è¨˜éŒ„è´å®¶
        }
        // ----------------------
        else if (op.type === 'MOVE') {
            const { cardIds, toZone, faceUp, shuffleSelection, insertIndex, stackTargetId, stackType } = op;
            let movingCards = state.cards.filter(c => cardIds.includes(c.id));
            
            if(shuffleSelection) movingCards.sort(() => Math.random() - 0.5); 
            
            state.cards = state.cards.filter(c => !cardIds.includes(c.id));
            movingCards.forEach(c => {
                c.zone = toZone;
                c.parentId = null;
                c.stackType = null;
                if (faceUp !== undefined) c.faceUp = faceUp;
                if (toZone.includes('hand') || toZone.includes('deck')) c.rotation = 0; 
                if (stackTargetId) {
                    c.parentId = stackTargetId;
                    c.stackType = stackType;
                }
            });

            if (insertIndex !== undefined && insertIndex !== -1) {
                let zoneCards = state.cards.filter(c => c.zone === toZone);
                let otherCards = state.cards.filter(c => c.zone !== toZone);
                zoneCards.splice(insertIndex, 0, ...movingCards);
                state.cards = [...otherCards, ...zoneCards];
            } else {
                state.cards.push(...movingCards);
            }

        } else if (op.type === 'SHUFFLE') {
            const { zoneId, order } = op; 
            let zoneCards = state.cards.filter(c => c.zone === zoneId);
            let otherCards = state.cards.filter(c => c.zone !== zoneId);
            if (order) {
                zoneCards = order.map(id => state.cards.find(c => c.id === id)).filter(c=>c);
            } else {
                zoneCards.sort(() => Math.random() - 0.5);
            }
            state.cards = [...otherCards, ...zoneCards];

        } else if (op.type === 'ROTATE' || op.type === 'SWITCH_TURN') {
            state.turnPlayer = state.turnPlayer === 1 ? 2 : 1;
        } 
        else if (op.type === 'ROTATE_CARD') {
            const { cardIds, deg, finalRotation } = op;
            state.cards.forEach(c => {
                if (cardIds.includes(c.id)) {
                    if (finalRotation !== undefined) c.rotation = finalRotation;
                    else c.rotation = (c.rotation + deg) % 360;
                }
            });
        }
        else if (op.type === 'FLIP_CARD') {
            const { cardIds, finalFaceUp } = op;
            state.cards.forEach(c => {
                if (cardIds.includes(c.id)) {
                    if (finalFaceUp !== undefined) c.faceUp = finalFaceUp;
                    else c.faceUp = !c.faceUp;
                }
            });
        }
        else if (op.type === 'RENAME_CARD') {
            const { cardIds, text } = op;
            const targets = state.cards.filter(c => cardIds.includes(c.id));
            targets.forEach(target => {
                 state.cards.forEach(c => {
                     if (c.imageKey === target.imageKey) {
                         c.text = text;
                     }
                 });
            });
        }
        else if (op.type === 'RESET_BOARD') {
            const { playerId } = op;
            state.cards.forEach(c => {
                if (c.zone.includes(`p${playerId}-battle`)) {
                    c.rotation = 0;
                }
                else if (c.zone.includes(`p${playerId}-mana`)) {
                    c.rotation = 180;
                }
            });
        }
        else if (op.type === 'SET_GLOW') {
            const { cardIds, color } = op;
            state.cards.forEach(c => {
                if (cardIds.includes(c.id)) {
                    if (c.zone.includes('ability')) {
                        c.glow = color;
                        if (c.sourceId) {
                            const source = state.cards.find(s => s.id === c.sourceId);
                            if (source) {
                                source.glow = color;
                            }
                        }
                    }
                }
            });
        }
        else if (op.type === 'INJURED') {
            const { cardIds, setInjured } = op;
            state.cards.forEach(c => {
                if (cardIds.includes(c.id)) {
                    c.isInjured = setInjured;
                }
            });
        }
        else if (op.type === 'CREATE_ABILITY') {
            const { sourceCardId, targetZone, newId } = op;
            const source = state.cards.find(c => c.id === sourceCardId);
            if (source) {
                let idToUse = newId;
                if (!idToUse) {
                     idToUse = state.cards.reduce((max, c) => Math.max(max, c.id), 0) + 1;
                }
                const newCard = new Card(idToUse, source.ownerId, source.text + " (Eff)", targetZone);
                newCard.faceUp = true;
                newCard.rotation = 0;
                
                newCard.imageKey = source.imageKey; 
                newCard.backImageKey = source.backImageKey;
                newCard.image = source.image; 
                newCard.text = source.text;
                newCard.sourceId = source.id; 
                
                state.cards.push(newCard);
            }
        }
        else if (op.type === 'DELETE_CARD') {
            const { cardIds } = op;
            cardIds.forEach(id => {
               const c = state.cards.find(x => x.id === id);
               if (c && c.zone.includes('ability') && c.sourceId) {
                   const source = state.cards.find(s => s.id === c.sourceId);
                   if (source) source.glow = null;
               }
            });
            state.cards = state.cards.filter(c => !cardIds.includes(c.id));
        }
        else if (op.type === 'POINT') { }
        else if (op.type === 'ATTACK') {
            const { attackerId } = op;
            const card = state.cards.find(c => c.id === attackerId);
            if(card) {
                card.rotation = 90; 
            }
        }
        else if (op.type === 'ADD_NOTE') {
            const { cardIds, note } = op;
            state.cards.forEach(c => {
                if(cardIds.includes(c.id)) c.note = note;
            });
        }
        else if (op.type === 'ADJUST_STYLE') {
            const { cardIds, key, val, isDelta } = op;
            state.cards.forEach(c => {
                if(cardIds.includes(c.id)) {
                    if (isDelta) c[key] += val;
                    else c[key] = val;
                }
            });
        }
    }
	
	
function finishMove(toZone, insertIdx, stackTargetId = null, stackType = null) {
        if (!pendingMove) return;

        // --- START: ç§»å‹•å‰å…ˆåˆ‡æ–·èˆŠé€£çµ ---
        const state = getCurrentDisplayState();
        // æª¢æŸ¥è¢«ç§»å‹•çš„å¡ç‰‡ä¸­ï¼Œæ˜¯å¦æœ‰ä»»ä½•ä¸€å¼µå±¬æ–¼å †ç–Šçµæ§‹(æœ‰çˆ¶å¡ æˆ– æœ‰å­å¡)
        const needsBreak = pendingMove.cardIds.some(id => {
            const c = state.cards.find(x => x.id === id);
            if (!c) return false;
            // 1. æˆ‘æ˜¯å­å¡ (é€£è‘—åˆ¥äºº)
            if (c.parentId) return true;
            // 2. æˆ‘æ˜¯çˆ¶å¡ (åˆ¥äººé€£è‘—æˆ‘)
            const isParent = state.cards.some(child => child.parentId === c.id);
            if (isParent) return true;
            return false;
        });

        if (needsBreak) {
            // åœ¨ç”¢ç”Ÿ MOVE å‹•ä½œå‰ï¼Œå…ˆæ’å…¥ä¸€å€‹ BREAK_LINKS å‹•ä½œ
            addOperation({ type: 'BREAK_LINKS', cardIds: [...pendingMove.cardIds] });
        }
        // --- END: ç§»å‹•å‰å…ˆåˆ‡æ–·èˆŠé€£çµ ---
        
        let finalCardIds = [...pendingMove.cardIds];
        if (pendingMove.shuffle) {
            finalCardIds.sort(() => Math.random() - 0.5);
        }

        let faceUp = true;
        if (toZone.includes('shield') || toZone.includes('deck')) faceUp = false;
        if (toZone.includes('hand') && toZone.includes('p2')) faceUp = true;

        addOperation({
            type: 'MOVE',
            cardIds: finalCardIds, 
            toZone: toZone,
            faceUp: faceUp,
            shuffleSelection: false, 
            insertIndex: insertIdx,
            stackTargetId: stackTargetId,
            stackType: stackType
        });

        cancelSelection();
        closeSelectorModal();
        closePositionModal();
    }

    function actionShuffleZone() {
        const zoneId = document.getElementById('modal-title').getAttribute('data-zone-id');
        if(!zoneId) return;
        
        const state = getCurrentDisplayState();
        const cards = getCardsInZone(state, zoneId);
        const ids = cards.map(c => c.id);
        ids.sort(() => Math.random() - 0.5); 
        
        addOperation({ type: 'SHUFFLE', zoneId: zoneId, order: ids });
        closeSelectorModal();
    }

    function rotateCard(deg) {
        if (!pendingMove) return;
        addOperation({ type: 'ROTATE_CARD', cardIds: pendingMove.cardIds, deg: deg });
    }

    function flipCard() {
        if (!pendingMove) return;
        const state = getCurrentDisplayState();
        const card = state.cards.find(c => c.id === pendingMove.cardIds[0]);
        const targetFace = !card.faceUp;
        addOperation({ type: 'FLIP_CARD', cardIds: pendingMove.cardIds, finalFaceUp: targetFace });
    }

    function renameCard() {
        if (!pendingMove || pendingMove.cardIds.length === 0) return;
        
        const text = document.getElementById('rename-input').value;
        const state = getCurrentDisplayState();
        
        const targetKeys = new Set();
        pendingMove.cardIds.forEach(id => {
            const c = state.cards.find(x => x.id === id);
            if(c) {
                if(c.imageKey) targetKeys.add(c.imageKey);
                if(c.backImageKey) targetKeys.add(c.backImageKey);
            }
        });

        const applyRename = (cardList) => {
            cardList.forEach(c => {
                const isTarget = pendingMove.cardIds.includes(c.id) || 
                                 (c.imageKey && targetKeys.has(c.imageKey)) ||
                                 (c.backImageKey && targetKeys.has(c.backImageKey));
                if (isTarget) {
                    c.text = text;
                }
            });
        };

        applyRename(initialState.cards);
        history.forEach(h => { if(h.state) applyRename(h.state.cards); });
        if(tempState) applyRename(tempState.cards);
        
        renderUI();
        saveToStorage();
    }
    
    function addCardNote() {
        if (!pendingMove) return;
        const note = document.getElementById('note-input').value;
        addOperation({ type: 'ADD_NOTE', cardIds: pendingMove.cardIds, note: note });
    }
    
    function adjustAbilityCard(key, val) {
        if (!pendingMove || pendingMove.cardIds.length === 0) return;
        
        const state = getCurrentDisplayState();
        const targetIds = pendingMove.cardIds;
        
        const keysToUpdate = new Set();
        targetIds.forEach(id => {
            const c = state.cards.find(card => card.id === id);
            if (c) {
                if (c.imageKey) keysToUpdate.add(c.imageKey);
                else if (c.backImageKey) keysToUpdate.add(c.backImageKey);
            }
        });

        if (keysToUpdate.size === 0) return;

        keysToUpdate.forEach(imgKey => {
            let currentStyle = globalAbilityStyleRegistry[imgKey] || { x: 50, y: 50, scale: 1 };
            let newStyle = { ...currentStyle };

            if (key === 'panX') newStyle.x += val;
            else if (key === 'panY') newStyle.y += val;
            else if (key === 'scale') newStyle.scale += val;

            globalAbilityStyleRegistry[imgKey] = newStyle;
        });

        renderUI();
        saveToStorage();
    }
    
    function resetBoard(playerId) {
        if(!confirm(`ç¢ºå®šè¦é‡ç½® Player ${playerId} çš„æˆ°å ´èˆ‡é­”åŠ›å€æ–¹å‘å—ï¼Ÿ`)) return;
        addOperation({ type: 'RESET_BOARD', playerId: playerId });
    }

    function toggleGlow() {
        if (!pendingMove) return;
        const state = getCurrentDisplayState();
        
        // Strict Check: Only Ability Zone cards can trigger Glow
        const invalid = pendingMove.cardIds.some(id => {
            const c = state.cards.find(x => x.id === id);
            return !c || !c.zone.includes('ability');
        });

        if (invalid) {
            alert("åªæœ‰ã€Œå¾…è™•ç†å€ã€çš„å¡ç‰‡å¯ä»¥ä¸‹é”ç™¼å…‰æŒ‡ä»¤ã€‚\n(è‹¥æœ‰è¨­å®šä¾†æºå¡ï¼Œä¾†æºå¡æœƒè‡ªå‹•åŒæ­¥ç™¼å…‰)");
            return;
        }

        const colors = ['red', 'yellow', 'green', 'blue', 'black', 'white', 'rainbow', null];
        const firstId = pendingMove.cardIds[0];
        const card = state.cards.find(c => c.id === firstId);
        let currentGlow = card ? card.glow : null;
        let idx = colors.indexOf(currentGlow);
        if (idx === -1) idx = 7; 
        let nextColor = colors[(idx + 1) % colors.length];
        
        addOperation({ type: 'SET_GLOW', cardIds: pendingMove.cardIds, color: nextColor });
    }

    function removeGlow() {
        if (!pendingMove) return;
        // Same strict check for removing glow manually via UI
        const state = getCurrentDisplayState();
        const invalid = pendingMove.cardIds.some(id => {
            const c = state.cards.find(x => x.id === id);
            return !c || !c.zone.includes('ability');
        });
        
        if (invalid) {
             alert("åªæœ‰ã€Œå¾…è™•ç†å€ã€çš„å¡ç‰‡å¯ä»¥æ“ä½œç™¼å…‰ç‹€æ…‹ã€‚");
             return;
        }

        addOperation({ type: 'SET_GLOW', cardIds: pendingMove.cardIds, color: null });
    }
    
    function revealCards() {
        if(!pendingMove) return;
        finishMove('reveal-zone', undefined);
    }
    
    function revealFromSelector() {
        if(selectedCardsInModal.length === 0) return;
        pendingMove = { cardIds: [...selectedCardsInModal], shuffle: false };
        closeSelectorModal();
        finishMove('reveal-zone', undefined);
    }
    
    function closeRevealZone() {
        if(confirm("å°‡å±•ç¤ºå€å¡ç‰‡å…¨éƒ¨é€å…¥å¢“åœ°ä¸¦é—œé–‰ï¼Ÿ")) {
             const state = getCurrentDisplayState();
             const cards = state.cards.filter(c => c.zone === 'reveal-zone');
             const p1Cards = cards.filter(c => c.ownerId === 1).map(c=>c.id);
             const p2Cards = cards.filter(c => c.ownerId === 2).map(c=>c.id);
             
             if (!isDrafting) startDraftAtEnd();
             
             if(p1Cards.length > 0) {
                 addOperation({
                    type: 'MOVE',
                    cardIds: p1Cards,
                    toZone: 'p1-grave',
                    faceUp: true,
                    shuffleSelection: false
                 });
             }
             if(p2Cards.length > 0) {
                 addOperation({
                    type: 'MOVE',
                    cardIds: p2Cards,
                    toZone: 'p2-grave',
                    faceUp: true,
                    shuffleSelection: false
                 });
             }
             saveDraft("çµæŸå±•ç¤º (End Reveal)");
        }
    }

    function endPoint() {
        if (isDrafting) {
            alert("è«‹å…ˆå„²å­˜ç•¶å‰æ­¥é©Ÿï¼Œå†çµæŸæŒ‡å‘");
            return;
        }
        startDraftAtEnd();
        addOperation({ type: 'PASS' });
        saveDraft("çµæŸæŒ‡å‘ (End Pointing)");
    }
	
	// --- [æ–°å¢] è§¸ç™¼å‹åˆ© ---
    function triggerWin(winnerId) {
        if (!isDrafting) startDraftAtEnd();
        
        addOperation({ 
            type: 'GAME_WIN', 
            winnerId: winnerId 
        });
        
        saveDraft(`Player ${winnerId} ç²å‹!!`);
    }
	
	// --- [æ–°å¢] åˆ‡æ›å—å‚·ç‹€æ…‹ ---
    function toggleInjured() {
        if (!pendingMove) return;
        
        // æª¢æŸ¥æ˜¯å¦ç¬¦åˆå€åŸŸé™åˆ¶ (åƒ…æˆ°é¬¥å€èˆ‡è­·ç›¾å€)
        const state = getCurrentDisplayState();
        const validZones = ['p1-battle', 'p2-battle', 'p1-shield', 'p2-shield'];
        const isValid = pendingMove.cardIds.every(id => {
            const c = state.cards.find(x => x.id === id);
            return c && validZones.includes(c.zone);
        });

        if (!isValid) {
            alert("åªæœ‰ã€Œæˆ°é¬¥å€ã€èˆ‡ã€Œè­·ç›¾å€ã€çš„å¡ç‰‡å¯ä»¥æ¨™è¨˜ç‚ºå—å‚·ã€‚");
            return;
        }

        // åˆ¤æ–·æ˜¯è¦å…¨éƒ¨åŠ å—å‚·ï¼Œé‚„æ˜¯å…¨éƒ¨å–æ¶ˆ (è‹¥å…¶ä¸­ä¸€å¼µå·²å—å‚·ï¼Œå‰‡è¦–ç‚ºè¦å–æ¶ˆ)
        const hasInjured = pendingMove.cardIds.some(id => {
            const c = state.cards.find(x => x.id === id);
            return c.isInjured;
        });

        addOperation({ 
            type: 'INJURED', 
            cardIds: pendingMove.cardIds, 
            setInjured: !hasInjured // å¦‚æœæœ‰äººå—å‚·å°±å…¨éƒ¨å–æ¶ˆï¼Œå¦å‰‡å…¨éƒ¨è¨­ç‚ºå—å‚·
        });
    }

    function copyToAbility() {
        if (!pendingMove) return;
        if (pendingMove.cardIds.length !== 1) return alert("è«‹ä¸€æ¬¡é¸æ“‡ä¸€å¼µç‰Œé€²è¡Œè¤‡è£½");
        
        const state = getCurrentDisplayState();
        const card = state.cards.find(c => c.id === pendingMove.cardIds[0]);
        if (!card) return;
        
        const targetZone = card.ownerId === 1 ? 'p1-ability' : 'p2-ability';
        const newId = state.cards.reduce((max, c) => Math.max(max, c.id), 0) + 1; 
        
        addOperation({ type: 'CREATE_ABILITY', sourceCardId: card.id, targetZone: targetZone, newId: newId });
    }

    function deleteSelectedCard() {
        if (!pendingMove) return;
        if(!confirm("ç¢ºå®šè¦åˆªé™¤é¸å–çš„å¡ç‰‡å—ï¼Ÿ(åƒ…å»ºè­°ç”¨æ–¼èƒ½åŠ›è™•ç†å€)")) return;
        
        addOperation({ type: 'DELETE_CARD', cardIds: pendingMove.cardIds });
        cancelSelection();
    }

    // --- Point Mode Logic ---
    function enterPointMode() {
        if (!pendingMove || pendingMove.cardIds.length !== 1) return alert("è«‹é¸æ“‡ä¸€å¼µå¡ç‰‡é€²è¡ŒæŒ‡å‘");
        pointerId = pendingMove.cardIds[0];
        isPointing = true;
        pointTargets = [];
        
        document.getElementById('card-action-panel').style.display = 'none';
        document.getElementById('point-bar').style.display = 'flex';
        updatePointInfo();
        document.querySelectorAll('.zone').forEach(el => el.classList.add('point-target-highlight'));
        renderUI(); 
    }

    function cancelPointMode() {
        isPointing = false;
        pointerId = null;
        pointTargets = [];
        document.getElementById('point-bar').style.display = 'none';
        document.querySelectorAll('.point-target-highlight').forEach(el => el.classList.remove('point-target-highlight'));
        document.querySelectorAll('.point-target-selected').forEach(el => el.classList.remove('point-target-selected'));
        cancelSelection(); 
    }

	function handlePointClick(zoneId, cardId) {
        if (!isPointing) return;
        
        // [ä¿®æ”¹] å…è¨±æŒ‡å‘ ç‰Œåº«(Deck)ã€è¶…æ¬¡å…ƒ(Hyper)ã€å¢“åœ°(Grave) ä¸‰ç¨®å€åŸŸ
        if (!cardId && (zoneId.includes('deck') || zoneId.includes('hyper') || zoneId.includes('grave'))) {
             let zoneName = "å€åŸŸ";
             if(zoneId.includes('deck')) zoneName = "ç©å®¶/ç‰Œåº«";
             if(zoneId.includes('hyper')) zoneName = "è¶…æ¬¡å…ƒå€";
             if(zoneId.includes('grave')) zoneName = "å¢“åœ°å€";

             if (confirm(`ç¢ºèªæŒ‡å‘ ${zoneName}?`)) {
                 finishPoint('ZONE', null); // é€™è£¡ä½¿ç”¨ 'ZONE' é¡å‹ï¼Œæœƒå‚³å…¥ null idsï¼Œéœ€åœ¨ finishPoint è™•ç†æˆ–ç›´æ¥ç”¨ DOM
             }
             return;
        }
        
        if (cardId) {
            if (pointTargets.includes(cardId)) {
                pointTargets = pointTargets.filter(id => id !== cardId);
            } else {
                pointTargets.push(cardId);
            }
            updatePointInfo();
            renderUI(); 
        }
    }

    function updatePointInfo() {
        const btn = document.getElementById('btn-confirm-point');
        const info = document.getElementById('point-target-info');
        if (pointTargets.length > 0) {
            info.innerText = `å·²é¸æ“‡ ${pointTargets.length} å€‹ç›®æ¨™`;
            btn.style.display = 'block';
        } else {
            info.innerText = "è«‹é»æ“Šç›®æ¨™...";
            btn.style.display = 'none';
        }
    }

    function confirmPointTargets() {
        if (pointTargets.length === 0) return;
        finishPoint('CARD', pointTargets);
    }

    function finishPoint(type, targetIds) {
        const state = getCurrentDisplayState();
        const pointer = state.cards.find(c => c.id === pointerId);
        let desc = `[æŒ‡å‘] ${pointer.text} æŒ‡å‘ `;
        if (type === 'PLAYER') desc += 'ç©å®¶/ç‰Œåº«';
        else if (type === 'CARD') desc += `${targetIds.length} å€‹ç›®æ¨™`;

        addOperation({
            type: 'POINT',
            attackerId: pointerId,
            targetType: type,
            targetIds: targetIds,
            desc: desc
        });
        cancelPointMode();
    }

    function handleZoneClick(zoneId) {
        if (isPointing) {
            handlePointClick(zoneId, null); 
            return;
        }

        if (pendingMove) {
            const state = getCurrentDisplayState();
            // FILTER: Prevent moving Ability cards
            const hasAbilityCard = pendingMove.cardIds.some(id => {
                const c = state.cards.find(card => card.id === id);
                return c && c.zone.includes('ability');
            });
            if(hasAbilityCard) {
                alert("èƒ½åŠ›å¾…è™•ç†å€çš„å¡ç‰‡ä¸èƒ½ç§»å‹•");
                return;
            }

            if (isStackZone(zoneId)) {
                openPositionSelector(zoneId, pendingMove);
            } else {
                finishMove(zoneId, undefined);
            }
            return;
        }
        openSelectorModal(zoneId);
    }
    
    document.addEventListener('click', (e) => {
        if (e.target.closest('.card') || e.target.closest('.zone') || e.target.closest('button') || e.target.closest('input') || e.target.closest('.modal')) return;
        if (!isPointing) cancelSelection();
    });

    function cancelSelection() {
        if (pendingMove) {
            pendingMove = null;
            document.querySelectorAll('.zone').forEach(el => el.classList.remove('target-highlight'));
            document.querySelectorAll('.card.selected').forEach(el => el.classList.remove('selected'));
            document.getElementById('card-action-panel').style.display = 'none';
        }
    }

    function isStackZone(zid) {
        return zid.includes('deck') || zid.includes('shield') || zid.includes('hyper');
    }

	function handleCardSingleClick(e, cardId) {
        e.stopPropagation(); 
        
        if (isPointing) {
            handlePointClick(null, cardId);
            return;
        }

        if (pendingMove) {
            // å¦‚æœé»æ“Šå·²é¸å–çš„å¡ç‰‡ -> å–æ¶ˆé¸å–è©²å¼µ
            if (pendingMove.cardIds.includes(cardId)) {
                 pendingMove.cardIds = pendingMove.cardIds.filter(id => id !== cardId);
                 if (pendingMove.cardIds.length === 0) {
                     cancelSelection();
                     return;
                 }
                 updateSelectionUI();
                 return;
            }
            
            const state = getCurrentDisplayState();
            const targetCard = state.cards.find(c => c.id === cardId);
            
            // å¦‚æœé»æ“Šåˆ¥å¼µå¡ -> è¦–ç‚ºè¦åœ¨ç›®æ¨™å¡ä¸Šé€²è¡Œå †ç–Š (é™¤äº†ç‰¹å®šå€åŸŸå¤–)
            if (targetCard && !targetCard.zone.includes('deck') && !targetCard.zone.includes('grave') && !targetCard.zone.includes('ability')) {
                openStackingModal(targetCard);
                return;
            }
        }
        
        // å–®ç´”é¸å–ï¼Œä¸åŸ·è¡Œä»»ä½•å‹•ä½œ
        if (!pendingMove) {
            pendingMove = { cardIds: [cardId], shuffle: false };
        } else {
            pendingMove.cardIds.push(cardId);
        }
        updateSelectionUI();
    }

    function openStackingModal(targetCard) {
        const modal = document.getElementById('position-selector-modal');
        const list = document.getElementById('position-list');
        list.innerHTML = '';
        
        document.getElementById('pos-modal-title').innerText = `å †ç–Šæ“ä½œ: ç›®æ¨™ [${targetCard.text}]`;
        document.getElementById('position-list').style.display = 'none';
        document.getElementById('stack-gui').style.display = 'grid';
        
        window.confirmStackMove = (type) => {
            finishMove(targetCard.zone, undefined, targetCard.id, type);
        };
        modal.style.display = 'flex';
    }

    function updateSelectionUI() {
        document.querySelectorAll('.card.selected').forEach(el => el.classList.remove('selected'));
        
        if (pendingMove && pendingMove.cardIds.length > 0) {
            const state = getCurrentDisplayState();
            
            let allAbility = true;
            let allRevealed = true;
            
			// --- [æ–°å¢] æª¢æŸ¥æ˜¯å¦ç‚ºæˆ°é¬¥æˆ–è­·ç›¾å€ ---
            let isBattleOrShield = true;
            pendingMove.cardIds.forEach(id => {
                const c = state.cards.find(card => card.id === id);
                if (!c) return;
                const z = c.zone;
                if (!z.includes('battle') && !z.includes('shield')) {
                    isBattleOrShield = false;
                }
            });
            document.getElementById('btn-injured').style.display = isBattleOrShield ? 'block' : 'none';
            // ------------------------------------
            
            // UI Filtering Logic (Req 6)
            document.getElementById('btn-delete-card').style.display = (allAbility || allRevealed) ? 'block' : 'none';
            document.getElementById('btn-point').style.display = 'block';
            document.getElementById('btn-end-point').style.display = 'block'; 

            const firstCard = state.cards.find(c => c.id === pendingMove.cardIds[0]);
            
            // Only show Glow buttons for Ability cards
            document.getElementById('btn-glow').style.display = allAbility ? 'block' : 'none';
            document.getElementById('btn-unglow').style.display = (allAbility && firstCard && firstCard.glow) ? 'block' : 'none';
            
            document.getElementById('btn-remove-image').style.display = (firstCard && firstCard.image) ? 'block' : 'none';
            
            document.getElementById('ability-adjust-controls').style.display = allAbility ? 'block' : 'none';
            document.getElementById('ability-adjust-buttons').style.display = allAbility ? 'flex' : 'none';

            // Hide standard move buttons if Ability card (can't move them)
            // Note: The UI panel buttons are mostly actions, move happens by clicking zones.
            // We handled zone click prevention in handleZoneClick.

            const panel = document.getElementById('card-action-panel');
            panel.style.display = 'flex';
            
            if (pendingMove.cardIds.length === 1 && firstCard) {
                document.getElementById('rename-input').value = firstCard.text;
                document.getElementById('note-input').value = firstCard.note || "";
            } else {
                document.getElementById('rename-input').value = '';
                document.getElementById('note-input').value = '';
            }
            
            document.querySelectorAll('.zone').forEach(el => el.classList.add('target-highlight'));
        } else {
            document.getElementById('card-action-panel').style.display = 'none';
        }
        
        renderUI(); 
    }

    function getCardPositions() {
        const positions = {};
        document.querySelectorAll('.card').forEach(el => {
            if(el.dataset.id) {
                const rect = el.getBoundingClientRect();
                positions[el.dataset.id] = { top: rect.top, left: rect.left, width: rect.width, height: rect.height };
            }
        });
        document.querySelectorAll('.zone').forEach(el => {
            if(el.dataset.zone) {
                const rect = el.getBoundingClientRect();
                positions['ZONE_' + el.dataset.zone] = { top: rect.top, left: rect.left, width: rect.width, height: rect.height };
            }
        });
        return positions;
    }

    function getCardsInZone(state, zoneName) {
        return state.cards.filter(c => c.zone === zoneName);
    }

    function getZoneName(zoneId) {
        return zoneId.toUpperCase(); 
    }

function renderUI() {
        const firstPositions = getCardPositions();
        const state = getCurrentDisplayState();
        
        let winOverlay = document.getElementById('win-overlay');
        if (!winOverlay) {
            winOverlay = document.createElement('div');
            winOverlay.id = 'win-overlay';
            document.body.appendChild(winOverlay);
        }

        const board = document.getElementById('game-board-container');
        const abilityZone = document.getElementById('ability-stack-zone');
        
        const p1Area = document.getElementById('player1-area');
        const p2Area = document.getElementById('player2-area');
        
        if (p1Area && p2Area) {
            p1Area.classList.remove('active-turn');
            p2Area.classList.remove('active-turn');
            if (state.turnPlayer === 1) p1Area.classList.add('active-turn');
            else p2Area.classList.add('active-turn');
        }
        
        if (state.globalRotation) {
            board.classList.add('rotated-view');
            abilityZone.classList.add('rotated-view');
        } else {
            board.classList.remove('rotated-view');
            abilityZone.classList.remove('rotated-view');
        }

        document.querySelectorAll('.zone, .ability-column').forEach(el => {
            const label = el.querySelector('.zone-label, .ability-label');
            el.innerHTML = '';
            if(label) el.appendChild(label);
            el.classList.remove('target-highlight');
            el.classList.remove('point-target-highlight'); 
            el.className = el.className.replace(/\bglow-\S+/g, '');
        });
        
        const revealZoneEl = document.getElementById('reveal-zone');
        const revealCards = state.cards.filter(c => c.zone === 'reveal-zone');
        if (revealCards.length > 0) {
            revealZoneEl.style.display = 'flex';
            revealZoneEl.innerHTML = `
                <span class="zone-label">å±•ç¤ºå€ (Reveal Zone)</span>
                <button class="mini-btn danger" style="position:absolute; top:5px; right:5px;" onclick="closeRevealZone()">âœ•</button>
            `;
            revealCards.forEach(c => revealZoneEl.appendChild(createCardElement(c)));
        } else {
            revealZoneEl.style.display = 'none';
            revealZoneEl.innerHTML = '';
        }

        if (pendingMove) document.querySelectorAll('.zone').forEach(el => el.classList.add('target-highlight'));
        if (isPointing) document.querySelectorAll('.zone').forEach(el => el.classList.add('point-target-highlight'));

        const zoneMap = {};
        const childMap = {}; 
        const rootCards = []; 

        state.cards.forEach(card => {
            if (card.zone === 'reveal-zone') return;
            if(!zoneMap[card.zone]) zoneMap[card.zone] = [];
            zoneMap[card.zone].push(card);
            if (card.parentId) {
                if (!childMap[card.parentId]) childMap[card.parentId] = [];
                childMap[card.parentId].push(card);
            } else {
                rootCards.push(card);
            }
        });

        ['p1-deck', 'p1-grave', 'p1-hyper', 'p2-deck', 'p2-grave', 'p2-hyper'].forEach(zid => {
            const cards = zoneMap[zid] || [];
            const glowingCard = cards.find(c => c.glow);
            if (glowingCard) {
                const zoneEl = document.querySelector(`.zone[data-zone="${zid}"]`);
                if (zoneEl) zoneEl.classList.add(`glow-${glowingCard.glow}`);
            }
        });

        const stackedZones = ['p1-deck', 'p1-grave', 'p1-hyper', 'p2-deck', 'p2-grave', 'p2-hyper', 'p1-shield', 'p2-shield'];

		const renderCardTree = (card, container) => {
            const isSpreadZone = !stackedZones.includes(card.zone) || card.zone.includes('shield');
            if (isSpreadZone) {
                let bounds = { minX: 0, maxX: 0, minY: 0, maxY: 0 };
                const measureTree = (c, x, y) => {
                    if (x < bounds.minX) bounds.minX = x;
                    if (x > bounds.maxX) bounds.maxX = x;
                    if (y < bounds.minY) bounds.minY = y;
                    if (y > bounds.maxY) bounds.maxY = y;
                    const children = childMap[c.id] || [];
                    children.forEach(child => {
                        let dx = 0, dy = 0;
                        if (child.stackType === 'puzzle_left') dx = -50;
                        else if (child.stackType === 'puzzle_right') dx = 50;
                        else if (child.stackType === 'puzzle_top') dy = -70;
                        else if (child.stackType === 'puzzle_bottom') dy = 70;
                        else if (child.stackType === 'shift_up') dy = -25;
                        else if (child.stackType === 'shift_down') dy = 25;
                        else if (child.stackType === 'bottom_exposed') dy = 20;
                        measureTree(child, x + dx, y + dy);
                    });
                };
                measureTree(card, 0, 0);
                const groupDiv = document.createElement('div');
                groupDiv.className = 'card-group';
                const totalW = (bounds.maxX - bounds.minX) + 50; 
                const totalH = (bounds.maxY - bounds.minY) + 70; 
                groupDiv.style.width = `${totalW}px`;
                groupDiv.style.height = `${totalH}px`;
                groupDiv.style.position = 'relative'; 
                groupDiv.style.margin = '5px'; 
                container.appendChild(groupDiv);
                
                const baseOffsetX = -bounds.minX;
                const baseOffsetY = -bounds.minY;

                const renderNode = (currentCard, offsetX, offsetY, zVal, depth) => {
                    const cardEl = createCardElement(currentCard);
                    let newOffsetX = offsetX;
                    let newOffsetY = offsetY;
                    let newZ = zVal;
                    let className = '';
                    if (depth === 0) {
                        className = 'stack-base';
                        newZ = 10;
                    } else {
                        if (currentCard.stackType === 'top') { className = 'stack-top'; newZ += 1; }
                        else if (currentCard.stackType === 'bottom') { className = 'stack-bottom'; newZ -= 1; }
                        else if (currentCard.stackType === 'shift_up') { className = 'stack-shift-up'; newOffsetY -= 25; newZ += 1; }
                        else if (currentCard.stackType === 'shift_down') { className = 'stack-shift-down'; newOffsetY += 25; newZ += 1; }
                        else if (currentCard.stackType === 'bottom_exposed') { className = 'stack-bottom-exposed'; newOffsetY += 20; newZ -= 1; }
                        else if (currentCard.stackType === 'puzzle_top') { className = 'stack-puzzle-top'; newOffsetY -= 70; }
                        else if (currentCard.stackType === 'puzzle_bottom') { className = 'stack-puzzle-bottom'; newOffsetY += 70; }
                        else if (currentCard.stackType === 'puzzle_left') { className = 'stack-puzzle-left'; newOffsetX -= 50; }
                        else if (currentCard.stackType === 'puzzle_right') { className = 'stack-puzzle-right'; newOffsetX += 50; }
                    }
                    if (className) cardEl.classList.add(className);
                    cardEl.style.position = 'absolute';
                    cardEl.style.left = `${newOffsetX}px`;
                    cardEl.style.top = `${newOffsetY}px`;
                    cardEl.style.zIndex = newZ;
                    if (currentCard.stackType && currentCard.stackType.includes('puzzle')) {
                         cardEl.style.transform = `rotate(${currentCard.rotation}deg)`;
                    }
                    groupDiv.appendChild(cardEl);
                    const children = childMap[currentCard.id] || [];
                    children.forEach(child => renderNode(child, newOffsetX, newOffsetY, newZ, depth + 1));
                };
                renderNode(card, baseOffsetX, baseOffsetY, 10, 0);
            }
        };

        Object.keys(zoneMap).forEach(zoneId => {
            const cardsInZone = zoneMap[zoneId];
            if (zoneId.includes('ability')) {
                const zoneEl = document.getElementById(zoneId === 'p1-ability' ? 'ability-zone-p1' : 'ability-zone-p2');
                cardsInZone.forEach(card => zoneEl.appendChild(createCardElement(card)));
                return;
            }
            const zoneEl = document.querySelector(`.zone[data-zone="${zoneId}"]`);
            if (!zoneEl) return;
            if (stackedZones.includes(zoneId) && !zoneId.includes('shield')) {
                if (cardsInZone.length > 0) {
                    const topCard = cardsInZone[cardsInZone.length - 1];
                    zoneEl.appendChild(createCardElement(topCard));
                }
                const badge = document.createElement('div');
                badge.className = 'count-badge';
                badge.innerText = cardsInZone.length;
                zoneEl.appendChild(badge);
            } else {
                const roots = rootCards.filter(c => c.zone === zoneId);
                roots.forEach(root => renderCardTree(root, zoneEl));
            }
        });

        renderTimeline();
        renderArrows(); 

        requestAnimationFrame(() => {
            const lastPositions = getCardPositions();
            Object.keys(lastPositions).forEach(id => {
                if (id.startsWith('ZONE_')) return;
                const cardEl = document.querySelector(`.card[data-id="${id}"]`);
                if (!cardEl) return;
                let start = firstPositions[id];
                if (!start && lastRenderedState) {
                    const prevCard = lastRenderedState.cards.find(c => c.id == id);
                    if (prevCard) start = firstPositions['ZONE_' + prevCard.zone];
                }
                if (start) {
                    const last = lastPositions[id];
                    const deltaX = start.left - last.left;
                    const deltaY = start.top - last.top;
                    if (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1) {
                        const cardData = state.cards.find(c => c.id == id);
                        const rotation = cardData ? cardData.rotation : 0;
                        const isAbility = cardData && cardData.zone.includes('ability');
                        if (cardData && cardData.stackType && cardData.stackType.includes('puzzle')) {
                             // skip
                        } else {
                            cardEl.style.transition = 'none';
                            cardEl.style.transform = `translate(${deltaX}px, ${deltaY}px) rotate(${isAbility?0:rotation}deg)`;
                            requestAnimationFrame(() => {
                                cardEl.style.transition = 'transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1)';
                                cardEl.style.transform = `translate(0, 0) rotate(${isAbility?0:rotation}deg)`;
                            });
                        }
                    }
                }
            });
            lastRenderedState = cloneState(state);

            if (currentIndex >= 0 && history[currentIndex]) {
                if (currentIndex !== lastAnimatedStep) {
                    const lastAction = history[currentIndex].action;
                    const winOverlay = document.getElementById('win-overlay');

                    // --- [ä¿®æ­£ 1] ç²¾æº–æ¸…é™¤å‹åˆ©å‹•ç•«ï¼Œä¸å½±éŸ¿æ’­æ”¾å™¨ ---
                    if (winOverlay) {
                        winOverlay.style.display = 'none';
                        if (winOverlayTimeout) {
                            clearTimeout(winOverlayTimeout);
                            winOverlayTimeout = null;
                        }
                    }
                    // ------------------------------------------

                    const createOp = lastAction.operations.find(op => op.type === 'CREATE_ABILITY');
                    if (createOp) {
                        setTimeout(() => {
                            animateAbilityFly(createOp.sourceCardId, createOp.newId);
                        }, 50);
                    }
                    
                    const winOp = lastAction.operations.find(op => op.type === 'GAME_WIN');
                    if (winOp && winOverlay) {
                        const winnerId = winOp.winnerId;
                        winOverlay.style.display = 'flex';
                        
                        const colors = ['#f00', '#0f0', '#00f', '#ff0', '#f0f', '#0ff'];
                        let confettiHtml = '';
                        for(let i=0; i<30; i++) {
                            const left = Math.random() * 100;
                            const delay = Math.random() * 1;
                            const bg = colors[Math.floor(Math.random()*colors.length)];
                            confettiHtml += `<div class="confetti" style="left:${left}%; animation-delay:${delay}s; background:${bg};"></div>`;
                        }

                        winOverlay.innerHTML = `
                            ${confettiHtml}
                            <div class="win-text">PLAYER ${winnerId} WIN!!</div>
                            <div class="win-sub">Congratulations</div>
                        `;
                        
                        // --- [ä¿®æ­£ 2] è¨˜éŒ„ Timer ID ---
                        winOverlayTimeout = setTimeout(() => {
                            winOverlay.style.display = 'none';
                            winOverlayTimeout = null;
                        }, 3000);
                        // ----------------------------
                    }

                    lastAnimatedStep = currentIndex;
                }
            }
        });
    }

    function createCardElement(card) {
        const el = document.createElement('div');
        el.className = `card ${card.faceUp ? '' : 'face-down'}`; 
        el.dataset.id = card.id; 
        
		// --- [æ–°å¢] æ¸²æŸ“å—å‚·çˆªç—• ---
        if (card.isInjured) {
            const clawDiv = document.createElement('div');
            // å¦‚æœæ˜¯ç·¨è¼¯ä¸­(isDrafting) -> é¡¯ç¤ºéœæ…‹ (ä¸åŠ  anim class)
            // å¦‚æœæ˜¯æ’­æ”¾ä¸­ -> åŠ å…¥ claw-anim class è§¸ç™¼å‹•ç•«
            // æ³¨æ„ï¼šé€™è£¡æˆ‘å€‘ç°¡å–®åˆ¤æ–·ï¼Œåªè¦ä¸æ˜¯ç·¨è¼¯æ¨¡å¼ï¼Œå°±è¦–ç‚ºæ’­æ”¾æ¨¡å¼ï¼Œè®“å®ƒå‹•èµ·ä¾†
            // è‹¥å¸Œæœ›æ¯æ¬¡æ›æ­¥æ‰å‹•ï¼Œå¯æ­é… lastAnimatedStep åˆ¤æ–·ï¼Œä½†å…¨åŸŸåŒæ­¥æ’­æ”¾æ¯”è¼ƒç°¡å–®æš´åŠ›ä¸”çˆ½å¿«
            
            const animClass = isDrafting ? '' : 'claw-anim';
            
            clawDiv.className = `claw-overlay ${animClass}`;
            clawDiv.innerHTML = `
                <svg class="claw-svg" viewBox="0 0 100 100">
                    <path class="claw-path p1" d="M20,20 Q50,50 80,80" />
                    <path class="claw-path p2" d="M30,10 Q60,40 90,70" />
                    <path class="claw-path p3" d="M10,30 Q40,60 70,90" />
                </svg>
            `;
            el.appendChild(clawDiv);
        }
		
        // Visual Glow (only applied if property exists, logic handles source sync)
        if (card.glow) el.classList.add(`glow-${card.glow}`);
        
        if (card.image && (card.faceUp || card.isHyper)) {
            const imageSrc = globalImageRegistry[card.imageKey];
            if (imageSrc) {
                el.style.backgroundImage = `url(${imageSrc})`;
                el.classList.add('has-image');
                
                if (card.zone.includes('ability')) {
                    const style = globalAbilityStyleRegistry ? (globalAbilityStyleRegistry[card.imageKey] || { x: 50, y: 50, scale: 1 }) : { x: 50, y: 50, scale: 1 };
                    el.style.backgroundPosition = `${style.x}% ${style.y}%`;
                    el.style.backgroundSize = `${100 * style.scale}%`;
                } else {
                     el.style.backgroundSize = 'cover';
                     el.style.backgroundPosition = 'center';
                     el.style.backgroundRepeat = 'no-repeat';
                }
            }
        }

        if (card.zone.includes('ability')) {
            el.classList.add('ability-card');
            if (!card.faceUp) el.className = `card ability-card`; 
        } else {
            // Apply rotation, unless it's a puzzle piece (handled in renderNode)
            if (!card.stackType || !card.stackType.includes('puzzle')) {
                el.style.transform = `rotate(${card.rotation}deg)`;
            }
        }
        
        if (pendingMove && pendingMove.cardIds.includes(card.id)) {
            el.classList.add('selected');
            if (!card.zone.includes('ability') && el.classList.contains('selected')) {
               // Only offset if not puzzle
               if (!card.stackType || !card.stackType.includes('puzzle')) {
                   el.style.transform = `rotate(${card.rotation}deg) translateY(-5px)`;
               }
            }
        }
        
        if (isPointing && pointTargets.includes(card.id)) {
            el.classList.add('point-target-selected');
        }
        
        if (card.note) {
            const noteEl = document.createElement('div');
            noteEl.className = 'card-note';
            noteEl.innerText = card.note;
            noteEl.title = card.note; 
            el.appendChild(noteEl);
        }

        if (card.faceUp || card.zone.includes('ability')) {
            const contentDiv = document.createElement('div');
            contentDiv.style.marginTop = card.note ? '10px' : '0';
            contentDiv.innerHTML = `<div class="card-text">${card.text}</div>`;
            if (card.power > 0) contentDiv.innerHTML += `<div class="card-power">${card.power}</div>`;
            el.appendChild(contentDiv);
        }
        
        const isViewerZone = card.zone.includes('deck') || card.zone.includes('grave') || card.zone.includes('hyper');
        
        if (!isViewerZone) {
             el.onclick = (e) => handleCardSingleClick(e, card.id);
        } else {
             el.onclick = (e) => {
                 e.stopPropagation(); 
                 handleZoneClick(card.zone);
             };
        }
        
        setTimeout(() => el.classList.add('interactive'), 0);
        return el;
    }

    function renderArrows() {
        const svg = document.getElementById('svg-layer');
        svg.innerHTML = `
            <defs>
                <marker id="arrowhead" markerWidth="12" markerHeight="12" refX="10" refY="6" orient="auto" markerUnits="userSpaceOnUse">
                    <path d="M0,0 L12,6 L0,12" fill="#e74c3c" />
                </marker>
            </defs>
        `;
        
        let ops = [];
        if (isDrafting) {
            ops = draftOperations;
        } else if (currentIndex >= 0 && history[currentIndex]) {
            ops = history[currentIndex].action.operations;
        }

        if (ops) {
            const pointOps = ops.filter(o => o.type === 'POINT' || o.type === 'ATTACK'); 
            
            pointOps.forEach(op => {
                const attacker = document.querySelector(`.card[data-id="${op.attackerId}"]`);
                if (!attacker) return;
                
                let targetEls = [];
                if (op.targetType === 'CARD' || op.targetType === 'CREATURE' || op.targetType === 'SHIELD') {
                    if (Array.isArray(op.targetIds)) {
                        op.targetIds.forEach(tid => {
                            const el = document.querySelector(`.card[data-id="${tid}"]`);
                            if(el) targetEls.push(el);
                        });
                    }
                } else if (op.targetType === 'PLAYER') {
                    const attackerOwner = attacker.closest('.player-area').id.includes('player1') ? 1 : 2;
                    const oppId = attackerOwner === 1 ? 2 : 1;
                    const deck = document.querySelector(`.deck-zone[data-zone="p${oppId}-deck"]`);
                    if(deck) targetEls.push(deck);
                }
                
                const startRect = attacker.getBoundingClientRect();
                const x1 = startRect.left + startRect.width / 2;
                const y1 = startRect.top + startRect.height / 2;
                
                targetEls.forEach(target => {
                    const endRect = target.getBoundingClientRect();
                    const x2 = endRect.left + endRect.width / 2;
                    const y2 = endRect.top + endRect.height / 2;
                    
                    const isSelf = (target === attacker);
                    
                    if (isSelf) {
                        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                        const r = 40; 
                        const d = `M ${x1},${y1} C ${x1+r*2},${y1-r*2} ${x1-r*2},${y1-r*2} ${x1},${y1}`;
                        path.setAttribute("d", d);
                        path.setAttribute("class", "arrow-line");
                        path.setAttribute("fill", "none");
                        svg.appendChild(path);
                    } else {
                        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                        line.setAttribute("x1", x1);
                        line.setAttribute("y1", y1);
                        line.setAttribute("x2", x2);
                        line.setAttribute("y2", y2);
                        line.setAttribute("class", "arrow-line");
                        svg.appendChild(line);
                    }
                });
            });
        }
    }

    function renderTimeline() {
        const list = document.getElementById('action-list');
        list.innerHTML = '';
        
        history.forEach((item, index) => {
            const gap = document.createElement('div');
            gap.className = 'timeline-gap';
            gap.title = "æ’å…¥æ–°æ­¥é©Ÿ";
            gap.onclick = () => startDraft(index);
            list.appendChild(gap);

            const li = document.createElement('li');
            
            let colorClass = '';
            if (item.action.operations && item.action.operations.length > 0) {
                const op = item.action.operations.find(o => o.cardIds && o.cardIds.length > 0);
                if (op) {
                    const cardId = op.cardIds[0];
                    const card = item.state.cards.find(c => c.id === cardId);
                    if (card) {
                        if (card.ownerId === 1) colorClass = 'p1-action';
                        else if (card.ownerId === 2) colorClass = 'p2-action';
                    }
                }
            }

            li.className = `action-item ${index === currentIndex ? 'active' : ''} ${colorClass}`;
            
            const delBtn = `<button class="icon-btn delete" onclick="event.stopPropagation(); deleteAction(${index})" title="åˆªé™¤æ­¥é©Ÿ">ğŸ—‘</button>`;
            const editBtn = `<button class="mini-btn edit" onclick="event.stopPropagation(); editAction(${index})" title="ç·¨è¼¯æ­¤æ­¥é©Ÿ">âœï¸ ç·¨è¼¯</button>`;
            
            const controls = `
                <div class="action-controls">
                    <button class="mini-btn play-from" onclick="event.stopPropagation(); playFromStep(${index})">â–¶ å¾æ­¤æ’­æ”¾</button>
                    <button class="mini-btn play-step" onclick="event.stopPropagation(); playSingleStep(${index})">ğŸ‘ï¸ æ¼”ç¤ºæ­¤æ­¥</button>
                    ${editBtn}
                    ${delBtn}
                </div>
            `;

            li.onclick = (e) => {
                if(e.target.tagName === 'BUTTON') return;
                currentIndex = index;
                renderUI();
                saveToStorage(); 
            };

            li.innerHTML = `
                <div class="action-header">
                    <span class="action-index">${index}</span>
                    <span class="action-desc">${item.action.description}</span>
                </div>
                ${controls}
            `;
            list.appendChild(li);
        });
        
        const endGap = document.createElement('div');
        endGap.className = 'timeline-gap';
        endGap.onclick = () => startDraftAtEnd();
        list.appendChild(endGap);

        document.getElementById('step-counter').innerText = `${currentIndex}/${history.length-1}`;
    }

    function prevStep() { if (currentIndex > 0) { currentIndex--; renderUI(); saveToStorage(); } }
    function nextStep() { if (currentIndex < history.length - 1) { currentIndex++; renderUI(); saveToStorage(); } }
    
    function playFromStep(idx) { 
        currentIndex = idx; renderUI(); saveToStorage();
        if (!playInterval) togglePlay(); 
    }

    function playSingleStep(idx) {
        if (playInterval) togglePlay(); 
        if (idx > 0) {
            currentIndex = idx - 1; renderUI();
            setTimeout(() => { currentIndex = idx; renderUI(); saveToStorage(); }, 500);
        } else {
            currentIndex = 0; renderUI(); saveToStorage();
        }
    }

    function togglePlay() {
        if (playInterval) {
            clearInterval(playInterval); playInterval = null;
            document.getElementById('btn-play').innerText = "â–¶ æ’­æ”¾";
        } else {
            document.getElementById('btn-play').innerText = "â¸ æš«åœ";
            playInterval = setInterval(() => {
                if (currentIndex < history.length - 1) { currentIndex++; renderUI(); saveToStorage(); } 
                else { togglePlay(); }
            }, 1200);
        }
    }
    
    function rotateBoard() { addOperation({type: 'ROTATE'}); }
    
    function exportData() {
        const historyToExport = JSON.parse(JSON.stringify(history));
        historyToExport.forEach((item, index) => { if (index > 0) delete item.state; });
        const data = {
            history: historyToExport,
            initialState: initialState,
            currentIndex: currentIndex,
            timestamp: Date.now(),
            imageRegistry: globalImageRegistry,
            abilityRegistry: globalAbilityStyleRegistry 
        };
        const blob = new Blob([JSON.stringify(data,null,2)], {type:"text/plain"});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `dm-script-${Date.now()}.txt`;
        a.click();
    }

    function processGameData(data, resetToStart = false) {
        globalImageRegistry = data.imageRegistry || {}; 
        globalAbilityStyleRegistry = data.abilityRegistry || {}; 
        initialState = data.initialState;
        let loadedHistory = data.history;
        if (!loadedHistory[0].state) loadedHistory[0].state = cloneState(initialState);
        for (let i = 1; i < loadedHistory.length; i++) {
            if (!loadedHistory[i].state) {
                const prevState = loadedHistory[i-1].state;
                const newState = cloneState(prevState);
                const ops = loadedHistory[i].action.operations;
                ops.forEach(op => applyOperation(newState, op));
                loadedHistory[i].state = newState;
            }
        }
        history = loadedHistory;
        currentIndex = resetToStart ? 0 : (data.currentIndex || 0);
        storageQuotaExceeded = false;
        hasAlertedQuota = false;
        lastRenderedState = null; 
        renderUI();
        saveToStorage();
    }

    function resolveImportConflict(choice) {
        document.getElementById('import-conflict-modal').style.display = 'none';
        if (choice === 'cancel') { pendingImportData = null; return; }
        if (choice === 'save') exportData(); 
        if (choice === 'save' || choice === 'overwrite') {
            if (pendingImportData) {
                try { processGameData(pendingImportData, true); alert("åŒ¯å…¥æˆåŠŸï¼"); } 
                catch(e) { alert("åŒ¯å…¥å¤±æ•—ï¼š" + e.message); }
            }
        }
        pendingImportData = null;
    }

    function importData(input) {
        const file = input.files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const data = JSON.parse(e.target.result);
                if(!data.history || !data.initialState) throw new Error("Invalid format");
                if(confirm("ç¢ºå®šè¦åŒ¯å…¥æ­¤æª”æ¡ˆå—ï¼Ÿ")) {
                    processGameData(data);
                    alert("åŒ¯å…¥æˆåŠŸï¼");
                }
            } catch(err) { alert("åŒ¯å…¥å¤±æ•—"); console.error(err); }
            input.value = ''; 
        };
        reader.readAsText(file);
    }

    function openSelectorModal(zoneId) {
        const state = getCurrentDisplayState();
        const cards = getCardsInZone(state, zoneId);
        const body = document.getElementById('modal-body');
        body.innerHTML = '';
        selectedCardsInModal = [];
        const title = document.getElementById('modal-title');
        title.innerText = `${getZoneName(zoneId)} (${cards.length})`;
        title.setAttribute('data-zone-id', zoneId); 
        
        cards.forEach((card, index) => {
            const el = document.createElement('div');
            el.className = 'card';
            
            // Req 2: Render Image in List
            if (card.image && (globalImageRegistry[card.imageKey] || globalImageRegistry[card.backImageKey])) {
                const imgKey = card.imageKey || card.backImageKey;
                el.style.backgroundImage = `url(${globalImageRegistry[imgKey]})`;
                el.classList.add('has-image-icon');
            }

            el.innerHTML += `<div style="position:absolute; top:2px; left:2px; font-size:10px; color:#888; font-weight:bold; z-index:10;">#${index+1}</div>
                            <div class="card-text">${card.text}</div>`;
            el.onclick = () => {
                if (selectedCardsInModal.includes(card.id)) {
                    selectedCardsInModal = selectedCardsInModal.filter(id=>id!==card.id);
                    el.classList.remove('selected');
                } else {
                    selectedCardsInModal.push(card.id);
                    el.classList.add('selected');
                }
            };
            body.appendChild(el);
        });
        document.getElementById('card-selector-modal').style.display = 'flex';
    }
    function closeSelectorModal() { document.getElementById('card-selector-modal').style.display = 'none'; }
    function prepareMove(shuffle) {
        if(selectedCardsInModal.length===0) return;
        pendingMove = { cardIds: [...selectedCardsInModal], shuffle };
        closeSelectorModal();
        updateSelectionUI();
    }

	function openPositionSelector(zoneId, moveData) {
        const modal = document.getElementById('position-selector-modal');
        const list = document.getElementById('position-list');
        const gui = document.getElementById('stack-gui');
        
        // æ¨™é¡Œèˆ‡æ¨¡å¼åˆ‡æ›
        document.getElementById('pos-modal-title').innerText = "æ’å…¥ä½ç½®é¸æ“‡ (é»æ“Šè™›ç·šæ¡†)";
        gui.style.display = 'none';
        list.style.display = 'flex'; 
        list.innerHTML = ''; 
        
        const state = getCurrentDisplayState();
        const cards = getCardsInZone(state, zoneId);

        // --- æ ¸å¿ƒé‚è¼¯ï¼šäº¤éŒ¯ç”Ÿæˆ [æ’æ§½] èˆ‡ [åƒè€ƒå¡] ---
        
        // 1. å…ˆæ”¾æœ€é ‚éƒ¨çš„æ’æ§½ (Index 0)
        list.appendChild(createSlotElement(0, "é ‚", zoneId));
        
        for (let i = 0; i < cards.length; i++) {
            const card = cards[i];
            
            // 2. æ”¾å…¥åƒè€ƒå¡ç‰‡ (Visual)
            const refCard = document.createElement('div');
            refCard.className = 'position-card-ref';
            
            // è™•ç†åœ–ç‰‡èˆ‡æ–‡å­—
            if (card.image && (globalImageRegistry[card.imageKey] || globalImageRegistry[card.backImageKey])) {
                const imgKey = card.imageKey || card.backImageKey;
                refCard.style.backgroundImage = `url(${globalImageRegistry[imgKey]})`;
                refCard.classList.add('has-image-icon');
                refCard.innerHTML = `<span style="display:none;">${card.text}</span>`; // éš±è—æ–‡å­—ä½†ä¿ç•™çµæ§‹
            } else {
                refCard.innerHTML = `<span style="padding:2px; word-break:break-all; line-height:1;">${card.text}</span>`;
            }
            
            // å·¦ä¸Šè§’åŠ å…¥åºè™Ÿï¼Œæ–¹ä¾¿å°ç…§
            const idxBadge = document.createElement('div');
            idxBadge.style.cssText = "position:absolute; top:0; left:0; background:rgba(0,0,0,0.6); color:white; font-size:8px; padding:1px 3px; border-bottom-right-radius:3px;";
            idxBadge.innerText = i + 1;
            refCard.appendChild(idxBadge);
            
            list.appendChild(refCard);

            // 3. æ”¾å…¥è©²å¡ç‰‡ä¹‹å¾Œçš„æ’æ§½ (Index i+1)
            // å¦‚æœæ˜¯æœ€å¾Œä¸€å¼µï¼Œæ¨™ç¤ºç‚ºã€Œåº•ã€
            const isTop = (i === cards.length - 1);
            list.appendChild(createSlotElement(i + 1, isTop ? "åº•" : "", zoneId, isTop));
        }

        modal.style.display = 'flex';
    }

    // å»ºç«‹æ’æ§½çš„è¼”åŠ©å‡½å¼
    function createSlotElement(index, text, zoneId, isTop) {
        const div = document.createElement('div');
        div.className = 'position-slot';
        
        // å¦‚æœæœ‰å‚³å…¥æ–‡å­—(åº•/é ‚)å°±é¡¯ç¤ºæ–‡å­—ï¼Œå¦å‰‡é¡¯ç¤ºä¸€å€‹ '+'
        if (text) {
            div.innerHTML = `<span style="font-weight:bold; ${isTop ? 'color:#e74c3c;' : ''}">${text}</span>`;
        } else {
            div.innerHTML = `<span style="opacity:0.3; font-size:1.2rem;">+</span>`;
        }
        
        div.title = `æ’å…¥è‡³ç¬¬ ${index} å¼µç‰Œçš„ä½ç½®`;
        div.onclick = () => finishMove(zoneId, index);
        return div;
    }

    function closePositionModal() {
        document.getElementById('position-selector-modal').style.display = 'none';
    }

    window.addEventListener('beforeunload', (e) => {
        if (storageQuotaExceeded) {
            e.preventDefault();
            e.returnValue = 'å„²å­˜ç©ºé–“å·²æ»¿ï¼Œæ‚¨çš„è³‡æ–™å¯èƒ½å°šæœªå„²å­˜ã€‚å»ºè­°å…ˆåŒ¯å‡ºè³‡æ–™ã€‚';
            return e.returnValue;
        }
    });

    window.onload = function() {
        const hasLocalData = loadFromStorage();
        const urlParams = new URLSearchParams(window.location.search);
        const scriptUrl = urlParams.get('scriptUrl');

        if (scriptUrl) {
            console.log("Found scriptUrl:", scriptUrl);
            fetch(scriptUrl)
                .then(res => { if(!res.ok) throw new Error(res.status); return res.json(); })
                .then(data => {
                    if(!data.history || !data.initialState) throw new Error("Invalid script");
                    if (hasLocalData) {
                        pendingImportData = data;
                        document.getElementById('import-conflict-modal').style.display = 'flex';
                    } else {
                        processGameData(data, true);
                    }
                    window.history.replaceState({}, document.title, window.location.pathname);
                })
                .catch(e => {
                    alert("ç„¡æ³•è¼‰å…¥æŒ‡å®šåŠ‡æœ¬: " + e.message);
                    if(!hasLocalData) openSetupModal();
                });
        } else {
            if (!hasLocalData) openSetupModal();
        }
    };
</script>
</body>
</html>