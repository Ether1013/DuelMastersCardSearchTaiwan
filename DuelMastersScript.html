
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Duel Masters Script Director - 決鬥王劇情編輯器 (DM TCG Editor)</title>
    <meta name="description" content="Duel Masters Script Director is a web-based TCG simulator for creating battle scenarios, replays, and visual novel-style dialogues. 決鬥王劇情編輯器，提供線上對戰模擬、劇本編寫與重播功能。デュエル・マスターズの対戦シミュレーター兼スクリプト作成ツール。">    
    <meta name="keywords" content="Duel Masters, Duel Masters Script Director, DM TCG, 決鬥王, 決鬥王劇情編輯器, 決鬥大師, 決鬥王, 卡牌遊戲模擬器, TCG Editor, Replay Generator, デュエル・マスターズ, デュエマ, DM, 対戦シミュレーター, 盤面作成, 架空対戦, スクリプトエディタ">   
    <meta name="author" content="Ether">
    <meta property="og:title" content="Duel Masters Script Director - 決鬥王劇情編輯器">
    <meta property="og:description" content="Create, edit, and share Duel Masters battle scenarios with dialogue. 線上決鬥王盤面模擬與劇本編輯工具。">
    <meta property="og:type" content="website">
    <style>
        :root {
            --card-width: 50px;
            --card-height: 70px;
            --bg-color: #dcdcdc;
            --p1-color: #e3f2fd;
            --p2-color: #fce4ec;
            --timeline-width: 320px;
            --highlight-color: #f1c40f;
        }

        * { box-sizing: border-box; }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #toolbar {
            height: 45px;
            background: #2c3e50;
            color: white;
            display: flex;
            align-items: center;
            padding: 0 10px;
            gap: 10px;
            flex-shrink: 0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 50;
        }

        #draft-bar {
            background: #e67e22;
            color: white;
            padding: 5px 10px;
            display: none;
            align-items: center;
            justify-content: space-between;
            font-size: 0.9rem;
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        #draft-bar label {
            display: flex; align-items: center; gap: 5px; cursor: pointer; user-select: none;
            background: rgba(0,0,0,0.1); padding: 2px 8px; border-radius: 4px;
        }

        #point-bar {
            background: #8e44ad;
            color: white;
            padding: 5px 10px;
            display: none;
            align-items: center;
            justify-content: space-between;
            font-size: 0.9rem;
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        /* --- 修改：操作面板樣式 (雙層版) --- */
		#card-action-panel {
			position: fixed;
			bottom: auto; 
			left: 0; 
			transform: none; 
			cursor: move;
			
			background: rgba(44, 62, 80, 0.95);
			color: white;
			padding: 8px 12px;
			border-radius: 8px;
			
			/* [修改] 改為垂直排列，讓兩行分開 */
			display: none; /* 由 JS 控制顯示 */
			flex-direction: column; 
			gap: 8px; /* 上下行的間距 */
			
			align-items: center;
			z-index: 1000;
			box-shadow: 0 5px 15px rgba(0,0,0,0.5);
			backdrop-filter: blur(5px);
			border: 1px solid #555;
			
			/* 寬度設為 auto，讓內容撐開 */
			width: auto;
			max-width: 90vw; /* 防止超出螢幕 */
		}

        /* [新增] 單行容器樣式 */
        .panel-row {
            display: flex;
            gap: 5px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap; /* 空間不足時允許換行 */
        }

        /* [新增] 垂直分隔線樣式 */
        .panel-sep {
            border-left: 1px solid #7f8c8d; 
            height: 20px; 
            margin: 0 5px;
            opacity: 0.5;
        }

		/* 避免拖曳時選取到面板內的文字 */
		#card-action-panel * { user-select: none; }
		#card-action-panel input, #card-action-panel button { cursor: pointer; }
		#card-action-panel input { cursor: text; user-select: auto; }

		/* 避免拖曳時選取到面板內的文字 */
		#card-action-panel * {
			user-select: none;
		}

		/* 輸入框與按鈕恢復預設游標 */
		#card-action-panel input,
		#card-action-panel button {
			cursor: pointer;
		}
		#card-action-panel input {
			cursor: text;
			user-select: auto;
		}
        
        button {
            background: #34495e;
            color: white;
            border: 1px solid #566573;
            padding: 4px 10px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 0.85rem;
            transition: all 0.2s;
        }
        button:hover { background: #4e6479; transform: translateY(-1px); }
        button:active { transform: translateY(1px); }
        
        button.primary { background: #2ecc71; border-color: #27ae60; font-weight: bold; }
        button.primary:hover { background: #27ae60; }
        
        button.danger { background: #c0392b; border-color: #e74c3c; }
        button.danger:hover { background: #e74c3c; }

        input[type="text"], input[type="number"] {
            padding: 4px;
            border-radius: 4px;
            border: 1px solid #ccc;
            font-size: 0.85rem;
        }

        #workspace {
            display: flex;
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        #svg-layer {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			pointer-events: none; 
			z-index: 999; 
			/* 確保沒有其他 transform 干擾，它會繼承父層 workspace 的 scale */
		}
        
        .arrow-line {
            stroke: rgba(231, 76, 60, 0.8);
            stroke-width: 4;
            stroke-dasharray: 10, 5;
            animation: dash 1s linear infinite;
            marker-end: url(#arrowhead);
            fill: none;
        }
        @keyframes dash { to { stroke-dashoffset: -15; } }

        #ability-stack-zone {
            width: 100px;
            background: #bdc3c7;
            border-right: 2px solid #7f8c8d;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            z-index: 10;
        }

        #ability-stack-zone.rotated-view {
            flex-direction: column-reverse;
        }

        .ability-column {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 5px 0;
            overflow-y: auto;
            position: relative;
            gap: 5px;
        }

        #ability-zone-p2 { background: rgba(252, 228, 236, 0.5); }
        #ability-zone-p1 { background: rgba(227, 242, 253, 0.5); }

        #ability-stack-zone:not(.rotated-view) #ability-zone-p2 { border-bottom: 2px dashed #7f8c8d; }
        #ability-stack-zone.rotated-view #ability-zone-p1 { border-bottom: 2px dashed #7f8c8d; }

        .ability-label {
            font-size: 0.7rem;
            font-weight: bold;
            color: #555;
            margin-bottom: 5px;
            opacity: 0.7;
        }

        #game-board-container {
            flex: 1;
            background: #95a5a6;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow: hidden; 
        }

        #main-board {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            background: white;
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
        }

        /* Turn Indicators */
        .turn-bar {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 12px;
            background: #95a5a6;
            z-index: 50;
            transition: all 0.5s ease;
            border-right: 1px solid rgba(0,0,0,0.1);
        }
        
        #player1-area.active-turn .turn-bar {
            background: #3498db;
            box-shadow: 0 0 15px 2px rgba(52, 152, 219, 0.8);
            animation: pulse-blue 2s infinite;
        }
        
        #player2-area.active-turn .turn-bar {
            background: #e91e63;
            box-shadow: 0 0 15px 2px rgba(233, 30, 99, 0.8);
            animation: pulse-red 2s infinite;
        }
        
        @keyframes pulse-blue {
            0% { box-shadow: 0 0 10px 2px rgba(52, 152, 219, 0.5); }
            50% { box-shadow: 0 0 20px 5px rgba(52, 152, 219, 0.9); }
            100% { box-shadow: 0 0 10px 2px rgba(52, 152, 219, 0.5); }
        }

        @keyframes pulse-red {
            0% { box-shadow: 0 0 10px 2px rgba(233, 30, 99, 0.5); }
            50% { box-shadow: 0 0 20px 5px rgba(233, 30, 99, 0.9); }
            100% { box-shadow: 0 0 10px 2px rgba(233, 30, 99, 0.5); }
        }

        #reveal-zone {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            min-width: 200px;
            min-height: 120px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px dashed #f1c40f;
            border-radius: 10px;
            z-index: 300; 
            display: none;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
            padding: 30px 20px 20px 20px; 
            transition: opacity 0.3s;
            box-shadow: 0 0 20px rgba(241, 196, 15, 0.3);
        }
        
        #reveal-zone .zone-label {
            top: 5px;
            left: 10px;
            width: auto;
            transform: none;
            color: #f1c40f;
            text-shadow: none;
            font-size: 1rem;
            pointer-events: none;
        }

        #timeline-panel {
            width: var(--timeline-width);
            background: #ecf0f1;
            border-left: 1px solid #bdc3c7;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            z-index: 20;
        }

        #timeline-header {
            padding: 8px;
            background: #34495e;
            color: white;
            font-weight: bold;
            text-align: center;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
        }

        #action-list {
            flex: 1;
            overflow-y: auto;
            list-style: none;
            padding: 0;
            margin: 0;
            padding-bottom: 20px;
        }

        .timeline-gap {
            height: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            position: relative;
        }
        .timeline-gap:hover::after {
            content: "+";
            background: #3498db;
            color: white;
            width: 20px; height: 20px;
            border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            font-weight: bold;
            font-size: 14px;
            position: absolute;
            z-index: 5;
        }
        .timeline-gap::before {
            content: "";
            height: 2px;
            background: #ccc;
            width: 80%;
            position: absolute;
        }

        .action-item {
            padding: 8px 10px;
            border-bottom: 1px solid #dcdcdc;
            cursor: pointer;
            font-size: 0.85rem;
            display: flex;
            flex-direction: column;
            gap: 5px;
            background: #fdfdfd;
            border-left: 4px solid transparent;
        }
        .action-item:hover { background: #f0f4f7; }
        .action-item.active { background: #e8f6fd; border-left-color: #2980b9;}
        .action-item.editing { background: #fff3e0; border-left-color: #e67e22; }

        .action-item.p1-action { border-left: 4px solid #3498db; background: rgba(52, 152, 219, 0.05); }
        .action-item.p1-action.active { background: rgba(52, 152, 219, 0.2); }
        
        .action-item.p2-action { border-left: 4px solid #e91e63; background: rgba(233, 30, 99, 0.05); }
        .action-item.p2-action.active { background: rgba(233, 30, 99, 0.2); }

        .action-header { display: flex; align-items: center; width: 100%; justify-content: space-between; }
        .action-index { font-weight: bold; margin-right: 6px; min-width: 18px; text-align: right; color: #7f8c8d;}
        .action-desc { flex: 1; white-space: pre-wrap; word-break: break-all; font-weight: 500;}
        
        .action-controls {
            display: flex; gap: 5px; margin-top: 5px; padding-left: 24px; opacity: 0.4; transition: opacity 0.2s;
        }
        .action-item:hover .action-controls, .action-item.active .action-controls { opacity: 1; }
        
        .mini-btn { font-size: 0.75rem; padding: 3px 8px; background: #bdc3c7; border: none; color: #2c3e50; border-radius: 3px; cursor: pointer;}
        .mini-btn:hover { background: #95a5a6; color: white; }
        .mini-btn.play-from { background: #2ecc71; color: white; }
        .mini-btn.play-from:hover { background: #27ae60; }
        .mini-btn.play-step { background: #3498db; color: white; }
        .mini-btn.play-step:hover { background: #2980b9; }
        .mini-btn.edit { background: #f39c12; color: white; }
        .mini-btn.edit:hover { background: #e67e22; }
        .mini-btn.delete-all { background: #c0392b; color: white; font-weight:bold; padding: 2px 6px; border-radius:3px; cursor:pointer; border:none;}

        .icon-btn { background: none; border: none; cursor: pointer; padding: 2px; opacity: 0.5; font-size: 1rem; }
        .icon-btn:hover { opacity: 1; transform: scale(1.1); }
        .icon-btn.delete { color: #c0392b; }

        .player-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 2px;
            position: relative;
            padding-left: 15px; /* Space for turn bar */
        }

        #player2-area {
            background-color: var(--p2-color);
            border-bottom: 2px dashed #999;
        }
        
        #player2-area .bottom-row { order: -1; }
        #player2-area .mana-zone { order: 0; }
        #player2-area .shield-zone { order: 1; }
        #player2-area .battle-zone { order: 2; }
        
        #player1-area { background-color: var(--p1-color); }

        .zone {
            border: 1px solid rgba(0,0,0,0.15);
            margin: 1px;
            display: flex;
            align-items: center;
            position: relative;
            min-height: var(--card-height);
            border-radius: 3px;
        }
        
        .zone.target-highlight {
            background-color: rgba(46, 204, 113, 0.4);
            border: 2px dashed #27ae60;
            box-shadow: inset 0 0 10px rgba(46, 204, 113, 0.5);
            cursor: copy;
            z-index: 100;
        }
        
        /* Zone Glows (New Feature) */
        .zone.glow-red { box-shadow: inset 0 0 20px rgba(255, 0, 0, 0.5); border: 2px solid red; }
        .zone.glow-yellow { box-shadow: inset 0 0 20px rgba(255, 215, 0, 0.5); border: 2px solid gold; }
        .zone.glow-green { box-shadow: inset 0 0 20px rgba(0, 255, 0, 0.5); border: 2px solid lime; }
        .zone.glow-blue { box-shadow: inset 0 0 20px rgba(0, 191, 255, 0.5); border: 2px solid deepskyblue; }
        .zone.glow-black { box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5); border: 2px solid black; }
        .zone.glow-white { box-shadow: inset 0 0 20px rgba(255, 255, 255, 0.8); border: 2px solid white; }
        .zone.glow-rainbow { animation: zone-rainbow 2s linear infinite; }
        @keyframes zone-rainbow {
            0% { border-color: red; box-shadow: inset 0 0 20px rgba(255,0,0,0.5); }
            50% { border-color: blue; box-shadow: inset 0 0 20px rgba(0,255,0,0.5); }
            100% { border-color: red; box-shadow: inset 0 0 20px rgba(255,0,0,0.5); }
        }

        .zone.point-target-highlight {
            background-color: rgba(142, 68, 173, 0.2);
            border: 2px dashed #9b59b6;
            cursor: crosshair;
            z-index: 100;
        }
        .card.point-target-highlight {
            box-shadow: 0 0 10px 5px rgba(155, 89, 182, 0.8);
            z-index: 101;
            cursor: crosshair;
        }
        .card.point-target-selected {
            box-shadow: 0 0 15px 8px #8e44ad;
            border: 2px solid #8e44ad;
        }

        .zone-label {
            position: absolute; font-size: 0.8rem; color: rgba(0,0,0,0.25);
            font-weight: 900; pointer-events: none; z-index: 0; width: 100%; text-align: center;
            top: 50%; transform: translateY(-50%); text-transform: uppercase;
        }

        .bottom-row { display: flex; height: var(--card-height); margin-top: auto; }
        .hand-zone { flex: 1; overflow-x: auto; padding: 2px; scrollbar-width: thin;}
        .side-zone-group { width: 170px; display: flex; gap: 3px; padding-left: 3px; flex-shrink: 0; }
        
        .stacked { flex: 1; justify-content: center; cursor: zoom-in; background: rgba(0,0,0,0.1); border: 1px solid rgba(0,0,0,0.3); }
        .mana-zone { height: calc(var(--card-height) * 0.6); background: rgba(0,0,0,0.05); }
        .shield-zone { height: calc(var(--card-height) * 0.85); justify-content: center; gap: 5px; }
        .battle-zone { flex: 1; background: rgba(255,255,255,0.6); justify-content: center; gap: 4px; padding: 5px; }

        .card-group {
            position: relative;
            /* Changed from fixed width to auto/min-width to support God Link/Puzzle stacking */
            width: auto; 
            min-width: var(--card-width);
            height: var(--card-height);
            margin: 0 5px; /* Increased margin for better separation */
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.3s;
        }

        .card-group:hover {
            z-index: 500;
        }
		/* [新增] 強制覆蓋舊的堆疊 CSS，將定位權限完全交給 JS */
        .card-group .card {
            /* 確保 JS 寫入的 top/left 不會被 CSS class 影響 */
            margin: 0 !important; 
        }
        /* 移除 hover 時的展開效果 (因為旋轉後展開方向會錯亂，暫時先移除，求穩) */
        .card-group:hover .card {
            top: auto !important; /* 讓 JS 的 inline-style 生效 */
        }
        /* 如果您還是希望有 Hover 展開，那需要更複雜的 JS 計算，建議先取消以確保旋轉正確 */
        /* Hover Fan-out - modified to respect Puzzle links */
        .card-group:hover .stack-base { top: 0px !important; z-index: 100; }
        /* Only fan out vertical stacks if not puzzling */
        .card-group:hover .stack-top:not(.puzzle-link) { z-index: 101; }
        .card-group:hover .stack-shift-up { top: -50px !important; z-index: 101; }
        .card-group:hover .stack-shift-down { top: -30px !important; z-index: 101; }
        .card-group:hover .stack-bottom { top: 40px !important; z-index: 102; box-shadow: 0 0 10px rgba(0,0,0,0.5); }

        .card {
            width: var(--card-width); height: var(--card-height);
            background-color: white; border: 1px solid #333; border-radius: 3px;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            position: relative; font-size: 9px; cursor: pointer;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.4); user-select: none;
            transition: box-shadow 0.2s, border-color 0.2s; 
            z-index: 1; flex-shrink: 0; overflow: hidden;
            will-change: transform, top, left;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }
        
        .card.has-image { border: none; }
        .card.has-image[class*="glow-"] { border: 1px solid transparent; }
        .card.has-image .card-text { display: none; }

        .card.interactive { transition: transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1); }
        .card:hover { z-index: 200; box-shadow: 0 4px 10px rgba(0,0,0,0.3); }
        /* 修改後 (加入 !important) */
		.card.selected { 
			box-shadow: 0 0 0 3px #f1c40f, 0 0 8px #f1c40f !important; 
			z-index: 100; 
		}
        .card.face-down { 
            background: #2c3e50;
            background-image: radial-gradient(circle, #34495e 10%, transparent 10%);
            background-size: 15px 15px; border: 1px solid white; color: transparent; 
        }
        
        .card-note {
            position: absolute; top: 1px; left: 2px; right: 2px;
            background: #f1c40f; color: black; font-size: 8px; text-align: center;
            border: 1px solid #d35400; z-index: 5;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
            pointer-events: none; border-radius: 2px; box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }
		
		/* --- [新增] 待處理區註記樣式 (左側縱條) --- */
        
        /* 1. 覆寫原本橫條的位置，改為左側直條 */
        .ability-card .card-note {
            /* 重置原本的定位 */
            top: 0 !important;
            bottom: 0 !important; /* 填滿高度 */
            left: 0 !important;
            right: auto !important;
            
            /* 設定寬度 */
            width: 16px; 
            height: 100%;
            
            /* 垂直文字排版 (直書) */
            writing-mode: vertical-rl; 
            text-orientation: upright; /* 讓中文字直立，英文轉向 */
            
            /* 內容置中 */
            display: flex;
            justify-content: center;
            align-items: center;
            
            /* 外觀修飾：左邊圓角，右邊直線 */
            border-radius: 2px 0 0 2px !important;
            border: none !important;
            border-right: 1px solid #d35400 !important;
            
            /* 陰影改成往右打 */
            box-shadow: 1px 0 3px rgba(0,0,0,0.2) !important;
            
            /* 字體微調 */
            font-size: 9px;
            letter-spacing: 1px;
            padding: 2px 0;
        }

        /* 2. 修正卡片文字內距，避免被左邊的註記條擋住 */
        .ability-card .card-text {
            padding-left: 18px !important; /* 讓出空間給左側條 (16px + 2px buffer) */
            text-align: left !important;   /* 改為靠左對齊比較好看 */
        }

        /* Stacking classes */
        .stack-base { z-index: 10; position: absolute; }
        .stack-top { z-index: 20; position: absolute; }
        .stack-bottom { z-index: 5; position: absolute; }
        .stack-shift-up { z-index: 20; position: absolute; }
        .stack-shift-down { z-index: 20; position: absolute; }
        .stack-bottom-exposed { z-index: 5; position: absolute; }
        .stack-top-offset { z-index: 20; position: absolute; }
        
        /* New Puzzle/Link Stacking Classes */
        .puzzle-link { /* Generic marker */ }
        .stack-puzzle-top { z-index: 20; position: absolute; }
        .stack-puzzle-bottom { z-index: 20; position: absolute; }
        .stack-puzzle-left { z-index: 20; position: absolute; }
        .stack-puzzle-right { z-index: 20; position: absolute; }

        .glow-red { box-shadow: 0 0 8px 4px rgba(255, 0, 0, 0.8) !important; border-color: red !important; }
        .glow-yellow { box-shadow: 0 0 8px 4px rgba(255, 215, 0, 0.8) !important; border-color: gold !important; }
        .glow-green { box-shadow: 0 0 8px 4px rgba(0, 255, 0, 0.8) !important; border-color: lime !important; }
        .glow-blue { box-shadow: 0 0 8px 4px rgba(0, 191, 255, 0.8) !important; border-color: deepskyblue !important; }
        .glow-black { box-shadow: 0 0 8px 4px rgba(0, 0, 0, 0.8) !important; border-color: black !important; }
        .glow-white { box-shadow: 0 0 8px 4px rgba(255, 255, 255, 0.9) !important; border-color: white !important; }
        .glow-rainbow { animation: rainbow 2s linear infinite !important; }
		
		/* 補回遺失的 rainbow 動畫關鍵影格 */
        @keyframes rainbow {
            0% { box-shadow: 0 0 8px 4px rgba(255, 0, 0, 0.8); border-color: red; }
            15% { box-shadow: 0 0 8px 4px rgba(255, 165, 0, 0.8); border-color: orange; }
            30% { box-shadow: 0 0 8px 4px rgba(255, 255, 0, 0.8); border-color: yellow; }
            45% { box-shadow: 0 0 8px 4px rgba(0, 255, 0, 0.8); border-color: lime; }
            60% { box-shadow: 0 0 8px 4px rgba(0, 127, 255, 0.8); border-color: cyan; }
            75% { box-shadow: 0 0 8px 4px rgba(0, 0, 255, 0.8); border-color: blue; }
            90% { box-shadow: 0 0 8px 4px rgba(139, 0, 255, 0.8); border-color: violet; }
            100% { box-shadow: 0 0 8px 4px rgba(255, 0, 0, 0.8); border-color: red; }
        }
		
		/* --- [新增] 下半部發光特效 (Bottom Glow) --- */

		/* 1. 基礎設定 */
		.card[class*="glow-bottom-"]::after {
			content: "";
			position: absolute;
			bottom: 0;
			left: 0;
			width: 100%;
			height: 50%; /* 覆蓋下半部 50% */
			z-index: 10;
			pointer-events: none;
			border-bottom-left-radius: 3px;
			border-bottom-right-radius: 3px;
			opacity: 0.85;
			transition: opacity 0.2s;
		}

		/* --- [新增] 下半部發光特效 (Bottom Glow) --- */

		/* 1. 基礎設定 */
		.card[class*="glow-bottom-"]::after {
			content: "";
			position: absolute;
			bottom: 0;
			left: 0;
			width: 100%;
			height: 50%; /* 覆蓋下半部 50% */
			z-index: 10;
			pointer-events: none;
			border-bottom-left-radius: 3px;
			border-bottom-right-radius: 3px;
			opacity: 0.85;
			transition: opacity 0.2s;
		}

		/* 2. 各顏色定義 */
		.card.glow-bottom-red::after {
			background: linear-gradient(to top, rgba(255, 0, 0, 0.8) 0%, rgba(255, 0, 0, 0) 100%);
			border-bottom: 3px solid red;
			box-shadow: 0 4px 10px rgba(255, 0, 0, 0.5);
		}
		.card.glow-bottom-yellow::after {
			background: linear-gradient(to top, rgba(255, 215, 0, 0.8) 0%, rgba(255, 215, 0, 0) 100%);
			border-bottom: 3px solid gold;
			box-shadow: 0 4px 10px rgba(255, 215, 0, 0.5);
		}
		.card.glow-bottom-green::after {
			background: linear-gradient(to top, rgba(0, 255, 0, 0.8) 0%, rgba(0, 255, 0, 0) 100%);
			border-bottom: 3px solid lime;
			box-shadow: 0 4px 10px rgba(0, 255, 0, 0.5);
		}
		.card.glow-bottom-blue::after {
			background: linear-gradient(to top, rgba(0, 191, 255, 0.8) 0%, rgba(0, 191, 255, 0) 100%);
			border-bottom: 3px solid deepskyblue;
			box-shadow: 0 4px 10px rgba(0, 191, 255, 0.5);
		}
		.card.glow-bottom-black::after {
			background: linear-gradient(to top, rgba(0, 0, 0, 0.9) 0%, rgba(0, 0, 0, 0) 100%);
			border-bottom: 3px solid black;
			box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
		}
		.card.glow-bottom-white::after {
			background: linear-gradient(to top, rgba(255, 255, 255, 0.9) 0%, rgba(255, 255, 255, 0) 100%);
			border-bottom: 3px solid white;
			box-shadow: 0 4px 10px rgba(255, 255, 255, 0.5);
		}
		.card.glow-bottom-rainbow::after {
			background: linear-gradient(to top, rgba(255, 0, 255, 0.6) 0%, rgba(0, 255, 255, 0) 100%);
			border-bottom: 3px solid white;
			animation: bottom-rainbow-anim 2s linear infinite;
		}

		@keyframes bottom-rainbow-anim {
			0% { border-bottom-color: red; box-shadow: 0 4px 10px rgba(255,0,0,0.5); }
			50% { border-bottom-color: blue; box-shadow: 0 4px 10px rgba(0,0,255,0.5); }
			100% { border-bottom-color: red; box-shadow: 0 4px 10px rgba(255,0,0,0.5); }
		}

        .ability-card { width: 80px; height: 35px; flex-direction: row; font-size: 8px; transform: none !important; cursor: pointer; overflow: hidden; }
        .ability-card .card-text { font-size: 8px; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; max-width: 90%; }
        .ability-card .card-power { display: none; }

        .card-power { 
            position: absolute; bottom: 0; left: 0; width: 100%;
            background: rgba(255,255,255,0.9); border-top: 1px solid #000; 
            text-align: center; font-weight: bold; font-size: 9px; color: black;
        }
        .card-text { padding: 2px; text-align: center; line-height: 1.1; font-weight: 500;}

        .count-badge {
            position: absolute; top: -6px; right: -6px;
            background: #e74c3c; color: white;
            border-radius: 50%; width: 20px; height: 20px;
            display: flex; justify-content: center; align-items: center;
            font-size: 10px; font-weight: bold; z-index: 50;
            border: 1px solid white; box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .modal {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); z-index: 2000;
            justify-content: center; align-items: center; backdrop-filter: blur(2px);
        }
        .modal-content {
            background: white; border-radius: 8px; box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            padding: 20px; display: flex; flex-direction: column;
            animation: slideUp 0.3s ease;
        }
        
        #setup-modal { display: none; }
        #setup-modal .modal-content { width: 320px; gap: 15px; }
        .input-group { display: flex; justify-content: space-between; align-items: center; }
        .input-group label { font-weight: bold; font-size: 0.9rem; }
        .input-group input { width: 60px; text-align: center; }

        #card-selector-modal .modal-content { width: 85%; max-width: 900px; height: 85%; }
        #modal-body { flex: 1; overflow-y: auto; display: flex; flex-wrap: wrap; gap: 12px; padding: 15px; background: #f8f9fa; border-radius: 4px; align-content: flex-start; }
        /* Style for cards in selector list that have images */
        #modal-body .card.has-image-icon { background-size: cover; background-position: center; color: transparent; text-shadow: none; }

        #position-selector-modal .modal-content { width: 90%; max-width: 600px; height: auto; max-height: 80vh; display: flex; flex-direction: column; }
		
		/* 容器：縮小間距讓縫隙感更明顯 */
        #position-list {
            flex: 1; 
            overflow-y: auto; 
            display: flex; 
            flex-wrap: wrap; 
            gap: 2px;            /* [修改] 間距縮小，讓插槽緊貼卡片 */
            padding: 10px; 
            background: #eee; 
            border-radius: 4px; 
            min-height: 0;
            align-content: flex-start;
        }

		/* 插槽：強制設定為極窄的縫隙 (約 14px) */
        .position-slot {
            /* 強制固定寬度，不讓 Flex 或內容撐開 */
            width: 14px !important;
            min-width: 14px !important; 
            max-width: 14px !important;
            height: var(--card-height);
            
            /* 隱藏溢出的文字 (Top/Bottom/+) */
            overflow: hidden; 
            
            background: rgba(0, 0, 0, 0.1); 
            border: 1px dashed #999;
            border-radius: 2px;
            
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s;
            
            /* 讓這個元素不會被壓縮或放大 */
            flex-shrink: 0;
            flex-grow: 0;
            
            /* 隱藏文字顏色 */
            color: transparent; 
        }
        
        /* 滑鼠移上去時：變寬、變色，方便操作 */
        .position-slot:hover { 
            /* Hover 時展開到一半卡片寬，方便確認 */
            width: 25px !important; 
            min-width: 25px !important;
            max-width: 25px !important;
            
            background: #3498db; 
            border-color: #2980b9; 
            z-index: 100;
            box-shadow: 0 0 5px rgba(52, 152, 219, 0.8);
            
            /* Hover 時顯示一點文字提示 (如果顏色不是透明的話) */
            /* color: white; */ 
        }

        /* 為了區分頭尾，我們可以利用 JS 賦予的 title 屬性來做樣式 (選用)
           或是保持統一的縫隙樣式，讓使用者依賴直覺 (最左=底，最右=頂) */
        
        /* 2. 參考卡樣式：尺寸同卡片，作為視覺參考 */
        .position-card-ref {
            width: var(--card-width); 
            height: var(--card-height);
            border: 1px solid #7f8c8d;
            border-radius: 3px;
            background-color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.6rem;
            color: #333;
            pointer-events: none; /* 禁止點擊卡片本身，強迫點擊插槽 */
            flex-shrink: 0;
            background-size: cover;
            background-position: center;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.2);
            overflow: hidden;
            opacity: 0.85;
        }

        /* [選用] 在卡片右側加一個微小的箭頭指示順序 */
        .position-card-ref::after {
            content: "➜";
            position: absolute;
            right: -8px; 
            top: 50%;
            transform: translateY(-50%);
            font-size: 8px;
            color: #999;
            z-index: 5;
            display: none; /* 如果覺得畫面太亂可以保持隱藏 */
        }
        
        #stack-gui {
            display: grid;
            grid-template-columns: repeat(3, 1fr); /* Changed to 3 columns to fit more options */
            gap: 10px;
            margin-top: 10px;
            overflow-y: auto;
        }
        .stack-option {
            background: #f8f9fa; border: 2px solid #ddd;
            border-radius: 8px; padding: 10px;
            text-align: center; cursor: pointer;
            transition: all 0.2s;
            display: flex; flex-direction: column; align-items: center; gap: 5px;
            font-size: 0.8rem;
        }
        .stack-option:hover { border-color: #3498db; background: #ebf5fb; transform: translateY(-2px); box-shadow: 0 3px 8px rgba(0,0,0,0.1); }
        .stack-icon {
            width: 30px; height: 40px; background: #ccc; border: 1px solid #999;
            position: relative; display: block; margin-bottom: 5px;
        }
        /* Existing Icons */
        .icon-top .child { position: absolute; top:0; left:0; width:100%; height:100%; background:#3498db; border:1px solid white; z-index:2; opacity:0.8; }
        .icon-bottom .child { position: absolute; top:0; left:0; width:100%; height:100%; background:#2c3e50; border:1px solid white; z-index:-1; }
        .icon-up .child { position: absolute; top:-15px; left:0; width:100%; height:100%; background:#e67e22; border:1px solid white; z-index:2; opacity:0.9; }
        .icon-down .child { position: absolute; top:15px; left:0; width:100%; height:100%; background:#9b59b6; border:1px solid white; z-index:2; opacity:0.9; }
        .icon-bottom-exp .child { position: absolute; top:20px; left:0; width:100%; height:100%; background:#27ae60; border:1px solid white; z-index:-1; opacity: 0.9; }
        
        /* New Puzzle Icons */
        .icon-p-top .child { position: absolute; top:-38px; left:0; width:100%; height:100%; background:#e74c3c; border:1px solid white; z-index:2; }
        .icon-p-bottom .child { position: absolute; top:38px; left:0; width:100%; height:100%; background:#e74c3c; border:1px solid white; z-index:2; }
        .icon-p-left .child { position: absolute; top:0; left:-28px; width:100%; height:100%; background:#e74c3c; border:1px solid white; z-index:2; }
        .icon-p-right .child { position: absolute; top:0; left:28px; width:100%; height:100%; background:#e74c3c; border:1px solid white; z-index:2; }

        .rotated-view #main-board { transform: rotate(180deg); }

		/* --- 修改部分：將位置選擇器改為網格佈局 (仿照 UI A) --- */
        #position-list {
            flex: 1; 
            overflow-y: auto; 
            display: flex; 
            flex-wrap: wrap; /* 允許換行 */
            gap: 8px;        /* 間距 */
            padding: 15px; 
            background: #eee; 
            border-radius: 4px; 
            min-height: 0;
            align-content: flex-start;
            justify-content: flex-start; /* 靠左對齊，符合閱讀順序 */
        }

        /* 插槽樣式：看起來像一張虛線卡片 */
        .position-slot {
            width: var(--card-width); 
            height: var(--card-height);
            background: rgba(255, 255, 255, 0.5); 
            border: 2px dashed #999;
            border-radius: 4px;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-size: 0.7rem;
            color: #555;
            cursor: pointer;
            transition: all 0.2s;
            flex-shrink: 0;
            position: relative;
        }
        
        .position-slot:hover { 
            background: #dff9fb; 
            border-color: #2980b9; 
            color: #2980b9; 
            font-weight: bold;
            transform: scale(1.05);
            z-index: 10;
        }
        
        /* 參考卡樣式：顯示在插槽中間，僅供參考，不可點擊 */
        .position-card-ref {
            width: var(--card-width); 
            height: var(--card-height);
            border: 1px solid #ccc;
            border-radius: 3px;
            background-color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.6rem;
            color: #aaa;
            opacity: 0.7; /* 稍微淡化，區分可點擊區域 */
            pointer-events: none; /* 禁止點擊 */
            flex-shrink: 0;
            background-size: cover;
            background-position: center;
            box-shadow: 1px 1px 2px rgba(0,0,0,0.1);
            overflow: hidden;
            text-align: center;
            padding: 2px;
        }
        
        /* 為了讓視覺動線更清楚，我們可以加一個小箭頭或線條 (選擇性) */
        .position-card-ref::after {
            content: "▶";
            position: absolute;
            right: -12px;
            top: 50%;
            transform: translateY(-50%);
            color: #ccc;
            font-size: 8px;
            display: none; /* 暫時隱藏，避免太亂 */
        }
		
		/* --- [新增] 爪痕特效樣式 --- */
		.claw-overlay {
			position: absolute;
			top: 0; left: 0; width: 100%; height: 100%;
			pointer-events: none; /* 讓滑鼠可以穿透點擊卡片 */
			z-index: 50;
			display: flex;
			justify-content: center;
			align-items: center;
			opacity: 0.9;
		}

		.claw-svg {
			width: 130%;  /* 原本是 80%，改成 130% 讓它超出卡片邊界 */
			height: 130%; /* 原本是 80%，改成 130% */
			overflow: visible;
		}

		.claw-path {
			fill: none;
			stroke: #c0392b; /* 血紅色 */
			stroke-width: 8;
			stroke-linecap: round;
			filter: drop-shadow(1px 1px 2px rgba(0,0,0,0.5));
		}

		/* 播放時的動畫 Class */
		.claw-anim .claw-path {
			stroke-dasharray: 100;
			stroke-dashoffset: 100;
			animation: scratch-anim 0.3s cubic-bezier(0.25, 1, 0.5, 1) forwards;
		}

		/* 讓三條爪痕有時間差，看起來更像抓擊 */
		.claw-anim .p1 { animation-delay: 0s; }
		.claw-anim .p2 { animation-delay: 0.1s; }
		.claw-anim .p3 { animation-delay: 0.05s; }

		@keyframes scratch-anim {
			to { stroke-dashoffset: 0; }
		}
		
		/* 手機版勝利畫面修正 */
		body.mobile-mode #win-overlay .win-text {
			font-size: 3rem; /* 原本是 5rem，手機版改小一點 */
		}

		body.mobile-mode #win-overlay .win-sub {
			font-size: 1.2rem; /* 原本是 2rem，稍微縮小 */
			margin-top: 5px;
		}

		/* --- [新增] 勝利慶祝動畫 --- */
        #win-overlay {
            position: fixed; 
			top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
			z-index: 2000;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.4);
            overflow: hidden;
        }

        .win-text {
            font-size: 5rem;
            font-weight: 900;
            text-transform: uppercase;
            color: #f1c40f;
            text-shadow: 0 0 20px rgba(0,0,0,0.8), 3px 3px 0 #c0392b;
            transform: scale(0);
            animation: win-pop 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }

        .win-sub {
            font-size: 2rem;
            color: white;
            margin-top: 10px;
            opacity: 0;
            animation: slideUp 0.5s ease 0.5s forwards;
            text-shadow: 0 0 5px black;
        }
        
        /* 簡單的彩帶特效 (使用偽元素模擬) */
        .confetti {
            position: absolute;
            width: 10px; height: 10px;
            background-color: #f00;
            animation: confetti-fall 3s linear infinite;
        }

        @keyframes win-pop {
            0% { transform: scale(0) rotate(-15deg); opacity: 0; }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }
        
        @keyframes confetti-fall {
            0% { transform: translateY(-100px) rotate(0deg); opacity: 1; }
            100% { transform: translateY(800px) rotate(720deg); opacity: 0; }
        }
		
		/* 語言選單樣式 */
		#lang-select {
			background: #34495e;
			color: white;
			border: 1px solid #566573;
			padding: 4px 8px;
			border-radius: 4px;
			margin-right: 10px;
			font-size: 0.85rem;
			cursor: pointer;
			outline: none;
		}
		#lang-select:hover {
			background: #4e6479;
		}

		/* 隱藏不需要的編輯工具，但保留 Timeline */
		body.mobile-mode #toolbar, 
		body.mobile-mode #draft-bar, 
		body.mobile-mode #point-bar, 
		body.mobile-mode #card-action-panel, 
		body.mobile-mode #setup-modal,
		body.mobile-mode .turn-bar {
			display: none !important;
		}

		/* 1. 虛擬畫布設定 - 加大寬度以容納右側 Sidebar */
		body.mobile-mode #workspace {
			width: 1600px !important; /* 加大：1200 -> 1600 */
			height: 800px !important;
			
			position: absolute;
			top: 0; left: 0;
			transform-origin: 0 0; 
			
			display: flex !important;
			flex-direction: row;
			background: #95a5a6;
			box-shadow: 0 0 50px rgba(0,0,0,0.5);
			
			/* [新增] 讓整個工作區無法點擊/拖曳 */
			pointer-events: none !important;
		}

		/* 2. SVG 設為穿透，避免擋到任何東西 */
		body.mobile-mode #svg-layer {
			pointer-events: none !important; 
			z-index: 500; 
		}

		/* 3. 左側能力區：維持顯示 */
		body.mobile-mode #ability-stack-zone {
			display: flex !important;
			width: 100px !important;
			flex-shrink: 0;
			height: 100%;
			border-right: 2px solid #7f8c8d;
			z-index: 600;
		}

		/* 4. 中間戰場：【關鍵】這裡設為 none，達成「透明擋板」效果 */
		body.mobile-mode #game-board-container {
			flex: 1;
			height: 100%;
			display: flex;
			justify-content: center;
			align-items: center;
			overflow: hidden;
			
			/* 這裡禁止互動！ */
			pointer-events: none !important; 
		}

		/* --- 移動控制面板位置 (靠右下角修正版) --- */
		/* --- 移動控制面板位置 --- */
		#mobile-controls {
			display: none; /* 由 JS 控制顯示 */
			align-items: center;
			justify-content: flex-end;
			gap: 8px; /* [修改] 間距稍微縮小 */
			
			position: fixed;
			bottom: calc(15px + env(safe-area-inset-bottom)); 
			right: calc(15px + env(safe-area-inset-right));
			
			z-index: 5000;
			flex-shrink: 0;
			opacity: 0.95;
		}

		/* 隱藏原本的停止按鈕 (如果 CSS 還有殘留) */
		#mob-stop-btn { display: none !important; }

		/* 音樂按鈕樣式：靜音時顯示紅色，播放時顯示綠色或白色 */
		#mob-music-btn.active {
			border-color: #2ecc71;
			color: #2ecc71;
			box-shadow: 0 0 5px #2ecc71;
		}

		/* 確保手機模式下 body 不會產生滾動條，避免 fixed 元素跑位 */
		body.mobile-mode {
			overflow: hidden;
			position: fixed; /* 鎖定 body */
			width: 100%;
			height: 100%;
			/* ... 其他樣式保持不變 ... */
		}

		/* --- 移動版速度選單 (縮小版) --- */
		#mob-speed-select {
			height: 36px; /* [修改] 高度縮小以配合按鈕 */
			border-radius: 18px;
			border: 2px solid white;
			background: rgba(44, 62, 80, 0.9);
			color: white;
			font-size: 0.85rem; /* [修改] 字體縮小 */
			padding: 0 10px;
			outline: none;
			box-shadow: 0 2px 5px rgba(0,0,0,0.3);
			text-align: center;
		}

		/* 手機版播放按鈕 (如果你還要保留這個浮動按鈕的話) */
		body.mobile-mode #mobile-controls {
			display: flex;
			z-index: 2000;
		}

		#orientation-overlay {
			display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
			background: #2c3e50; color: white; z-index: 10000;
			flex-direction: column; justify-content: center; align-items: center; text-align: center;
		}
		#orientation-overlay .icon { font-size: 50px; margin-bottom: 20px; animation: rotate 2s infinite; }
		@keyframes rotate { 0% {transform: rotate(0deg);} 50% {transform: rotate(-90deg);} 100% {transform: rotate(0deg);} }

        @keyframes slideUp { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
		
		/* --- 垂直進度條樣式 (修正版) --- */
		#playback-slider-container {
			position: fixed;
			/* [修改點 2] 桌機版位置調整 */
			/* Timeline 寬度是 320px，我們設定 325px 讓它剛好在列表左側邊緣 */
			right: 0px; 
			
			top: 50%;
			transform: translateY(-50%);
			
			/* [修改點 1] 長度調整：容器高度設為 95% 視窗高度 */
			height: 95vh; 
			
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			z-index: 3001; /* 確保在阻擋層之上 */
			gap: 10px;
			pointer-events: none; /* 容器本身不擋滑鼠，讓內部元件擋就好 */
		}

		/* 讓內部元件可以被點擊 */
		#playback-slider-container > * {
			pointer-events: auto;
		}

		/* --- 新版進度條區域樣式 (Slider Zone) --- */
		#slider-zone {
			/* 桌機版佈局設定 */
			width: 30px; /* 固定寬度，形成一個窄條 */
			background: #2c3e50; /* 深色背景，區隔展示區與列表 */
			border-left: 1px solid #34495e;
			border-right: 1px solid #bdc3c7;
			
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			
			position: relative;
			z-index: 20; /* 確保在普通層級之上 */
			flex-shrink: 0; /* 禁止被壓縮 */
		}

		#slider-tooltip {
			position: absolute;
			/* 讓提示文字轉正，並顯示在滑桿上方或旁邊 */
			top: 20px;
			background: rgba(241, 196, 15, 0.9);
			color: #000;
			padding: 2px 6px;
			border-radius: 4px;
			font-size: 0.7rem;
			font-weight: bold;
			pointer-events: none;
			z-index: 25;
			white-space: nowrap;
		}

		#playback-slider {
			-webkit-appearance: none;
			appearance: none;
			
			/* 長度設定：
			   因為旋轉了 90度，這裡的 width 控制的是螢幕上的「垂直高度」。
			*/
			width: 90vh; 
			
			height: 6px; /* 軌道寬度 */
			background: rgba(255, 255, 255, 0.2);
			border-radius: 3px;
			outline: none;
			
			/* [關鍵修改] 
			   改成 90deg (順時針旋轉)。
			   原本的 range 是「左小右大」。
			   轉 90 度後變成了「上小下大」，符合你要的 Top=0%, Bottom=100%。
			*/
			transform: rotate(90deg); 
			
			cursor: pointer;
		}

		#playback-slider::-webkit-slider-thumb {
			-webkit-appearance: none;
			appearance: none;
			width: 16px;
			height: 16px;
			border-radius: 50%;
			background: #f1c40f;
			cursor: pointer;
			border: 2px solid #fff;
			box-shadow: 0 1px 3px rgba(0,0,0,0.5);
			transition: transform 0.1s;
		}

		#playback-slider::-webkit-slider-thumb:hover {
			transform: scale(1.4);
		}

		/* --- 手機版模式修正 (Mobile Mode Fixes) --- */

		/* 1. 隱藏原本的時間軸 (Action Log) */
		body.mobile-mode #timeline-panel {
			display: none !important;
		}

		/* 2. 顯示並重設 Slider Zone 的排版 */
		/* 讓它像 Timeline 一樣，乖乖待在 Workspace 裡面的右側 */
		body.mobile-mode #slider-zone {
			display: flex !important;
			position: relative !important; /* 關鍵：參與 Flex 排版 */
			
			/* 清除原本 fixed 的定位屬性 */
			top: auto !important;
			right: auto !important;
			transform: none !important;
			
			/* 設定在虛擬畫布中的尺寸 */
			width: 60px !important;  
			height: 100% !important; 
			
			/* 確保層級與互動 */
			z-index: 3000 !important;
			background: rgba(44, 62, 80, 0.6); /* 半透明深色背景，更有質感 */
			border-left: 1px solid rgba(255,255,255,0.2);
			flex-shrink: 0; 
			
			/* 【關鍵】因為父層 workspace 是 pointer-events: none，這裡必須開啟 auto 才能拖拉 */
			pointer-events: auto !important;
		}

		/* 3. 調整滑桿 (Input Range) 的尺寸 */
		/* 因為畫布高度是 800px，我們設定 700px 讓它夠長 */
		body.mobile-mode #playback-slider {
			width: 700px !important; /* 足夠長度 */
			height: 40px !important; /* 加高觸控區 */
			transform: rotate(90deg);
			background: rgba(255, 255, 255, 0.2);
			border-radius: 20px;
			cursor: pointer;
		}

		/* 加大手機版滑塊按鈕 (Thumb) */
		body.mobile-mode #playback-slider::-webkit-slider-thumb {
			width: 36px !important;
			height: 36px !important;
			background: #f1c40f;
			box-shadow: 0 2px 5px rgba(0,0,0,0.5);
			border: 3px solid #fff;
		}

		/* 修正提示文字的位置 (轉正) */
		body.mobile-mode #slider-tooltip {
			transform: rotate(0deg); 
			top: 30px;
			right: auto;
			font-size: 1.5rem; /* 字體加大，方便手機閱讀 */
			font-weight: 800;
			text-shadow: 0 2px 4px rgba(0,0,0,0.5);
		}

		/* 確保進度條與手機按鈕永遠在阻擋層之上 */
		#playback-slider-container, #mobile-controls {
			z-index: 3001 !important;
		}
		
		/* --- 調整側邊堆疊區的文字高度，避免英文版重疊 --- */

		/* 超次元 (Hyper): 設為 25% */
		.hyper-zone .zone-label {
			top: 25% !important; /* 使用 !important 確保覆蓋預設值 */
		}

		/* 墓地 (Grave): 設為 50% (維持中間) */
		.grave-zone .zone-label {
			top: 50% !important;
		}

		/* 牌庫 (Deck): 設為 75% */
		.deck-zone .zone-label {
			top: 75% !important;
		}
		
		/* --- 手機版專用：戰鬥區卡片放大 1.5 倍 (修正版) --- */
		body.mobile-mode .battle-zone .card-group {
			/* 1. 改用 transform: scale，這是標準屬性，getBoundingClientRect 能完美支援 */
			transform: scale(1.5);
			
			/* 2. 設定縮放原點為「中心」，確保放大後位置不會亂跑 */
			transform-origin: center center;
			
			/* 3. 【關鍵】因為 transform 只是視覺放大，不會「撐開」原本的空間 */
			/* 所以必須手動增加 margin (外距)，否則放大後的卡片會互相重疊 */
			/* 寬度 50px * 1.5 = 75px (差 25px)，左右各補約 12px */
			margin: 25px 15px !important; 
			
			/* 確保放大後的層級正確 */
			z-index: 10;
		}
		
		/* --- 修正：強制在手機版顯示回合呼吸燈 --- */
		body.mobile-mode .turn-bar {
			display: block !important; /* 原本被設為 none，這裡強制顯示 */
			
			/* 手機螢幕較小，建議稍微加寬一點，視覺上會更明顯 */
			width: 20px !important; 
			
			/* 確保它的層級夠高，不會被放大的卡片蓋住 */
			z-index: 50 !important; 
		}

		/* 選擇性調整：如果你覺得手機版呼吸燈太亮或太暗，可以調整這裡 */
		body.mobile-mode #player1-area.active-turn .turn-bar {
			box-shadow: 0 0 25px 5px rgba(52, 152, 219, 0.9);
		}
		body.mobile-mode #player2-area.active-turn .turn-bar {
			box-shadow: 0 0 25px 5px rgba(233, 30, 99, 0.9);
		}
		/* --- [新增] 低調訪客計數器 --- */
        #visitor-counter {
            position: fixed;
            z-index: 100; /* 層級適中，不擋重要元素 */
            font-family: sans-serif;
            font-size: 10px; /* 字體極小 */
            pointer-events: none; /* 滑鼠穿透 */
            opacity: 0.5; /* 半透明，很不明顯 */
            
            /* 預設先隱藏，等腳本載入成功後會自動透過 JS 顯示(由不蒜子控制)，
               或者我們可以強制 block，但不蒜子會控制內部 span 的 display */
            display: block !important; 
        }

        /* 桌機版：左下角，深灰色 */
        body:not(.mobile-mode) #visitor-counter {
            bottom: 5px;
            left: 5px;
            color: rgba(0, 0, 0, 0.3);
        }

        /* 手機版：左下角，淺白色 (因為手機版背景較深) */
        body.mobile-mode #visitor-counter {
            bottom: 5px;
            left: 5px;
            color: rgba(255, 255, 255, 0.3);
            /* 手機版稍微離開邊緣一點，避免被圓角切到 */
            transform: translate(5px, -5px); 
        }
		
		/* --- SRW Dialogue System Styles --- */
        #dialogue-layer {
            position: absolute; 
            top: 0; 
            
            /* --- 修改開始：避開左右面板 --- */
            left: 100px;   /* 避開左側 Ability Zone (100px) */
            right: 380px;  /* 避開右側 Timeline (320px) + Slider (30px) + 5px間距 */
            width: auto;   /* 刪除原本的 width: 100% */
            /* --- 修改結束 --- */

            height: 100%;
            pointer-events: none; 
            z-index: 2000;
            display: none; 
            flex-direction: column; 
            justify-content: space-between;
            overflow: hidden; 
            padding: 20px 0;
        }
        #dialogue-layer.active { display: flex; }

		/* 額外修正：確保手機版 (Mobile Mode) 因為右側面板隱藏，對話框要延伸回去 */
        body.mobile-mode #dialogue-layer {
            right: 70 !important;
            /* 左側 Ability Zone 在手機版依然存在，所以 left: 100px 保持不變 */
        }
		
        /* 上下對話區塊容器 */
        .diag-row {
            display: flex; width: 100%; height: 180px; align-items: flex-end; position: relative;
            opacity: 0; transition: opacity 0.2s; pointer-events: none; /* 預設隱藏 */
        }
        .diag-row.visible { opacity: 1; pointer-events: auto; }

        /* 頂部 (P2/敵方) - 頭像在右，框在左 */
        .diag-row.top { flex-direction: row-reverse; align-items: flex-start; }
        /* 底部 (P1/我方) - 頭像在左，框在右 */
        .diag-row.bottom { flex-direction: row; }

        /* 立繪容器 */
        .diag-portrait {
            width: 160px; height: 160px; flex-shrink: 0;
            margin: 0 10px; border-radius: 8px;
            background-size: cover; background-position: center;
            border: 2px solid rgba(255,255,255,0.5);
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            background-color: rgba(0,0,0,0.8);
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        /* 對話框本體 */
        .diag-box {
            flex: 1; height: 100%; max-width: 70%;
            background: linear-gradient(180deg, rgba(0,20,40,0.9) 0%, rgba(0,10,20,0.95) 100%);
            border: 2px solid #3498db; border-radius: 8px;
            display: flex; flex-direction: column; padding: 15px;
            position: relative; margin: 0 20px;
            box-shadow: 0 0 15px rgba(52, 152, 219, 0.2);
            backdrop-filter: blur(2px);
        }
        
        /* 顏色變體 */
        .diag-row.top .diag-box { border-color: #c0392b; box-shadow: 0 0 15px rgba(192, 57, 43, 0.2); }
        .diag-row.top .diag-portrait { border-color: #c0392b; }
        .diag-row.bottom .diag-portrait { border-color: #3498db; }

        /* 名字標籤 */
        .diag-name {
            background: #3498db; color: white; padding: 2px 10px;
            font-size: 0.9rem; font-weight: bold; display: inline-block;
            transform: skewX(-15deg); margin-bottom: 8px; align-self: flex-start;
            box-shadow: 2px 2px 0 rgba(0,0,0,0.5);
        }
        .diag-row.top .diag-name { background: #c0392b; align-self: flex-end; }

        /* 文字內容 */
        .diag-text { color: white; line-height: 1.4; white-space: pre-wrap; text-shadow: 1px 1px 2px black; flex: 1; overflow-y: auto;}
        
        /* 文字大小 */
        .text-s { font-size: 1rem; }
        .text-m { font-size: 1.5rem; }
        .text-l { font-size: 2.2rem; font-weight: bold; color: #f1c40f; }

        /* 進場特效動畫 */
        .fx-fade { animation: fadeIn 0.5s ease forwards; }
        .fx-slide { animation: slideInX 0.4s cubic-bezier(0.2, 0.8, 0.2, 1) forwards; }
        .fx-direct { /* No animation */ }

        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        /* 左側滑入 */
        .diag-row.bottom .fx-slide { animation-name: slideInLeft; }
        @keyframes slideInLeft { from { transform: translateX(-50px); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        /* 右側滑入 */
        .diag-row.top .fx-slide { animation-name: slideInRight; }
        @keyframes slideInRight { from { transform: translateX(50px); opacity: 0; } to { transform: translateX(0); opacity: 1; } }

        /* 編輯器樣式 */
        .emotion-grid { display: grid; grid-template-columns: repeat(6, 1fr); gap: 5px; margin-top: 5px; }
        .emotion-opt { 
            width: 100%; aspect-ratio: 1; border: 2px solid #555; cursor: pointer; 
            background-size: cover; border-radius: 4px; opacity: 0.6;
        }
        .emotion-opt:hover { opacity: 1; }
        .emotion-opt.active { border-color: #f1c40f; opacity: 1; box-shadow: 0 0 5px #f1c40f; }
        
        .diag-editor-row { display: flex; gap: 10px; margin-bottom: 15px; border: 1px solid #ddd; padding: 10px; border-radius: 4px; background: #fdfdfd; }
        .diag-editor-col { flex: 1; display: flex; flex-direction: column; gap: 5px; }
        .diag-section-title { font-weight: bold; margin-bottom: 5px; border-bottom: 2px solid #eee; padding-bottom: 2px; }
		
		/* --- 新增：編輯中的佔位符樣式 --- */
        .action-item.placeholder {
            border: 2px dashed #f1c40f;
            background: rgba(241, 196, 15, 0.1);
            color: #7f8c8d;
            text-align: center;
            padding: 15px 10px;
            font-style: italic;
            font-weight: bold;
            animation: pulse-placeholder 1.5s infinite;
            cursor: default;
        }

        @keyframes pulse-placeholder {
            0% { background: rgba(241, 196, 15, 0.05); }
            50% { background: rgba(241, 196, 15, 0.15); }
            100% { background: rgba(241, 196, 15, 0.05); }
        }

        /* --- 新增：鎖定列表滾動 --- */
        #action-list.locked {
            overflow-y: hidden !important; /* 強制鎖住滾動 */
            padding-right: 0; /* 避免滾動條消失造成的輕微跳動(視瀏覽器而定) */
        }
		
		/* --- 灰階化按鈕樣式 --- */
        button.disabled-gray {
            filter: grayscale(100%);
            opacity: 0.5;
            pointer-events: none;
            cursor: not-allowed;
        }

        /* --- 修正 Modal 內按鈕間距 --- */
        .diag-editor-col button { margin-top: 5px; }
		
		/* --- 持續效果卡片樣式 --- */
		.card.ability-card.continuous {
			border: 3px double #8e44ad !important; /* 紫色雙線框 */
			background: #f4ecf7; /* 淡紫色背景 */
			box-shadow: 0 0 5px rgba(142, 68, 173, 0.4);
		}

		/* 在卡片右上角加上 ∞ 符號 */
		.card.ability-card.continuous::after {
			content: "∞";
			position: absolute;
			top: -8px;
			right: -4px;
			color: #fff;
			background: #8e44ad;
			width: 18px;
			height: 18px;
			border-radius: 50%;
			font-size: 14px;
			font-weight: bold;
			display: flex;
			justify-content: center;
			align-items: center;
			z-index: 10;
			box-shadow: 1px 1px 2px rgba(0,0,0,0.3);
			line-height: 1;
		}
		
		/* --- [新增] 王牌系統樣式 --- */
		/* 1. 王牌星星 (右上角) - [修改] 黑框白肉版 */
		.ace-star-mark {
			position: absolute;
			top: -6px; right: -2px; /* 稍微往外推一點，避免擋住卡圖太多 */
			font-size: 16px; /* 稍微加大 */
			
			/* [核心修改] 黑框白肉 */
			color: white; 
			-webkit-text-stroke: 1.5px black; /* 這是文字描邊最有效的方法 */
			/* 為了相容性，加一點陰影讓它在淺色背景也能看清 */
			text-shadow: 2px 2px 0px rgba(0,0,0,0.3);
			
			cursor: pointer;
			z-index: 50;
			transition: transform 0.2s;
			
			/* 移除原本的 filter: drop-shadow(0 0 2px gold); */
		}
		
		.ace-star-mark:hover { 
			transform: scale(1.4); 
			color: #e74c3c; /* Hover 時變紅，提示可點擊 */
			-webkit-text-stroke: 1px #c0392b;
		}
		
		/* [新增] 播放模式或手機模式時，隱藏王牌星星 */
		body.is-playing .ace-star-mark,
		body.mobile-mode .ace-star-mark {
			display: none !important;
		}

		/* 2. 長按集氣邊框 (SVG) - [修改] 光束質感版 */
		.ace-loader-svg {
			position: absolute;
			top: 0; left: 0;
			width: 100%; height: 100%;
			pointer-events: none;
			z-index: 40;
			display: none; 
			
			/* [關鍵] 允許光暈超出 SVG 邊界，否則光會被切掉 */
			overflow: visible; 
		}

		.ace-loader-rect {
			fill: none;
			
			/* [核心修改 1] 線條本體改為白色 (模擬光的中心) */
			stroke: #fff; 
			
			/* [核心修改 2] 線條改細一點，把視覺留給光暈 */
			stroke-width: 3; 
			
			/* [核心修改 3] 利用多層陰影製造強烈的金色光暈效果 (Neon Glow) */
			/* 第一層(2px)是高光，第二層(8px)是擴散光 */
			filter: drop-shadow(0 0 2px #f1c40f) drop-shadow(0 0 8px gold);
			
			stroke-dasharray: 240; 
			stroke-dashoffset: 240; 
			stroke-linecap: round; /* 讓光束頭尾圓潤 */
		}
		/* 觸發集氣動畫：0.7秒內跑完 */
		.charging .ace-loader-svg { display: block; }
		.charging .ace-loader-rect {
			animation: ace-fill 0.7s linear forwards;
		}
		@keyframes ace-fill {
			to { stroke-dashoffset: 0; }
		}

		/* --- [精簡版] 王牌特效 (移除 Zoom In，僅保留金光與閃光) --- */
        
        .anim-flash-white {
            display: block !important;
            /* 0.5秒的閃光：快閃 -> 全白 -> 慢退 */
            animation: flash-white 0.5s ease-out forwards;
        }

        @keyframes flash-white {
            0% { opacity: 0; }
            50% { opacity: 1; } /* 瞬間全白 */
            100% { opacity: 0; }
        }
		
		/* --- [獨立光圈版] 王牌特效 --- */
        
        /* 1. 全螢幕閃光遮罩 (維持不變) */
        #ace-flash-layer {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: white;
            z-index: 9999;
            opacity: 0;
            pointer-events: none;
            display: none;
        }
        
		/* 2. 外掛發光圈 (獨立於卡片之外) - 絕對尺寸版 */
        .ace-external-ring {
			position: fixed !important;
			z-index: 4000 !important;
			pointer-events: none;
			background: transparent;
			border-radius: 4px;
			box-sizing: border-box; 

			/* 讀取 JS 算好的絕對座標與尺寸 */
			top: var(--y);
			left: var(--x);
			width: var(--w);
			height: var(--h);
			
			/* [新增] 預設顏色 (金色)，如果 JS 沒傳入會用這個 */
			--ace-color: 255, 215, 0; 

			/* 動畫設定 */
			animation: ace-ring-power-up 0.7s linear forwards;
		}

        .ace-external-ring.power-down {
			animation: ace-ring-power-down 0.7s linear forwards;
		}

		/* [修改] 將原本寫死的 rgba 數值改為 var(--ace-color) */
		@keyframes ace-ring-power-up {
			0% {
				box-shadow: 0 0 0 0 rgba(var(--ace-color), 0);
				transform: translate(-50%, -50%) rotate(var(--rot)) scale(1);
			}
			30% {
				box-shadow: 0 0 15px 5px rgba(var(--ace-color), 0.4);
				transform: translate(-50%, -50%) rotate(var(--rot)) scale(1);
			}
			60% {
				box-shadow: 0 0 35px 15px rgba(var(--ace-color), 0.7);
				transform: translate(-50%, -50%) rotate(var(--rot)) scale(1);
			}
			100% {
				box-shadow: 0 0 80px 40px rgba(var(--ace-color), 1);
				transform: translate(-50%, -50%) rotate(var(--rot)) scale(1.05);
			}
		}

		@keyframes ace-ring-power-down {
			0% {
				box-shadow: 0 0 80px 40px rgba(var(--ace-color), 1);
				transform: rotate(var(--rot)) scale(1.05);
			}
			40% {
				box-shadow: 0 0 35px 15px rgba(var(--ace-color), 0.7);
			}
			70% {
				box-shadow: 0 0 15px 5px rgba(var(--ace-color), 0.4);
			}
			100% {
				box-shadow: 0 0 0 0 rgba(var(--ace-color), 0);
				transform: rotate(var(--rot)) scale(1);
			}
		}
		
		/* --- [新增] 多重選取模式樣式 --- */
        
        /* 選取時的大紅勾 */
        .card .check-mark {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 40px;
            color: #e74c3c;
            font-weight: 900;
            text-shadow: 2px 2px 0px white, -2px -2px 0px white, 2px -2px 0px white, -2px 2px 0px white;
            z-index: 200; /* 確保蓋在文字和圖片上 */
            pointer-events: none;
            display: none;
        }
        
        /* 顯示紅勾 */
        .card.multi-selected .check-mark {
            display: block;
        }
        
        /* 選取時的邊框 */
        .card.multi-selected {
            border: 3px solid #e74c3c !important;
            box-shadow: 0 0 10px rgba(231, 76, 60, 0.5);
        }

        /* 按鈕啟動狀態 */
        #btn-multi-move.active {
            background: #e74c3c !important;
            border-color: #c0392b !important;
            animation: pulse-red 2s infinite;
        }

        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 0 rgba(231, 76, 60, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(231, 76, 60, 0); }
            100% { box-shadow: 0 0 0 0 rgba(231, 76, 60, 0); }
        }
		
		/* [新增] 王牌按鈕啟用狀態 (亮金色) */
		#btn-ace.active {
			background: #f1c40f !important;
			border-color: #f39c12 !important;
			color: #2c3e50 !important;
			font-weight: bold;
			box-shadow: 0 0 10px rgba(241, 196, 15, 0.5);
		}

		/* [新增] 移除原本的集氣動畫與 SVG 樣式 (因為長按改成多選了) */
		.ace-loader-svg, .charging .ace-loader-rect {
			display: none !important;
		}

		/* 確保星星還是看得到，但滑鼠游標改回預設 (因為不能點了) */
		.ace-star-mark {
			cursor: default !important;
			pointer-events: none !important; /* 讓點擊穿透星星選到卡片 */
		}
		
		/* [新增] BGM 列表樣式 */
        .bgm-item {
            padding: 10px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: background 0.2s;
        }
        .bgm-item:hover { background: #f9f9f9; }
        .bgm-item.selected { background: #e8f6fd; color: #2980b9; font-weight: bold; }
        .bgm-item.playing-preview::after {
            content: "🔊";
            margin-left: auto;
        }
		/* [新增] 手機版隱藏 BGM 按鈕 (強制隱藏) */
        body.mobile-mode #btn-bgm {
            display: none !important;
        }

        /* [新增] 手機版按鈕通用樣式 (確保 Stop 跟 Play 長得像) */
        .mobile-btn {
			width: 36px;  /* [修改] 縮小尺寸 */
			height: 36px; /* [修改] 縮小尺寸 */
			border-radius: 50%;
			border: 2px solid white;
			background: rgba(44, 62, 80, 0.9);
			color: white;
			font-size: 0.9rem; /* [修改] 字體縮小 */
			cursor: pointer;
			box-shadow: 0 2px 5px rgba(0,0,0,0.3);
			display: flex; justify-content: center; align-items: center;
			padding: 0;
			flex-shrink: 0;
		}
        .mobile-btn:active { transform: scale(0.95); }
		
		/* [新增] Play 按鈕發光引導動畫 (Pulse Effect) */
        @keyframes play-btn-pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(241, 196, 15, 0.7);
                transform: scale(1);
            }
            50% {
                transform: scale(1.1);
            }
            70% {
                box-shadow: 0 0 0 20px rgba(241, 196, 15, 0);
                transform: scale(1.1);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(241, 196, 15, 0);
                transform: scale(1);
            }
        }

        /* 套用在按鈕上的 class */
        .btn-highlight {
            animation: play-btn-pulse 2s infinite;
            background: #f39c12 !important; /* 讓底色稍微亮一點 */
            border-color: #f1c40f !important;
            font-weight: bold;
            z-index: 3005 !important; /* 確保在最上層 */
        }
		
		body.mobile-mode #reveal-zone .card {
			transform: scale(1.5);
			transform-origin: center center;
			margin: 25px 8px !important;   /* 配合放大比例，稍微縮小左右外距 */
		}

        /* 1. 間距減半 (手牌與魔力區) */
		body.mobile-mode .mana-zone .card-group,
		body.mobile-mode .hand-zone .card-group {
			margin: 0 2px !important; /* 原本是 5px，改為 2px */
		}

		/* 2. 展示區調整 (放大 1.5倍 + 間距縮小) */
		body.mobile-mode #reveal-zone {
			padding: 20px 15px !important; /* 縮小內距 */
			gap: 8px !important;           /* 縮小卡片間距 */
		}
		
		
		/* 1. 對話層修正：針對 #dialogue-layer 及其「所有子元件」強制封鎖 */
		/* 使用 * 選擇器選取底下所有東西，並用 !important 覆蓋 JS 的行內樣式 */
		body.mobile-mode #dialogue-layer,
		body.mobile-mode #dialogue-layer * {
			pointer-events: none !important;
		}
		
		/* 2. 牌庫、墓地、超次元、待處理區修正 */
		/* 這些區域的卡片也必須強制封鎖，避免 JS 綁定的 onclick 生效 */
		body.mobile-mode .deck-zone .card,
		body.mobile-mode .grave-zone .card,
		body.mobile-mode .hyper-zone .card,
		body.mobile-mode #ability-stack-zone .card {
			pointer-events: none !important;
		}

		/* 3. 確保展示區(Reveal Zone)的卡片「可以」被點擊 (放大檢視用) */
		/* 因為上面用了 * 選擇器可能會誤殺，這裡再度確保展示區是活的 */
		body.mobile-mode #reveal-zone .card {
			pointer-events: auto !important;
		}

		/* 3. 強制開啟卡片點擊 (原本是 none，為了讓點擊生效改為 auto) */
		body.mobile-mode .card {
			pointer-events: auto !important; 
		}
		/* 但底下的容器依然保持穿透，避免誤觸拖曳邏輯 */
		body.mobile-mode #game-board-container,
		body.mobile-mode .zone {
			pointer-events: none !important;
		}
		
		/* 4. [新增] 手機版右側卡片放大檢視視窗 */
		#mobile-card-viewer {
			display: none;
			position: fixed;
			top: 0; 
			left: 0; 
			width: 100%; 
			height: 100%;
			background: rgba(0, 0, 0, 0.6); /* 半透明黑底 */
			z-index: 6000; /* 確保在最上層 */
			justify-content: flex-end; /* 靠右對齊 */
			align-items: center;
			padding-right: 50px; /* 右側留一點邊距 */
			backdrop-filter: blur(2px);
		}

		#mobile-card-viewer img {
			max-height: 90vh; /* 高度不超過螢幕 90% */
			max-width: 50vw;  /* 寬度不超過螢幕一半 */
			box-shadow: 0 0 20px rgba(0,0,0,0.8);
			border: 3px solid white;
			border-radius: 10px;
			animation: zoomIn 0.2s ease-out;
		}

		@keyframes zoomIn {
			from { transform: scale(0.8); opacity: 0; }
			to { transform: scale(1); opacity: 1; }
		}
		
		/* --- [優化版] 王牌特效樣式 --- */

		/* 1. 動畫期間強制解除卡牌的邊界限制，讓光能透出來 */
		.card.animating-ace {
			overflow: visible !important;   /* 關鍵！讓光暈不會被切掉 */
			z-index: 3000 !important;       /* 確保壓在所有卡片之上 */
			will-change: transform;         /* 優化渲染效能 */
		}

		/* 2. 內部光暈層 (取代原本的 External Ring) */
		.ace-internal-glow {
			position: absolute;
			top: 0; 
			left: 0; 
			width: 100%; 
			height: 100%;
			pointer-events: none;
			border-radius: 4px;
			
			/* 預設從中心開始 */
			transform-origin: center center;
			
			/* 動畫設定 */
			animation: ace-pop-sequence 0.8s cubic-bezier(0.22, 1, 0.36, 1) forwards;
		}

		/* 3. 動畫序列：擴大發光 -> 轉白閃光 -> 消退 */
		@keyframes ace-pop-sequence {
			0% {
				transform: scale(1);
				box-shadow: 0 0 0 0 rgba(var(--ace-color), 0);
				background: rgba(var(--ace-color), 0);
				opacity: 0.5;
			}
			40% {
				/* 階段一：光暈迅速擴大，顏色飽和 */
				transform: scale(1.4);
				box-shadow: 0 0 30px 10px rgba(var(--ace-color), 0.8);
				background: rgba(var(--ace-color), 0.3);
				opacity: 1;
			}
			60% {
				/* 階段二：變成強烈白光 (Flash) */
				transform: scale(1.5);
				box-shadow: 0 0 60px 20px rgba(255, 255, 255, 1); /* 強制白光 */
				background: rgba(255, 255, 255, 0.6);
				opacity: 1;
				border: 2px solid white;
			}
			100% {
				/* 階段三：消退 */
				transform: scale(1.6);
				box-shadow: 0 0 80px 40px rgba(var(--ace-color), 0);
				background: rgba(var(--ace-color), 0);
				opacity: 0;
				border: 0px solid white;
			}
		}
		/* --- Ending Effect: CRT Switch Off --- */

		/* --- [新增] Ending 特效：CRT 電視關機 --- */

		/* 1. 黑色遮罩 (FIN 畫面) */
		#ending-overlay {
			position: fixed;
			top: 0; left: 0; width: 100vw; height: 100vh;
			background: black;
			z-index: 9999;
			display: none;
			flex-direction: column;
			justify-content: center;
			align-items: center;
			opacity: 0;
			transition: opacity 1.5s ease-in; /* 文字慢慢浮現 */
			pointer-events: none; /* 避免遮擋點擊 (直到完全顯示) */
		}

		/* 2. 結束文字樣式 */
		.end-title {
			color: white;
			font-size: 3rem;
			font-weight: 900;
			letter-spacing: 5px;
			margin-bottom: 20px;
			text-shadow: 0 0 10px rgba(255,255,255,0.8);
			font-family: 'Courier New', Courier, monospace; /* 復古字體感 */
		}
		.end-sub {
			color: #7f8c8d;
			font-size: 1.2rem;
			font-family: sans-serif;
			letter-spacing: 2px;
		}

		/* 3. 關機動畫 Keyframes */
		@keyframes crt-shutdown {
			0% { transform: scale(1, 1); filter: brightness(1); }
			40% { transform: scale(1, 0.005); filter: brightness(5); } /* 擠壓成亮線 */
			50% { transform: scale(1, 0.005); }
			100% { transform: scale(0, 0.005); filter: brightness(0); } /* 縮成點並消失 */
		}

		/* 4. 觸發動畫的 Class */
		body.shutdown-mode #workspace,
		body.shutdown-mode #toolbar, 
		body.shutdown-mode #card-action-panel,
		body.shutdown-mode #timeline-panel {
			animation: crt-shutdown 0.5s cubic-bezier(0.23, 1, 0.32, 1) forwards;
		}

		/* [修正] 手機版關機特效強制置中 */
		/* 原本手機版是以左上角為原點，這裡強制改成中心點並重新定位 */
		body.mobile-mode.shutdown-mode #workspace {
			top: 50% !important;
			left: 50% !important;
			transform-origin: center center !important;
			
			/* 因為畫布固定為 1600x800，回推一半的寬高來置中 */
			margin-left: -800px !important;
			margin-top: -400px !important;
		}
		
		/* --- [新增] Ending Credit 樣式 --- */
		.end-credits {
			margin-top: 50px;
			display: flex;
			flex-direction: column;
			gap: 20px;
			text-align: center;
			
			/* 讓名單比標題晚一點浮現 */
			opacity: 0;
			animation: slideUp 1.5s ease 2s forwards; 
		}

		.credit-group {
			display: flex;
			flex-direction: column;
			gap: 2px;
		}

		.credit-role {
			color: #7f8c8d; /* 灰色職稱 */
			font-size: 0.75rem;
			text-transform: uppercase;
			letter-spacing: 2px;
			font-family: sans-serif;
		}

		.credit-name {
			color: #ecf0f1; /* 亮白色名字 */
			font-size: 1rem;
			font-weight: bold;
			font-family: sans-serif;
			letter-spacing: 1px;
		}

		/* --- [修正] 手機版 Ending 資訊：縮小字體 + 改為橫排 --- */
		body.mobile-mode .end-title {
			font-size: 3rem !important;
			margin-bottom: 5px;
		}
		
		body.mobile-mode .end-sub {
			font-size: 1rem !important;
			letter-spacing: 1px;
		}

		body.mobile-mode .end-credits {
			margin-top: 30px !important;
			
			/* [核心修改] 改為橫向排列 */
			flex-direction: row !important; 
			flex-wrap: wrap !important;      /* 空間不夠時自動換行 */
			justify-content: center !important; /* 水平置中 */
			
			gap: 15px 25px !important;       /* 上下 15px, 左右 25px 間距 */
		}

		/* 確保每個群組內的文字保持垂直 (職稱在上，名字在下) 並置中 */
		body.mobile-mode .credit-group {
			display: flex;
			flex-direction: column;
			align-items: center;
			min-width: 120px; /* 確保每個區塊有基本寬度，排列比較整齊 */
		}

		body.mobile-mode .credit-role {
			font-size: 0.6rem !important;
			letter-spacing: 1px;
			margin-bottom: 3px;
		}

		body.mobile-mode .credit-name {
			font-size: 0.9rem !important;
		}
		
		/* --- [新增] 手機版劇本選擇器樣式 --- */
        #mobile-script-selector {
            display: none; /* 預設隱藏 */
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(10, 20, 30, 0.95); /* 深色背景 */
            z-index: 9999; /* 最上層 */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            backdrop-filter: blur(5px);
        }

        .script-list-container {
            width: 100%;
            max-width: 500px;
            max-height: 60vh;
            overflow-y: auto;
            margin: 20px 0;
            border: 1px solid #444;
            border-radius: 8px;
            background: rgba(0,0,0,0.3);
        }

        .script-item {
            padding: 15px;
            border-bottom: 1px solid #444;
            cursor: pointer;
            transition: all 0.2s;
            color: #ccc;
        }
        
        .script-item:last-child { border-bottom: none; }
        .script-item:hover { background: rgba(255,255,255,0.05); }
        
        /* 選中狀態 */
        .script-item.selected {
            background: rgba(52, 152, 219, 0.2);
            border-left: 5px solid #3498db;
            color: white;
        }

        .script-item-title {
            font-size: 1.1rem;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .script-item-desc {
            font-size: 0.85rem;
            opacity: 0.7;
            line-height: 1.4;
        }

        #btn-mobile-start {
            font-size: 1.2rem;
            padding: 12px 40px;
            background: #f1c40f;
            color: #2c3e50;
            border: none;
            border-radius: 30px;
            font-weight: 900;
            box-shadow: 0 4px 15px rgba(241, 196, 15, 0.4);
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        #btn-mobile-start:active { transform: scale(0.95); }
        #btn-mobile-start:disabled { 
            background: #7f8c8d; 
            color: #bdc3c7; 
            cursor: not-allowed; 
            box-shadow: none;
        }
		
		/* [修改] 無月之門按鈕 - 未啟動狀態 (OFF) */
        #btn-moonless {
            background: #34495e; /* 標準深藍灰 */
            border-color: #566573;
            color: #bdc3c7;      /* 文字稍微暗一點 */
            transition: all 0.2s;
        }

        /* [修改] 無月之門按鈕 - 啟動狀態 (ON) */
        #btn-moonless.active {
            background: #8e44ad !important; /* 鮮豔的紫色 */
            border-color: #9b59b6 !important; /* 亮紫色邊框 */
            color: #fff !important;           /* 純白文字 */
            
            /* 加入發光陰影，讓它看起來是亮著的 */
            box-shadow: 0 0 12px rgba(142, 68, 173, 0.8), inset 0 0 5px rgba(255,255,255,0.3);
            
            font-weight: bold;
            transform: scale(1.05); /* 稍微放大一點點 */
        }
		
		/* 猜拳結果顯示層 */
    #rps-overlay {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        pointer-events: none;
        z-index: 2500; /* 比對話框高，比 Menu 低 */
        display: none;
        justify-content: center;
        align-items: center;
        gap: 50px;
        background: rgba(0,0,0,0.3); /* 稍微暗一點突顯結果 */
        animation: fadeIn 0.3s ease;
    }

    .rps-hand {
        font-size: 5rem;
        text-shadow: 0 0 10px rgba(0,0,0,0.5);
        display: flex;
        flex-direction: column;
        align-items: center;
        color: white;
        transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }

    .rps-hand.winner {
        transform: scale(1.5);
        text-shadow: 0 0 20px gold;
        filter: drop-shadow(0 0 5px gold);
    }

    .rps-hand.loser {
        opacity: 0.5;
        transform: scale(0.8);
        filter: grayscale(1);
    }

    .rps-vs {
        font-size: 2rem;
        font-weight: 900;
        color: #f1c40f;
        font-family: impact, sans-serif;
        transform: rotate(-10deg);
    }

    .rps-tag {
        font-size: 1rem;
        background: #2c3e50;
        padding: 2px 8px;
        border-radius: 4px;
        margin-top: 10px;
        font-weight: bold;
    }
    .rps-hand.p1 .rps-tag { background: #3498db; }
    .rps-hand.p2 .rps-tag { background: #c0392b; }
    </style>
</head>
<body>

<div id="toolbar">
    <div style="font-weight: 800; font-size: 1.1rem; margin-right: 10px; color: #f1c40f;">DM Editor</div>
    
    <select id="lang-select" onchange="changeLanguage(this.value)">
        <option value="zh">中文</option>
        <option value="en">English</option>
        <option value="jp">日本語</option>
    </select>

    <button onclick="openSetupModal()" data-i18n="btn_setup">Setup / Clear</button>
	<button onclick="actionDrawCard()" style="background:#2980b9; border-color:#2471a3;" data-i18n="btn_draw">🎴 抽牌 (Draw)</button>
    <button onclick="rotateBoard()" data-i18n="btn_rotate">🔄 換人 (Switch Turn)</button>
    →
    <button onclick="resetCurrentTurnPlayer()" data-i18n="btn_reset_current">重置當前 (Untap)</button>
    <select onchange="handleWinSelect(this)" style="background:#f39c12; border-color:#d35400; color:white; padding:4px 8px; border-radius:4px; font-weight:bold; cursor:pointer; outline:none;">
        <option value="" data-i18n="opt_win_default">🏆 宣告勝利...</option>
        <option value="1" data-i18n="btn_p1_win">🏆 1P Win</option>
        <option value="2" data-i18n="btn_p2_win">🏆 2P Win</option>
    </select>
	<button onclick="actionRPS()" style="background:#e67e22; border-color:#d35400;" data-i18n="btn_rps">✊✌️🖐️ 猜拳 (RPS)</button>
    <div style="flex:1"></div>
    <div style="flex:1"></div>
	<button id="btn-add-dialogue" onclick="openDialogueModal()" style="background:#8e44ad; border-color:#8e44ad;" data-i18n="btn_dialogue">💬 對話 (Dialog)</button>
    <button id="btn-bgm" onclick="openBGMModal()" style="background:#e67e22; border-color:#d35400;">🎵 BGM</button>
	<button onclick="document.getElementById('import-input').click()" data-i18n="btn_import">匯入 (Import)</button>
    <input type="file" id="import-input" style="display:none" onchange="importData(this)">
    <button onclick="exportData()" data-i18n="btn_export">匯出 (Export)</button>
	<button onclick="openAboutModal()" style="background:#7f8c8d; border-color:#616a6b;">ℹ️ About</button>
</div>

<div id="draft-bar">
    <span>
        <span data-i18n="lbl_draft_warning">⚠️ 編輯中... (已累積 </span>
        <span id="draft-count">0</span>
        <span data-i18n="lbl_draft_ops"> 個操作)</span>
    </span>
	<span id="draft-mode-hint" style="margin-left:15px; background:rgba(255,255,255,0.2); padding:2px 8px; border-radius:4px; font-weight:normal;"></span>
    <label title="開啟此選項後，本次編輯的結果將會影響後續所有步驟的狀態">
        <input type="checkbox" id="propagate-check" checked> 
        <span data-i18n="chk_propagate">🔗 連動更新後續</span>
    </label>
    <div style="display:flex; gap:10px;">
        <button onclick="cancelDraft()" class="danger" data-i18n="btn_cancel">取消</button>
        <button onclick="saveDraft()" class="primary" data-i18n="btn_save_step">💾 儲存此步</button>
    </div>
</div>

<div id="point-bar">
    <span data-i18n="lbl_point_mode">👉 指向模式：請選擇目標 (可選擇任意卡片或區域)</span>
    <div style="display:flex; gap:10px;">
        <span id="point-target-info" style="font-size:0.8rem; align-self:center;"></span>
        <button id="btn-confirm-point" class="primary" style="display:none;" onclick="confirmPointTargets()" data-i18n="btn_confirm_point">✅ 確認指向</button>
        <button onclick="cancelPointMode()" class="danger" data-i18n="btn_cancel">取消</button>
    </div>
</div>

<div id="move-status-bar" style="display:none;">
    <span style="font-weight:bold;">
        🚀 移動模式 (已選 <span id="move-count">0</span> 張)
    </span>
    
    <label class="toggle-switch">
        <input type="checkbox" id="ace-entry-check">
        <span class="slider"></span>
        <span style="margin-left:5px; font-weight:bold; color:#f1c40f;">王牌登場 (Ace Entry)</span>
    </label>

    <button onclick="cancelSelection()" class="danger">取消 (Cancel)</button>
</div>

<div id="workspace">

	<svg id="svg-layer">
        <defs>
            <marker id="arrowhead" markerWidth="12" markerHeight="12" refX="10" refY="6" orient="auto" markerUnits="userSpaceOnUse">
                <path d="M0,0 L12,6 L0,12" fill="#e74c3c" />
            </marker>
        </defs>
    </svg>
	
    <div id="ability-stack-zone">
        <div id="ability-zone-p2" class="ability-column">
            <div class="ability-label" data-i18n="zone_ability">P2 能力 (待處理)</div>
        </div>
        <div id="ability-zone-p1" class="ability-column">
            <div class="ability-label" data-i18n="zone_ability">P1 能力 (待處理)</div>
        </div>
    </div>
	
	<div id="dialogue-layer">
        <div id="diag-row-p2" class="diag-row top">
            <div class="diag-box">
                <div class="diag-name" id="diag-name-p2">P2</div>
                <div class="diag-text text-m" id="diag-text-p2">...</div>
            </div>
            <div class="diag-portrait" id="diag-img-p2"></div>
        </div>
        <div id="diag-row-p1" class="diag-row bottom">
            <div class="diag-portrait" id="diag-img-p1"></div>
            <div class="diag-box">
                <div class="diag-name" id="diag-name-p1">P1</div>
                <div class="diag-text text-m" id="diag-text-p1">...</div>
            </div>
        </div>
    </div>

    <div id="game-board-container">
        <div id="main-board">
            
            <div id="reveal-zone" class="zone" data-zone="reveal-zone">
                <span class="zone-label">展示區 (Reveal Zone)</span>
                <button class="mini-btn danger" style="position:absolute; top:5px; right:5px;" onclick="closeRevealZone()">✕</button>
            </div>

            <div id="player2-area" class="player-area">
                <div class="turn-bar"></div>
                <div class="battle-zone zone" data-zone="p2-battle" onclick="handleZoneClick('p2-battle')"><span class="zone-label" data-i18n="zone_battle">P2 戰鬥場</span></div>
                <div class="shield-zone zone" data-zone="p2-shield" onclick="handleZoneClick('p2-shield')"><span class="zone-label" data-i18n="zone_shield">P2 護盾區</span></div>
                <div class="mana-zone zone" data-zone="p2-mana" onclick="handleZoneClick('p2-mana')"><span class="zone-label" data-i18n="zone_mana">P2 魔力區</span></div>
                <div class="bottom-row">
                    <div class="hand-zone zone" data-zone="p2-hand" onclick="handleZoneClick('p2-hand')"><span class="zone-label" data-i18n="zone_hand">P2 手牌</span></div>
                    <div class="side-zone-group">
                        <div class="hyper-zone zone stacked" data-zone="p2-hyper" onclick="handleZoneClick('p2-hyper')"><span class="zone-label" data-i18n="zone_hyper">超次元</span></div>
                        <div class="grave-zone zone stacked" data-zone="p2-grave" onclick="handleZoneClick('p2-grave')"><span class="zone-label" data-i18n="zone_grave">墓地</span></div>
                        <div class="deck-zone zone stacked" data-zone="p2-deck" onclick="handleZoneClick('p2-deck')"><span class="zone-label" data-i18n="zone_deck">牌庫</span></div>
                    </div>
                </div>
            </div>

            <div id="player1-area" class="player-area">
                <div class="turn-bar"></div>
                <div class="battle-zone zone" data-zone="p1-battle" onclick="handleZoneClick('p1-battle')"><span class="zone-label" data-i18n="zone_battle">P1 戰鬥場</span></div>
                <div class="shield-zone zone" data-zone="p1-shield" onclick="handleZoneClick('p1-shield')"><span class="zone-label" data-i18n="zone_shield">P1 護盾區</span></div>
                <div class="mana-zone zone" data-zone="p1-mana" onclick="handleZoneClick('p1-mana')"><span class="zone-label" data-i18n="zone_mana">P1 魔力區</span></div>
                <div class="bottom-row">
                    <div class="hand-zone zone" data-zone="p1-hand" onclick="handleZoneClick('p1-hand')"><span class="zone-label" data-i18n="zone_hand">P1 手牌</span></div>
                    <div class="side-zone-group">
                        <div class="deck-zone zone stacked" data-zone="p1-deck" onclick="handleZoneClick('p1-deck')"><span class="zone-label" data-i18n="zone_deck">牌庫</span></div>
                        <div class="grave-zone zone stacked" data-zone="p1-grave" onclick="handleZoneClick('p1-grave')"><span class="zone-label" data-i18n="zone_grave">墓地</span></div>
                        <div class="hyper-zone zone stacked" data-zone="p1-hyper" onclick="handleZoneClick('p1-hyper')"><span class="zone-label" data-i18n="zone_hyper">超次元</span></div>
                    </div>
                </div>
            </div>

        </div>
    </div>

	<div id="slider-zone">
        <div id="slider-tooltip">0/0</div>
        <input type="range" id="playback-slider" min="0" max="0" value="0" step="1" 
               oninput="handleSliderDragging(this.value)" 
               onchange="handleSliderRelease(this.value)">
    </div>
	
    <div id="timeline-panel">
        <div id="timeline-header">
			<span style="flex:1;" data-i18n="lbl_action_log">Action Log</span>
			<small style="font-weight:normal; opacity:0.8; margin-right:5px;" id="step-counter">0/0</small>
		</div>
        <ul id="action-list"></ul>
        <div style="padding: 10px; background: #ecf0f1; border-top:1px solid #bdc3c7;">
            <div style="display: flex; gap:5px; justify-content: center; margin-bottom: 5px;">
                <button onclick="prevStep()">▲</button>
                <button onclick="togglePlay()" id="btn-play">▶</button>
				<button onclick="stopPlayback()" id="btn-stop">⏹</button>
                <button onclick="nextStep()">▼</button>
				<select id="speed-select" onchange="changePlaybackSpeed(this.value)" style="padding:2px; border-radius:4px; border:1px solid #ccc; background:#fff; font-size:0.85rem; cursor:pointer;">
					<option value="4.0">🚀 0.25x (極慢)</option>
					<option value="2.0">🐢 0.5x (慢速)</option>
					<option value="1.33">🚶 0.75x (稍慢)</option>
					<option value="1.0" selected>▶ 1.0x (正常)</option>
					<option value="0.66">🏃 1.5x (稍快)</option>
					<option value="0.5">🐇 2.0x (快速)</option>
					<option value="0.25">⚡ 4.0x (極速)</option>
				</select>
            </div>
        </div>
    </div>
</div>

<div id="card-action-panel">
    
    <div class="panel-row">
        <button id="btn-paste" onclick="pasteImageMode()" data-i18n="act_paste">🖼️ 上圖 (Ctrl+V)</button>
        <button id="btn-remove-image" style="display:none; background:#e74c3c;" onclick="removeImage()" data-i18n="btn_remove_img_short">✕ 圖</button>
        
        <div class="panel-sep"></div>
        
        <input type="text" id="rename-input" placeholder="名稱..." onkeydown="if(event.key==='Enter') renameCard()" style="width: 80px;" data-i18n-ph="ph_rename">
        <button onclick="renameCard()" data-i18n="act_rename">更名</button>
        <input type="text" id="note-input" placeholder="註記..." onkeydown="if(event.key==='Enter') addCardNote()" style="width: 80px;" data-i18n-ph="ph_note">
        <button onclick="addCardNote()" data-i18n="act_note">📝註記</button>
        
        <div class="panel-sep"></div>

        <button id="btn-ace" onclick="toggleAceFromPanel()" data-i18n="act_ace">👑 王牌</button>
        
        <button id="btn-delete-card" class="danger" style="display:none; margin-left:5px;" onclick="deleteSelectedCard()" data-i18n="act_delete">🗑️ 刪除</button>
    </div>

    <div class="panel-row">
        <button id="btn-rotate-l" onclick="rotateCard(-90)">↶</button>
        <button id="btn-rotate-r" onclick="rotateCard(90)">↷</button>
        <button id="btn-flip" onclick="flipCard()" data-i18n="act_flip">翻面</button>
        
        <button id="btn-moonless" onclick="toggleMoonless()" data-i18n="act_moonless">🌑 無月之門</button>

        <div class="panel-sep"></div>

        <button id="btn-injured" style="display:none; background:#e74c3c; border-color:#c0392b;" onclick="toggleInjured()" data-i18n="act_injured">💔 受傷</button>
        <button id="btn-clear-injured" style="display:none; background:#27ae60; border-color:#2ecc71;" onclick="clearInjured()" data-i18n="act_clear_injured">❤️ 治癒</button>
        
        <button id="btn-glow" onclick="toggleGlow()" data-i18n="act_glow">💡發光</button>
        <button id="btn-glow-bottom" onclick="toggleBottomGlow()" style="background:#5dade2; border-color:#3498db;" data-i18n="act_glow_bottom">👇底光</button>
        <button id="btn-unglow" style="display:none;" onclick="removeGlow()">✕</button>

        <div class="panel-sep"></div>

        <button id="btn-copy-ability" onclick="copyToAbility(false)" data-i18n="act_ability">⚡單次</button>
        <button id="btn-copy-continuous" onclick="copyToAbility(true)" style="background:#9b59b6; border-color:#8e44ad;" data-i18n="act_continuous">∞ 持續</button>
        
        <div id="ability-adjust-controls" style="display:none; width:1px;"></div>
        <div id="ability-adjust-buttons" style="display:none; gap:2px; align-items:center;">
            <button onclick="adjustAbilityCard('panX', -10)">⬅</button>
            <button onclick="adjustAbilityCard('panX', 10)">➡</button>
            <button onclick="adjustAbilityCard('panY', -10)">⬆</button>
            <button onclick="adjustAbilityCard('panY', 10)">⬇</button>
            <button onclick="adjustAbilityCard('scale', 0.1)">+</button>
            <button onclick="adjustAbilityCard('scale', -0.1)">-</button>
        </div>

        <div class="panel-sep"></div>

        <button id="btn-reveal" onclick="revealCards()" data-i18n="act_reveal">👁️ 展示</button>
        <button id="btn-point" style="display:none; background:#8e44ad; border-color:#9b59b6;" onclick="enterPointMode()" data-i18n="act_point">👉 指向</button>
        <button id="btn-end-point" style="display:none; background:#95a5a6; border-color:#7f8c8d;" onclick="endPoint()" data-i18n="act_end_point">🛑 結束指向</button>
        
        <button class="danger" style="margin-left:5px;" onclick="cancelSelection()">✕</button>
    </div>
</div>

<div id="multi-select-bar" style="display:none; position:fixed; bottom:80px; left:50%; transform:translateX(-50%); background:rgba(44, 62, 80, 0.9); padding:10px 20px; border-radius:30px; color:white; font-weight:bold; z-index:2000; box-shadow:0 4px 15px rgba(0,0,0,0.3); align-items:center; gap:10px;">
    <span>📚 多選模式: <span id="multi-count-val">0</span> 張</span>
    <span style="font-size:0.8rem; opacity:0.8;">(點擊區域移動 / ESC取消)</span>
    <button onclick="cancelSelection()" style="background:#c0392b; border:none; padding:2px 8px; border-radius:10px; font-size:0.8rem; cursor:pointer;">✕</button>
</div>

<div id="setup-modal" class="modal">
    <div class="modal-content">
        <h3 style="margin-top:0; text-align:center;" data-i18n="title_setup">開局設定</h3>
        <div style="background:#fff3cd; padding:5px; margin-bottom:10px; font-size:0.85rem; border-radius:4px; text-align:center;" data-i18n="msg_setup_warn">
            注意：開始新局會清除當前未匯出的進度。
        </div>
        <div class="input-group">
            <label data-i18n="lbl_p1_deck">P1 牌庫數:</label>
            <input type="number" id="setup-p1-deck" value="40" min="40" max="60">
        </div>
        <div class="input-group">
            <label>P1 超次元:</label>
            <input type="number" id="setup-p1-hyper" value="0" min="0" max="8">
        </div>
        <hr style="width:100%; border:0; border-top:1px dashed #ccc;">
        <div class="input-group">
            <label data-i18n="lbl_p2_deck">P2 牌庫數:</label>
            <input type="number" id="setup-p2-deck" value="40" min="40" max="60">
        </div>
        <div class="input-group">
            <label>P2 超次元:</label>
            <input type="number" id="setup-p2-hyper" value="0" min="0" max="8">
        </div>
        <div style="margin-top:20px; display:flex; justify-content:space-between;">
            <button onclick="clearStorage()" style="background:#7f8c8d;" data-i18n="btn_clear_storage">清除存檔</button>
            <button onclick="finishSetup()" class="primary" data-i18n="btn_start_game">開始遊戲 (Start)</button>
        </div>
    </div>
</div>

<div id="card-selector-modal" class="modal">
    <div class="modal-content">
        <div style="display:flex; justify-content:space-between; margin-bottom:10px;">
            <span id="modal-title" style="font-weight:bold; font-size:1.2rem;">Zone</span>
            <button onclick="closeSelectorModal()" style="border:none; background:none; font-size:1.5rem;">✕</button>
        </div>
        <div id="modal-body"></div>
        <div style="margin-top:15px; display:flex; gap:10px; justify-content:flex-end;">
			<button onclick="actionShuffleZone()" style="background:#8e44ad;" data-i18n="btn_shuffle_zone">洗牌此區</button>
			<button onclick="prepareMove(true)" style="background:#d35400;" data-i18n="btn_shuffle_move">洗牌選取牌並移動...</button>
			<button onclick="revealFromSelector()" style="background:#3498db;" data-i18n="btn_reveal_sel">👁️ 展示</button>
			<button onclick="prepareMove(false)" style="background:#2980b9;" data-i18n="btn_move_sel">移動選取牌...</button>
		</div>
    </div>
</div>

<div id="position-selector-modal" class="modal">
    <div class="modal-content">
        <div id="pos-modal-title" style="font-weight:bold; font-size:1.2rem; margin-bottom:10px;" data-i18n="title_stack">堆疊操作</div>
        <div style="margin-bottom:10px; font-size:0.9rem; color:#666;" data-i18n="lbl_stack_hint">請點擊圖示選擇堆疊方式：</div>
        
        <div id="stack-gui">
            <div class="stack-option" onclick="confirmStackMove('top')">
                <div class="stack-icon icon-top"><div class="child"></div></div>
                <span data-i18n="opt_stack_top">疊在上方</span>
            </div>
            <div class="stack-option" onclick="confirmStackMove('bottom')">
                <div class="stack-icon icon-bottom"><div class="child"></div></div>
                <span data-i18n="opt_stack_btm">疊在下方</span>
            </div>
            <div class="stack-option" onclick="confirmStackMove('puzzle_top')">
                <div class="stack-icon icon-p-top"><div class="child"></div></div>
                <span data-i18n="opt_puz_top">拼在上方</span>
            </div>
            <div class="stack-option" onclick="confirmStackMove('puzzle_bottom')">
                <div class="stack-icon icon-p-bottom"><div class="child"></div></div>
                <span data-i18n="opt_puz_btm">拼在下方</span>
            </div>
             <div class="stack-option" onclick="confirmStackMove('puzzle_left')">
                <div class="stack-icon icon-p-left"><div class="child"></div></div>
                <span data-i18n="opt_puz_left">拼在左邊</span>
            </div>
             <div class="stack-option" onclick="confirmStackMove('puzzle_right')">
                <div class="stack-icon icon-p-right"><div class="child"></div></div>
                <span data-i18n="opt_puz_right">拼在右邊</span>
            </div>
            
            <div class="stack-option" onclick="confirmStackMove('shift_up')">
                <div class="stack-icon icon-up"><div class="child"></div></div>
                <span data-i18n="opt_shift_up">上方 (露出底)</span>
            </div>
            <div class="stack-option" onclick="confirmStackMove('shift_down')">
                <div class="stack-icon icon-down"><div class="child"></div></div>
                <span data-i18n="opt_shift_down">上方 (露出頂)</span>
            </div>
            <div class="stack-option" onclick="confirmStackMove('bottom_exposed')">
                <div class="stack-icon icon-bottom-exp"><div class="child"></div></div>
                <span data-i18n="opt_btm_exp">下方 (露出底)</span>
            </div>
        </div>
        <div id="position-list" style="display:none;"></div> 
        <div style="margin-top:15px; text-align:right;">
            <button onclick="closePositionModal()" class="danger">取消</button>
        </div>
    </div>
</div>

<div id="import-conflict-modal" class="modal">
    <div class="modal-content" style="width: 400px; text-align: center;">
        <h3>發現外部劇本</h3>
        <p>網址參數包含劇本檔，但偵測到您有未儲存的本地進度。</p>
        <p>請問要如何處理？</p>
        <div style="display: flex; flex-direction: column; gap: 10px; margin-top: 15px;">
            <button onclick="resolveImportConflict('cancel')" style="padding: 10px;">❌ 不匯入 (使用本地存檔)</button>
            <button onclick="resolveImportConflict('save')" style="padding: 10px; background: #2ecc71;">💾 存檔然後匯入</button>
            <button onclick="resolveImportConflict('overwrite')" style="padding: 10px; background: #e74c3c;">⚠️ 不存檔直接匯入</button>
        </div>
    </div>
</div>

<div id="mobile-controls">
    <select id="mob-speed-select" onchange="changePlaybackSpeed(this.value)">
        <option value="4.0">🐢 0.25x</option>
        <option value="2.0">🐇 0.5x</option>
        <option value="1.33">🚶 0.75x</option>
        <option value="1.0" selected>▶ 1.0x</option>
        <option value="0.66">🏃 1.5x</option>
        <option value="0.5">🚀 2.0x</option>
        <option value="0.25">⚡ 4.0x</option>
    </select>
	<button class="mobile-btn" id="mob-mute-btn" onclick="toggleMute()" style="margin-left: 5px; margin-right: 5px;">🔊</button>
    <button class="mobile-btn" id="mob-stop-btn" onclick="stopPlayback()" style="margin-right:5px;">⏹</button>
    <button class="mobile-btn" id="mob-play-btn" onclick="togglePlay()">▶</button>
</div>

<div id="orientation-overlay">
    <div class="icon">📱</div>
    
    <h2 style="margin: 10px 0 5px;">請旋轉螢幕</h2>
    <p style="margin: 0 0 5px; font-size: 0.9rem; opacity: 0.8;">為了最佳觀看體驗，請將手機轉為橫向。</p>
    <p style="margin: 0 0 15px; font-size: 0.85rem; color: #f1c40f; font-weight: bold;">⚠️ 行動裝置只提供播放，編輯請使用個人電腦開啟。</p>
    
    <h2 style="margin: 10px 0 5px; font-size: 1.3rem;">Please Rotate Screen</h2>
    <p style="margin: 0 0 5px; font-size: 0.9rem; opacity: 0.8;">For the best experience, please use landscape mode.</p>
    <p style="margin: 0 0 15px; font-size: 0.85rem; color: #f1c40f; font-weight: bold;">⚠️ Mobile is for playback only. Please use PC for editing.</p>
    
    <h2 style="margin: 10px 0 5px; font-size: 1.3rem;">画面を回転してください</h2>
    <p style="margin: 0 0 5px; font-size: 0.9rem; opacity: 0.8;">最適な表示のために、端末を横向きにしてください。</p>
    <p style="margin: 0; font-size: 0.85rem; color: #f1c40f; font-weight: bold;">⚠️ モバイルは再生専用です。編集はPCをご利用ください。</p>
</div>
<div id="bgm-modal" class="modal">
    <div class="modal-content" style="width: 400px;">
        <h3 style="margin-top:0; text-align:center;">🎵 設定背景音樂 (BGM)</h3>
        <p style="font-size:0.8rem; color:#666; text-align:center;">點擊列表可試聽，按下確認後生效。</p>
        
        <div id="bgm-list" style="max-height: 300px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px;">
            </div>

        <div style="margin-top:15px; display:flex; justify-content:space-between;">
            <button class="danger" onclick="closeBGMModal()">取消 (Cancel)</button>
            <button class="primary" onclick="confirmBGM()">💾 確認 (Confirm)</button>
        </div>
    </div>
</div>
<div id="about-modal" class="modal">
    <div class="modal-content" style="width: 350px; text-align: center;">
        <h3 style="margin-top:0; border-bottom:1px solid #eee; padding-bottom:10px;">Credits</h3>
        
        <div style="text-align: left; font-size: 0.9rem; line-height: 1.6; padding: 10px;">
            <div style="margin-bottom: 12px;">
                <div style="font-weight:bold; color:#2c3e50;">Project Lead & Design</div>
                <div>Ether (<a href="mailto:tairandodx@msn.com" style="color:#3498db; text-decoration:none;">tairandodx@msn.com</a>)</div>
            </div>
            
            <div style="margin-bottom: 12px;">
                <div style="font-weight:bold; color:#2c3e50;">Coding & Implementation</div>
                <div>Google Gemini Pro (v1.5 / v2.0 Flash)</div>
            </div>
            
            <div style="margin-bottom: 12px;">
                <div style="font-weight:bold; color:#2c3e50;">Music / BGM Assets</div>
                <div>魔王魂 (<a href="https://maou.audio" target="_blank" style="color:#e67e22; text-decoration:none;">maou.audio</a>)</div>
            </div>
        </div>

        <div style="margin-top:15px; border-top:1px solid #eee; padding-top:15px;">
            <button class="primary" onclick="document.getElementById('about-modal').style.display='none'">Close</button>
        </div>
    </div>
</div>
<div id="dialogue-modal" class="modal">
    <div class="modal-content" style="width: 700px; max-width:95vw;">
        <h3 style="margin-top:0; text-align:center;" data-i18n="title_dialogue_insert">插入劇情對話 (Action)</h3>
        <p style="font-size:0.8rem; color:#666; text-align:center;" data-i18n="lbl_diag_replace_hint">
            點擊表情圖示後，按下[Ctrl+V]可替換該表情圖片 (全域生效)。
        </p>
		<div style="text-align:center; margin-bottom:15px; padding-bottom:10px; border-bottom:1px dashed #ccc;">
            <button onclick="swapAndFlipAllPortraits()" style="background:#e67e22; border-color:#d35400; font-weight:bold;" data-i18n="btn_swap_flip">
                🔁 P1/P2 圖片交換 & 水平翻轉
            </button>
            <div style="font-size:0.75rem; color:#888; margin-top:5px;" data-i18n="lbl_swap_flip_hint">
                * 將 P1 與 P2 的所有表情圖片互換，並自動進行水平翻轉 (預設圖除外)
            </div>
        </div>

        <div class="diag-editor-row" style="border-left: 5px solid #c0392b;">
            <div class="diag-editor-col" style="flex:0 0 100px; align-items:center; justify-content:center;">
                <label><input type="checkbox" id="edit-p2-active" onchange="toggleDiagEdit('p2')"> <span data-i18n="lbl_enable_p2">啟用 P2</span></label>
                <div style="font-weight:bold; color:#c0392b;" data-i18n="lbl_p2_desc">(上方/敵方)</div>
            </div>
            <div class="diag-editor-col">
                <input type="text" id="edit-p2-name" placeholder="Name..." data-i18n-ph="ph_name" value="Rival">
                <textarea id="edit-p2-text" rows="2" placeholder="Text..." data-i18n-ph="ph_text"></textarea>
                <div style="display:flex; gap:5px;">
                    <select id="edit-p2-size">
                        <option value="s" data-i18n="opt_size_s">小字</option>
                        <option value="m" selected data-i18n="opt_size_m">中字</option>
                        <option value="l" data-i18n="opt_size_l">大字</option>
                    </select>
                    <select id="edit-p2-effect">
                        <option value="direct" data-i18n="opt_effect_direct">直接顯示</option>
                        <option value="fade" data-i18n="opt_effect_fade">淡入</option>
                        <option value="slide" selected data-i18n="opt_effect_slide">滑入</option>
                    </select>
                    <span style="font-size:0.8rem; margin:0 3px;">➡</span>
                    <select id="edit-p2-exit">
                        <option value="direct" data-i18n="opt_exit_direct">直接消失</option>
                        <option value="fade" data-i18n="opt_exit_fade">淡出</option>
                        <option value="slide" data-i18n="opt_exit_slide">抽出</option>
                    </select>
                </div>
            </div>
            <div class="diag-editor-col" style="flex:0 0 200px;">
                <div class="emotion-grid" id="emotion-grid-p2"></div>
                <input type="hidden" id="edit-p2-emotion" value="normal">
            </div>
        </div>

        <div class="diag-editor-row" style="border-left: 5px solid #3498db;">
            <div class="diag-editor-col" style="flex:0 0 100px; align-items:center; justify-content:center;">
                <label><input type="checkbox" id="edit-p1-active" checked onchange="toggleDiagEdit('p1')"> <span data-i18n="lbl_enable_p1">啟用 P1</span></label>
                <div style="font-weight:bold; color:#3498db;" data-i18n="lbl_p1_desc">(下方/我方)</div>
            </div>
            <div class="diag-editor-col">
                <input type="text" id="edit-p1-name" placeholder="Name..." data-i18n-ph="ph_name" value="Player">
                <textarea id="edit-p1-text" rows="2" placeholder="Text..." data-i18n-ph="ph_text"></textarea>
                <div style="display:flex; gap:5px;">
                    <select id="edit-p1-size">
                        <option value="s" data-i18n="opt_size_s">小字</option>
                        <option value="m" selected data-i18n="opt_size_m">中字</option>
                        <option value="l" data-i18n="opt_size_l">大字</option>
                    </select>
                    <select id="edit-p1-effect">
                        <option value="direct" data-i18n="opt_effect_direct">直接顯示</option>
                        <option value="fade" data-i18n="opt_effect_fade">淡入</option>
                        <option value="slide" selected data-i18n="opt_effect_slide">滑入</option>
                    </select>
                    <span style="font-size:0.8rem; margin:0 3px;">➡</span>
                    <select id="edit-p1-exit">
                        <option value="direct" data-i18n="opt_exit_direct">直接消失</option>
                        <option value="fade" data-i18n="opt_exit_fade">淡出</option>
                        <option value="slide" data-i18n="opt_exit_slide">抽出</option>
                    </select>
                </div>
            </div>
            <div class="diag-editor-col" style="flex:0 0 200px;">
                <div class="emotion-grid" id="emotion-grid-p1"></div>
                <input type="hidden" id="edit-p1-emotion" value="normal">
            </div>
        </div>

        <div style="text-align:right; margin-top:10px;">
            <button class="danger" onclick="document.getElementById('dialogue-modal').style.display='none'; cancelDraft();" data-i18n="btn_cancel">取消</button>
            <button class="primary" onclick="confirmDialogue()" data-i18n="btn_save_step">💾 儲存此步</button>
        </div>
    </div>
</div>

<script>

	// --- [新增] 預設/全域 計數器 (桌機版或無劇本時使用) ---
    // 請填入您申請的「主頁/大廳」專用計數器網址
    const DEFAULT_COUNTER_URL = 'https://www.f-counter.net/j/66/1765258234/';
	// --- [新增] 劇本清單設定 ---
    const AVAILABLE_SCRIPTS = [
        {
            filename: 'script20251203.txt',
            title: '天災色控制 VS 巨大鯨',
            description: '初試劇本功能',
			counter_url: 'https://www.f-counter.net/j/66/1765257662/',
			speed: 1.0,
            lang: 'zh',
        },
        {
            filename: 'script20251205.txt',
            title: '王鬥高麗菜 VS 波夏克龍皇神',
            description: '作者常玩的訓練對局',
			counter_url: 'https://www.f-counter.net/j/66/1765257467/',
			speed: 1.0,
            lang: 'zh',
        },
        {
            filename: 'script20251208.txt',
            title: '甲獸軍隊 VS 烏爾天寶',
            description: '進行DM25-RP4新卡的測試',
			counter_url: 'https://www.f-counter.net/j/66/1765258081/',
			speed: 1.0,
            lang: 'zh',
        },
        {
            filename: 'script20251209.txt',
            title: '新惡魔 VS 新武士',
            description: '進行DM25-RP4新卡的測試',
			counter_url: 'https://www.f-counter.net/j/66/1765258098/',
			speed: 1.33,
            lang: 'zh',
        },
        // 您可以在此擴充更多劇本...
    ];

	// --- Dialogue Assets Generation ---
    const EMOTIONS = ['normal', 'blank', 'serious', 'smug', 'furious', 'terrified'];
    const EMOTION_LABELS = {normal:'一般', blank:'呆滯', serious:'認真', smug:'得意', furious:'盛怒', terrified:'驚恐'};
    
    // 生成簡單的 Canvas 頭像
    function generateDefaultPortraits() {
        const drawFace = (color, emotion) => {
            const canvas = document.createElement('canvas');
            canvas.width = 160; canvas.height = 160;
            const ctx = canvas.getContext('2d');
            
            // 背景與框
            ctx.fillStyle = '#222'; ctx.fillRect(0,0,160,160);
            ctx.lineWidth = 4; ctx.strokeStyle = color; ctx.strokeRect(5,5,150,150);
            
            // 臉型
            ctx.beginPath(); ctx.arc(80, 80, 50, 0, Math.PI*2); ctx.stroke();
            
            // 眼睛
            ctx.beginPath();
            if(emotion==='blank') { ctx.arc(65, 70, 3, 0, Math.PI*2); ctx.arc(95, 70, 3, 0, Math.PI*2); }
            else if(emotion==='serious') { ctx.moveTo(55,65); ctx.lineTo(75,75); ctx.moveTo(105,65); ctx.lineTo(85,75); } // 眉頭深鎖
            else if(emotion==='furious') { ctx.moveTo(55,60); ctx.lineTo(75,80); ctx.moveTo(105,60); ctx.lineTo(85,80); } // 生氣眉毛
            else if(emotion==='terrified') { ctx.arc(65, 70, 8, 0, Math.PI*2); ctx.arc(95, 70, 8, 0, Math.PI*2); } // 瞳孔放大
            else { ctx.arc(65, 70, 5, 0, Math.PI*2); ctx.arc(95, 70, 5, 0, Math.PI*2); }
            ctx.stroke();

            // 嘴巴
            ctx.beginPath();
            if(emotion==='smug') { ctx.arc(80, 90, 10, 0, Math.PI, false); } // 微笑
            else if(emotion==='furious') { ctx.moveTo(70,105); ctx.lineTo(90,105); ctx.rect(70,100,20,10); } // 怒吼
            else if(emotion==='terrified') { ctx.ellipse(80, 110, 10, 15, 0, 0, Math.PI*2); } // 張口
            else if(emotion==='serious') { ctx.moveTo(70,105); ctx.lineTo(90,105); } // 抿嘴
            else { ctx.arc(80, 90, 15, 0, Math.PI, false); } // 一般笑
            ctx.stroke();

            return canvas.toDataURL();
        };

        ['p1', 'p2'].forEach(p => {
            const color = p === 'p1' ? '#3498db' : '#c0392b';
            EMOTIONS.forEach(emo => {
                const key = `avatar_${p}_${emo}`;
                if (!globalImageRegistry[key]) {
                    globalImageRegistry[key] = drawFace(color, emo);
                }
            });
        });
    }
	
	// --- [新增] URL 參數讀取工具 ---
    function getUrlParameter(name) {
        name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
        var regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
        var results = regex.exec(location.search);
        return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
    }
	
	// --- [新增] 播放時間參數設定 (Global Config for Playback) ---
    // 您可以在這裡統一調整所有速度 (單位：毫秒)
    
    const TIME_ACTION_BASE = 1200;       // 一般動作 (如移動卡片) 的預設停留時間
    const TIME_DIALOGUE_BASE = 500;      // 對話動作的「起跳」時間
    const TIME_CHAR_READING = 90;        // 對話中「每個字」增加的閱讀時間
    const TIME_DIALOGUE_MIN = 1200;      // 對話動作的「最短」停留時間 (避免字太少一閃而過)
	
	// --- 多語言設定 (i18n) ---
    const TRANSLATIONS = {
		'zh': {
			'btn_setup': 'Setup / Clear',
			'btn_rotate': '🔄 回合結束',
			'btn_p1_reset': 'P1 重置',
			'btn_p2_reset': 'P2 重置',
			'btn_reset_current': '重置當前 (Untap)', // [新增]
			'btn_p1_win': '🏆 1P Win',
			'btn_p2_win': '🏆 2P Win',
			'opt_win_default': '🏆 宣告勝利...', // [新增]
			'btn_import': '匯入 (Import)',
			'btn_export': '匯出 (Export)',
            'btn_dialogue': '💬 對話 (Dialog)', // [新增]
			
			'zone_battle': '戰鬥場',
			'zone_shield': '護盾區',
			'zone_mana': '魔力區',
			'zone_hand': '手牌',
			'zone_hyper': '超次元',
			'zone_grave': '墓地',
			'zone_deck': '牌庫',
			'zone_ability': '能力 (待處理)',
			
			'act_flip': '翻面',
			'act_injured': '💔 受傷',
			'act_clear_injured': '❤️ 治癒', // [新增]
			'act_glow': '💡發光',
			'act_ability': '⚡觸發能力',
			'act_continuous': '∞ 持續能力',
			'act_reveal': '👁️ 展示',
			'act_point': '👉 指向',
			'act_end_point': '🛑 結束指向',
			'act_paste': '🖼️ 上圖 (Ctrl+V)',
			'act_rename': '更名',
			'act_note': '📝註記',
			'act_delete': '🗑️ 刪除',

			'lbl_draft_warning': '⚠️ 編輯中... (已累積 ',
			'lbl_draft_ops': ' 個操作)',
			'lbl_draft_ops_prefix': '包含', 
			'chk_propagate': '🔗 連動更新後續',
			'btn_cancel': '取消',
			'btn_save_step': '💾 儲存此步',
			'lbl_point_mode': '👉 指向模式：請選擇目標 (可選擇任意卡片或區域)',
			'btn_confirm_point': '✅ 確認指向',
			'btn_reset_all': '🗑️重設',

			'title_setup': '開局設定',
			'msg_setup_warn': '注意：開始新局會清除當前未匯出的進度。',
            'btn_clear_storage': '清除存檔',
			'btn_start_game': '開始遊戲 (Start)',
			'btn_draw': '🎴 抽牌 (Draw)', // [新增]

            // --- 對話相關翻譯 [新增] ---
            'title_dialogue_insert': '插入劇情對話 (Action)',
            'lbl_diag_replace_hint': '點擊表情圖示後，按下[Ctrl+V]可替換該表情圖片 (全域生效)。',
            'lbl_enable_p2': '啟用 P2',
            'lbl_p2_desc': '(上方/敵方)',
            'lbl_enable_p1': '啟用 P1',
            'lbl_p1_desc': '(下方/我方)',
            'ph_name': '名字...',
            'ph_text': '台詞...',
            'opt_size_s': '小字',
            'opt_size_m': '中字',
            'opt_size_l': '大字',
            'opt_effect_direct': '直接顯示',
            'opt_effect_fade': '淡入',
            'opt_effect_slide': '滑入',
            'opt_exit_direct': '直接消失',
            'opt_exit_fade': '淡出',
            'opt_exit_slide': '抽出',
            // -----------------------

            // ... (保留舊有的其他翻譯，如堆疊操作、訊息等) ...
            'btn_shuffle_zone': '洗牌此區',
			'btn_shuffle_move': '洗牌選取牌並移動...',
			'btn_reveal_sel': '👁️ 展示',
			'btn_move_sel': '移動選取牌...',
            'title_stack': '堆疊操作',
            'lbl_stack_hint': '請點擊圖示選擇堆疊方式：',
            'msg_storage_full': '⚠️ 自動存檔失敗：儲存空間已滿。\n建議您立即「匯出」保存進度。',
            'msg_confirm_clear_storage': '確定要清除所有自動存檔嗎？',
            'msg_cleared': '存檔已清除。',
            'msg_confirm_del_all': '確定要刪除所有動作並重新開始新局嗎？',
            'msg_unsaved_draft': '目前有未儲存的變更，是否捨棄並開始新步驟？',
            'msg_unsaved_edit': '目前有未儲存的變更，是否捨棄並編輯此步驟？',
            'msg_confirm_del_step': '確定刪除此步驟？',
            'msg_confirm_p1_reset': '確定要重置 P1 盤面方向嗎？',
            'msg_confirm_p2_reset': '確定要重置 P2 盤面方向嗎？',
            'msg_glow_err': '只有「待處理區」的卡片可以下達發光指令。',
            'msg_glow_ability_only': '只有「待處理區」的卡片可以操作發光狀態。',
            'msg_injured_err': '只有「戰鬥區」與「護盾區」的卡片可以標記為受傷。',
            'msg_select_one_copy': '請一次選擇一張牌進行複製',
            'msg_select_one_point': '請選擇一張卡片進行指向',
            'msg_point_save_first': '請先儲存當前步驟，再結束指向',
            'msg_mobile_blocked': '此功能未對行動裝置開放',
            'msg_import_success': '匯入成功！',
            'msg_import_fail': '匯入失敗',
            'msg_confirm_import': '確定要匯入此檔案嗎？',
            'msg_replace_img': '確定要替換這張卡片的圖片嗎？',
            'msg_remove_img': '確定要移除這張卡片的圖片嗎？',
            'msg_init_fail': '初始化失敗: ',
            'msg_cannot_del_init': '無法刪除初始步驟。',
            'btn_cancel_draft': '取消',
            'msg_confirm_delete_all': '確定要刪除所有動作並重新開始新局嗎？',
            'msg_confirm_reveal_close': '確定要關閉展示區並將卡片送入墓地嗎？',
            'msg_delete_card_confirm': '確定要刪除選取的卡片嗎？(僅建議用於能力處理區)',
            'msg_confirm_point_zone': '確認指向 {zone}?',
            'msg_ability_cant_move': '能力待處理區的卡片不能移動',
            'msg_insert_pos_title': '插入位置選擇 (點擊虛線框)',
            'msg_load_script_fail': '無法載入指定劇本: ',
			'msg_editing_step': '📝 正在編輯 #{n}',
			'msg_insert_after': '➕ 將新增於 #{n} 之後',
            'btn_play_from': '▶ 從此播放',
            'btn_play_step': '👁️ 演示此步',
            'btn_edit_step': '✏️ 編輯',
            'btn_delete_step': '🗑 刪除',
            'btn_play': '▶',
            'btn_pause': '⏸',
            'lbl_reveal_zone': '展示區 (Reveal Zone)',
            'lbl_action_log': 'Action Log (操作紀錄)',
            'op_default': '操作',
            'op_count_suffix': ' 個動作',
            'desc_end_reveal': '結束展示',
            'desc_end_point': '結束指向',
            'lbl_move': '位移:',
            'lbl_scale': '縮放:',
            'btn_remove_img_short': '✕ 圖',
            'title_stack_target': '堆疊操作: 目標 [{target}]',
             // ... 保留其他您原本可能有的翻譯 ...
            'opt_stack_top': '疊在上方',
            'opt_stack_btm': '疊在下方',
            'opt_puz_top': '拼在上方',
            'opt_puz_btm': '拼在下方',
            'opt_puz_left': '拼在左邊',
            'opt_puz_right': '拼在右邊',
            'opt_shift_up': '上方 (露出底)',
            'opt_shift_down': '上方 (露出頂)',
            'opt_btm_exp': '下方 (露出底)',
            'lbl_p1_deck': 'P1 牌庫數:',
            'lbl_p2_deck': 'P2 牌庫數:',
            'op_POINT': '指向',
            'op_ATTACK': '攻擊宣言',
			'btn_multi_move': '📚 移動多張...',
            'btn_multi_confirm': '❌ 取消 / ✅ 一起移動',
            'msg_select_dest': '已選取 {n} 張卡片，請點擊「目標區域」進行移動 (若是牌庫/護盾將跳出插入選單)。',
			// ... (原本的內容) ...
            'act_glow_bottom': '👇底光',
            'btn_swap_flip': '🔁 P1/P2 圖片交換 & 水平翻轉',
            'lbl_swap_flip_hint': '* 將 P1 與 P2 的所有表情圖片互換，並自動進行水平翻轉 (預設圖除外)',
            'msg_confirm_swap': '確定要交換 P1 與 P2 的所有圖片並進行翻轉嗎？\n(注意：這是全域修改，會影響所有對話步驟)',
            'msg_swap_done': '圖片交換與翻轉完成！',
			'act_moonless': '🌑 無月之門',
			'btn_rps': '✊✌️🖐️ 猜拳 (RPS)',
            'act_rps': '猜拳',
            'rps_rock': '✊ 石頭',
            'rps_paper': '🖐️ 布',
            'rps_scissors': '✌️ 剪刀',
            'rps_draw': '平手！再來一把！',
            'rps_p1_win': 'P1 獲勝！',
            'rps_p2_win': 'P2 獲勝！',
		},
        // 為了節省空間，英文與日文請依照相同邏輯補上對應翻譯 (若無則顯示Key)
		'en': {
            'btn_dialogue': '💬 Dialog',
            'title_dialogue_insert': 'Insert Dialogue',
            'lbl_diag_replace_hint': 'Click an icon and press [Ctrl+V] to replace image (Global).',
            'lbl_enable_p2': 'Enable P2',
            'lbl_p2_desc': '(Top/Rival)',
            'lbl_enable_p1': 'Enable P1',
            'lbl_p1_desc': '(Bottom/Self)',
            'ph_name': 'Name...',
            'ph_text': 'Dialogue...',
            'opt_size_s': 'Small', 'opt_size_m': 'Medium', 'opt_size_l': 'Large',
            'opt_effect_direct': 'Instant', 'opt_effect_fade': 'Fade In', 'opt_effect_slide': 'Slide In',
            'opt_exit_direct': 'Instant', 'opt_exit_fade': 'Fade Out', 'opt_exit_slide': 'Slide Out',
            // ... (其餘請保留原樣) ...
            'btn_setup': 'Setup / Clear', 'btn_rotate': '🔄 Switch Turn', 'btn_reset_current': 'Untap Current','btn_p1_reset': 'P1 Untap', 'btn_p2_reset': 'P2 Untap',
            'btn_p1_win': '🏆 1P Win', 'btn_p2_win': '🏆 2P Win', 'opt_win_default': '🏆 Declare Win...', 'btn_import': 'Import', 'btn_export': 'Export',
            'zone_battle': 'Battle Zone', 'zone_shield': 'Shields', 'zone_mana': 'Mana', 'zone_hand': 'Hand',
            'zone_hyper': 'Hyper Zone', 'zone_grave': 'Graveyard', 'zone_deck': 'Deck', 'zone_ability': 'Ability (Pending)',
            'act_flip': 'Flip', 'act_injured': '💔 Injured', 'act_clear_injured': '❤️ Heal', 'act_glow': '💡 Glow', 'act_ability': '⚡ One-shot', 'act_continuous': '∞ Continuous',
            'act_reveal': '👁️ Reveal', 'act_point': '👉 Point', 'act_end_point': '🛑 End Point', 'act_paste': '🖼️ Paste Img',
            'act_rename': 'Rename', 'act_note': '📝 Note', 'act_delete': '🗑️ Delete', 'btn_cancel': 'Cancel', 'btn_save_step': '💾 Save Step',
            'lbl_point_mode': '👉 Point Mode: Select Target(s)', 'btn_confirm_point': '✅ Confirm', 'btn_reset_all': '🗑️ Reset',
            'title_setup': 'Setup Game', 'msg_setup_warn': 'Note: Starting new game clears unsaved progress.',
            'lbl_p1_deck': 'P1 Deck:', 'lbl_p2_deck': 'P2 Deck:', 'btn_clear_storage': 'Clear Storage', 'btn_start_game': 'Start Game','btn_draw': '🎴 Draw', // [新增]
            'btn_shuffle_zone': 'Shuffle Zone', 'btn_shuffle_move': 'Shuffle & Move...', 'btn_reveal_sel': '👁️ Reveal', 'btn_move_sel': 'Move Selected...',
            'title_stack': 'Stacking', 'lbl_stack_hint': 'Choose stacking method:', 'opt_stack_top': 'Cover Top', 'opt_stack_btm': 'Underneath',
            'opt_puz_top': 'Puzzle Top', 'opt_puz_btm': 'Puzzle Btm', 'opt_puz_left': 'Puzzle Left', 'opt_puz_right': 'Puzzle Right',
            'opt_shift_up': 'Shift Up', 'opt_shift_down': 'Shift Down', 'opt_btm_exp': 'Bottom Exposed', 'ph_rename': 'Name...', 'ph_note': 'Note...',
            'msg_storage_full': '⚠️ Storage full. Please Export data.', 'msg_confirm_clear_storage': 'Clear all auto-saved data?',
            'msg_cleared': 'Storage cleared.', 'msg_confirm_del_all': 'Delete all actions and restart?', 'msg_unsaved_draft': 'Discard changes and start new?',
            'msg_unsaved_edit': 'Discard changes and edit this step?', 'msg_confirm_del_step': 'Delete this step?',
            'msg_confirm_p1_reset': 'Reset P1 board?', 'msg_confirm_p2_reset': 'Reset P2 board?', 'msg_glow_err': 'Glow is only for Ability Zone.',
            'msg_glow_ability_only': 'Only cards in Ability Zone can glow.', 'msg_injured_err': 'Only cards in Battle/Shield Zone can be injured.',
            'msg_select_one_copy': 'Select exactly one card to copy.', 'msg_select_one_point': 'Select one card to point.',
            'msg_point_save_first': 'Save step before ending point mode.', 'msg_mobile_blocked': 'Not available on mobile.',
            'msg_import_success': 'Import Success!', 'msg_import_fail': 'Import Failed', 'msg_confirm_import': 'Import this file?',
            'msg_replace_img': 'Replace existing image?', 'msg_remove_img': 'Remove image from card?', 'msg_init_fail': 'Init Failed: ',
            'msg_cannot_del_init': 'Cannot delete the initial step.', 'btn_cancel_draft': 'Cancel', 'msg_confirm_delete_all': 'Delete all actions and restart?',
            'msg_confirm_reveal_close': 'Close reveal zone and send cards to grave?', 'msg_delete_card_confirm': 'Delete selected card(s)?',
            'msg_confirm_point_zone': 'Confirm point to {zone}?', 'msg_ability_cant_move': 'Ability cards cannot be moved.',
            'msg_insert_pos_title': 'Select Insert Position', 'msg_load_script_fail': 'Failed to load script: ', 'btn_play_from': '▶ Play From Here',
            'msg_editing_step': '📝 Editing #{n}',
			'msg_insert_after': '➕ Will insert after #{n}',
			'btn_play_step': '👁️ Demo Step', 'btn_edit_step': '✏️ Edit', 'btn_delete_step': '🗑 Delete', 'btn_play': '▶', 'btn_pause': '⏸',
            'lbl_reveal_zone': 'Reveal Zone', 'lbl_action_log': 'Action Log', 'op_default': 'Action', 'op_count_suffix': ' Actions',
            'desc_end_reveal': 'End Reveal', 'desc_end_point': 'End Pointing', 'lbl_move': 'Move:', 'lbl_scale': 'Scale:', 'btn_remove_img_short': '✕ Img',
            'title_stack_target': 'Stacking: Target [{target}]', 'lbl_draft_warning': '⚠️ Editing... (Steps: ', 'lbl_draft_ops': ')',
            'lbl_draft_ops_prefix': 'Contains ', 'chk_propagate': '🔗 Propagate Changes',
			'btn_multi_move': '📚 Move Multi...',
            'btn_multi_confirm': '❌ Cancel / ✅ Move All',
            'msg_select_dest': '{n} cards selected. Click a Destination Zone to move.',		
			// ... (Original content) ...
            'act_glow_bottom': '👇Btm Glow',
            'btn_swap_flip': '🔁 Swap P1/P2 & Flip',
            'lbl_swap_flip_hint': '* Swaps all P1/P2 portraits and flips them horizontally (Default avatars excluded).',
            'msg_confirm_swap': 'Are you sure you want to swap and flip all portraits?\n(Note: This is global and affects all dialogue steps.)',
            'msg_swap_done': 'Swap and flip complete!',
			'act_moonless': '🌑 Moonless',
			'btn_rps': '✊✌️🖐️ RPS',
            'act_rps': 'RPS',
            'rps_rock': '✊ Rock',
            'rps_paper': '🖐️ Paper',
            'rps_scissors': '✌️ Scissors',
            'rps_draw': 'Draw! Again!',
            'rps_p1_win': 'P1 Wins!',
            'rps_p2_win': 'P2 Wins!',
		},
		'jp': {
            'btn_dialogue': '💬 会話 (Dialog)',
            'title_dialogue_insert': '会話イベント挿入',
            'lbl_diag_replace_hint': 'アイコンをクリック後、[Ctrl+V]で画像を置き換えられます（全体反映）。',
            'lbl_enable_p2': 'P2を有効化',
            'lbl_p2_desc': '(上側/敵)',
            'lbl_enable_p1': 'P1を有効化',
            'lbl_p1_desc': '(下側/自分)',
            'ph_name': '名前...',
            'ph_text': 'セリフ...',
            'opt_size_s': '小', 'opt_size_m': '中', 'opt_size_l': '大',
            'opt_effect_direct': '即時', 'opt_effect_fade': 'フェード', 'opt_effect_slide': 'スライド',
            'opt_exit_direct': '即時消失', 'opt_exit_fade': 'フェード', 'opt_exit_slide': 'スライド',
            // ... (其餘請保留原樣) ...
            'btn_setup': '設定 / クリア', 'btn_rotate': '🔄 ターン交代', 'btn_reset_current': 'アンタップ (Current)', 'btn_p1_reset': 'P1 アンタップ', 'btn_p2_reset': 'P2 アンタップ',
            'btn_p1_win': '🏆 1P 勝利', 'btn_p2_win': '🏆 2P 勝利', 'opt_win_default': '🏆 勝利宣言...', 'btn_import': 'インポート', 'btn_export': 'エクスポート',
            'zone_battle': 'バトルゾーン', 'zone_shield': 'シールド', 'zone_mana': 'マナゾーン', 'zone_hand': '手札',
            'zone_hyper': '超次元', 'zone_grave': '墓地', 'zone_deck': '山札', 'zone_ability': '効果処理',
            'act_flip': '裏返す', 'act_injured': '💔 負傷', 'act_clear_injured': '❤️ 回復', 'act_glow': '💡 発光', 'act_ability': '⚡ トリガー能力','act_continuous': '∞ 常在能力',
            'act_reveal': '👁️ 公開', 'act_point': '👉 対象選択', 'act_end_point': '🛑 選択終了', 'act_paste': '🖼️ 画像貼付',
            'act_rename': '名前変更', 'act_note': '📝 メモ', 'act_delete': '🗑️ 削除', 'lbl_draft_warning': '⚠️ 編集中... (操作数: ',
            'lbl_draft_ops': ')', 'lbl_draft_ops_prefix': '', 'chk_propagate': '🔗 以降へ反映', 'btn_cancel': 'キャンセル',
            'btn_save_step': '💾 保存', 'lbl_point_mode': '👉 対象を選択してください (カード/領域)', 'btn_confirm_point': '✅ 決定',
            'btn_reset_all': '🗑️ リセット', 'title_setup': 'ゲーム設定', 'msg_setup_warn': '注意：新しいゲームを始めると、未保存の進行状況は消去されます。',
            'lbl_p1_deck': 'P1 山札数:', 'lbl_p2_deck': 'P2 山札数:', 'btn_clear_storage': 'データ削除', 'btn_start_game': 'ゲーム開始','btn_draw': '🎴 ドロー', // [新增]
            'btn_shuffle_zone': 'シャッフル', 'btn_shuffle_move': 'シャッフルして移動...', 'btn_reveal_sel': '👁️ 公開', 'btn_move_sel': '選択したカードを移動...',
            'title_stack': '重ね方を選択', 'lbl_stack_hint': 'アイコンをクリックしてください：', 'opt_stack_top': '上に重ねる', 'opt_stack_btm': '下に重ねる',
            'opt_puz_top': '上にリンク', 'opt_puz_btm': '下にリンク', 'opt_puz_left': '左にリンク', 'opt_puz_right': '右にリンク',
            'opt_shift_up': '少し上へ', 'opt_shift_down': '少し下へ', 'opt_btm_exp': '下へずらす', 'ph_rename': 'カード名...', 'ph_note': 'メモ...',
            'msg_storage_full': '⚠️ 保存領域がいっぱいです。エクスポートしてください。', 'msg_confirm_clear_storage': '保存データを削除しますか？',
            'msg_cleared': 'データを削除しました。', 'msg_confirm_del_all': 'すべての手順を削除してリセットしますか？', 'msg_unsaved_draft': '未保存の変更があります。破棄して新しい手順を作成しますか？',
            'msg_unsaved_edit': '未保存の変更があります。破棄してこの手順を編集しますか？', 'msg_confirm_del_step': 'この手順を削除しますか？',
            'msg_confirm_p1_reset': 'P1の盤面をアンタップ状態に戻しますか？', 'msg_confirm_p2_reset': 'P2の盤面をアンタップ状態に戻しますか？',
            'msg_glow_err': '効果処理エリアのカードのみ発光設定が可能です。', 'msg_glow_ability_only': '効果処理エリアのカードのみ発光設定が可能です。',
            'msg_injured_err': 'バトルゾーンまたはシールドのカードのみ負傷状態にできます。', 'msg_select_one_copy': 'コピーするカードを1枚選択してください。',
            'msg_select_one_point': '対象のカードを1枚選択してください。', 'msg_point_save_first': '対象選択を終了する前に、現在の手順を保存してください。',
            'msg_mobile_blocked': 'この機能はモバイル端末では利用できません。', 'msg_import_success': 'インポート成功！', 'msg_import_fail': 'インポート失敗',
            'msg_confirm_import': 'このファイルを読み込みますか？', 'msg_replace_img': '画像を置き換えますか？', 'msg_remove_img': '画像を削除しますか？',
            'msg_init_fail': '初期化エラー: ', 'msg_cannot_del_init': '初期状態は削除できません。', 'btn_cancel_draft': 'キャンセル',
            'msg_confirm_delete_all': 'すべての操作を削除してリセットしますか？', 'msg_confirm_reveal_close': '公開領域を閉じて、カードを墓地に送りますか？',
            'msg_delete_card_confirm': '選択したカードを削除しますか？(効果処理エリア推奨)', 'msg_confirm_point_zone': '{zone} を対象にしますか？',
            'msg_ability_cant_move': '効果処理中のカードは移動できません。', 'msg_insert_pos_title': '挿入位置を選択 (点線枠をクリック)',
            'msg_load_script_fail': 'スクリプトの読み込みに失敗しました: ', 'btn_play_from': '▶ ここから再生', 'btn_play_step': '👁️ この手順を確認',
            'msg_editing_step': '📝 手順 #{n} を編集中',
			'msg_insert_after': '➕ 手順 #{n} の後に追加',
			'btn_edit_step': '✏️ 編集', 'btn_delete_step': '🗑 削除', 'btn_play': '▶', 'btn_pause': '⏸ 一時停止',
            'lbl_reveal_zone': '公開領域', 'lbl_action_log': '行動ログ', 'op_default': '操作', 'op_count_suffix': ' アクション',
            'desc_end_reveal': '公開終了', 'desc_end_point': '選択終了', 'lbl_move': '移動:', 'lbl_scale': '縮小/拡大:', 'btn_remove_img_short': '✕ 画像',
            'title_stack_target': 'スタック操作: 対象 [{target}]', 'op_POINT': '対象選択', 'op_ATTACK': '攻撃宣言',
			'btn_multi_move': '📚 複数移動...',
            'btn_multi_confirm': '❌ 取消 / ✅ 一括移動',
            'msg_select_dest': '{n} 枚選択中。移動先のエリアをクリックしてください。',	
			// ... (Original content) ...
            'act_glow_bottom': '👇下発光',
            'btn_swap_flip': '🔁 P1/P2 画像交換 & 反転',
            'lbl_swap_flip_hint': '* P1とP2の立ち絵を入れ替え、左右反転します（デフォルト画像を除く）。',
            'msg_confirm_swap': 'すべての画像を交換して反転しますか？\n(注意：これは全体に適用され、すべての会話に影響します)',
            'msg_swap_done': '交換と反転が完了しました！',		
			'act_moonless': '🌑 無月の門',	
			'btn_rps': '✊✌️🖐️ じゃんけん',
            'act_rps': 'じゃんけん',
            'rps_rock': '✊ グー',
            'rps_paper': '🖐️ パー',
            'rps_scissors': '✌️ チョキ',
            'rps_draw': 'あいこでしょ！',
            'rps_p1_win': 'P1 勝利！',
            'rps_p2_win': 'P2 勝利！',			
		}
	};

    let currentLang = 'zh';
	
	// --- [新增] 操作面板位置記憶變數 ---
    // 預設值：P1 在上面 (Top: 15%)，P2 在下面 (Top: 80%)，水平大致置中
    let panelPosSettings = {
        p1: { x: window.innerWidth / 2 - 200, y: window.innerHeight * 0.8 }, 
        p2: { x: window.innerWidth / 2 - 200, y: window.innerHeight * 0.15 } 
    };
    let currentPanelOwner = 'p1'; // 記錄目前是誰的面板

    // --- [新增] 初始化拖曳功能 ---
    function initDraggablePanel() {
        const panel = document.getElementById('card-action-panel');
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };

        panel.addEventListener('mousedown', (e) => {
            // 如果點擊的是按鈕或輸入框，不觸發拖曳
            if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') return;
            
            isDragging = true;
            // 計算滑鼠點擊點與面板左上角的偏移量
            const rect = panel.getBoundingClientRect();
            dragOffset.x = e.clientX - rect.left;
            dragOffset.y = e.clientY - rect.top;
            
            // 視覺回饋：稍微變透明
            panel.style.opacity = '0.8';
        });

        window.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            e.preventDefault(); // 防止選取文字
            
            // 計算新位置
            let newX = e.clientX - dragOffset.x;
            let newY = e.clientY - dragOffset.y;

            // 邊界檢查 (防止拖出螢幕)
            const panelW = panel.offsetWidth;
            const panelH = panel.offsetHeight;
            const maxW = window.innerWidth - panelW;
            const maxH = window.innerHeight - panelH;

            if (newX < 0) newX = 0;
            if (newY < 0) newY = 0;
            if (newX > maxW) newX = maxW;
            if (newY > maxH) newY = maxH;

            // 套用位置
            panel.style.left = newX + 'px';
            panel.style.top = newY + 'px';
        });

        window.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                panel.style.opacity = '1'; // 恢復不透明
                
                // [關鍵] 拖曳結束後，記憶當前擁有者的位置
                const rect = panel.getBoundingClientRect();
                panelPosSettings[currentPanelOwner] = { x: rect.left, y: rect.top };
            }
        });
        
        // 視窗縮放時重新校正置中 (選用)
        window.addEventListener('resize', () => {
             panelPosSettings.p1.x = window.innerWidth / 2 - 300;
             panelPosSettings.p2.x = window.innerWidth / 2 - 300;
             // Y 軸保持比例
             panelPosSettings.p1.y = window.innerHeight * 0.15;
             panelPosSettings.p2.y = window.innerHeight * 0.8;
        });
    }

    // 請務必在 window.onload 裡面呼叫 initDraggablePanel();
	
	// --- [新增] BGM 設定 ---
    const BGM_FOLDER = 'bgm/'; // 請確保您的 bgm 資料夾在根目錄
    const BGM_FILES = [
        'heightenedAlert.mp3',
        'SpeedKing.mp3',
        'TheGodsTrial.mp3',
        'Edgy.mp3',
        'Village.mp3',
        'Mischievous.mp3',
        'Battle01.mp3',
        'BattleLastBoss01.mp3',
        'Battle02.mp3',
        'Battle03.mp3'
    ];
    
    // 全域音樂播放物件
    const globalAudioPlayer = new Audio();
    globalAudioPlayer.loop = true; // BGM 通常需要循環
    
    // 預覽用的播放物件 (避免干擾主播放器)
    const previewAudioPlayer = new Audio();

    // 同時修改 getPlayButtonText 判定
    function getPlayButtonText() { return playTimeout ? t('btn_pause') : t('btn_play'); }
    // --- [整合版] 更新播放按鈕 UI (同時處理桌機與手機) ---
    function updatePlayButtonUI() {
        const isPlaying = !!playTimeout; // 轉為布林值
        const text = isPlaying ? t('btn_pause') : t('btn_play');
        const icon = isPlaying ? "⏸" : "▶";

        // 1. 更新桌機版按鈕
        const deskBtn = document.getElementById('btn-play');
        if (deskBtn) deskBtn.innerText = text;

        // 2. 更新手機版按鈕
        const mobBtn = document.getElementById('mob-play-btn');
        if (mobBtn) mobBtn.innerText = icon;
    }
	
	// [新增] 播放速度因子 (預設 1.0)
	let currentSpeedFactor = 1.0;

	// --- [修改] changePlaybackSpeed 函式 --
	function changePlaybackSpeed(val) {
		currentSpeedFactor = parseFloat(val);

		// [新增] 同步兩個選單的顯示狀態
		// 這樣無論是用電腦版還是手機版操作，另一邊都會跟著變
		const deskSelect = document.getElementById('speed-select');
		const mobSelect = document.getElementById('mob-speed-select');
		
		if (deskSelect) deskSelect.value = val;
		if (mobSelect) mobSelect.value = val;
	}
	
	// --- [補回遺失的函式] 取得與選取卡片有連結關係的所有卡片 ID (家族樹搜尋) ---
    function getAllLinkedCardIds(state, initialIds) {
        const resultIds = new Set(initialIds);
        
        // 輔助：找某張卡的 Parent (往上找)
        const getParent = (id) => state.cards.find(c => c.id === id);
        
        // 輔助：找某張卡的 Children (往下找)
        const getChildren = (parentId) => state.cards.filter(c => c.parentId === parentId);

        // 對每一個選取的 ID 進行擴散搜尋
        initialIds.forEach(startId => {
            let current = state.cards.find(c => c.id === startId);
            if (!current) return;

            // 1. 向上溯源：找到最頂層/最底層的 Root (沒有 parentId 的那張)
            let root = current;
            while (root.parentId) {
                const p = getParent(root.parentId);
                if (!p) break; // 防呆
                root = p;
            }

            // 2. 向下擴散：從 Root 開始，把所有子孫全部加入
            const stack = [root];
            while (stack.length > 0) {
                const node = stack.pop();
                resultIds.add(node.id);
                
                const children = getChildren(node.id);
                children.forEach(child => stack.push(child));
            }
        });

        return Array.from(resultIds);
    }
	
    function changeLanguage(lang) {
        currentLang = lang;
        const dict = TRANSLATIONS[lang];
        if (!dict) return;

        // 1. 更新一般標籤 (innerText / value)
        document.querySelectorAll('[data-i18n]').forEach(el => {
            const key = el.getAttribute('data-i18n');
            if (dict[key]) {
                if (el.tagName === 'INPUT' && el.type === 'button') {
                    el.value = dict[key];
                } else {
                    // 使用 innerText 會覆蓋掉子元素，若只是純文字替換這最安全
                    // 對於有換行符號 (\n) 的翻譯，可以用 innerText 自動處理換行
                    el.innerText = dict[key]; 
                }
            }
        });
        
        // 2. 更新 Placeholder (輸入框提示)
        document.querySelectorAll('[data-i18n-ph]').forEach(el => {
            const key = el.getAttribute('data-i18n-ph');
            if (dict[key]) {
                el.placeholder = dict[key];
            }
        });

        // 3. 更新 Play 按鈕
        updatePlayButtonUI();

        // 4. 重繪 Timeline (按鈕才會變換語言)
        renderTimeline();
        
        // 5. 其他動態介面更新
        if (isDrafting) updateDraftBar();
        if (isPointing) updatePointInfo();
    }
    
    // 輔助函式：給 JS 內部使用的翻譯
    function t(key) {
        return (TRANSLATIONS[currentLang] && TRANSLATIONS[currentLang][key]) ? TRANSLATIONS[currentLang][key] : key;
    }

    class Card {
        constructor(id, ownerId, text, zone) {
            this.id = id;
            this.ownerId = ownerId;
            this.text = text;
            this.zone = zone;
            this.faceUp = false;
            this.rotation = 0; 
            this.power = 0;
            this.image = null;
            this.isHyper = false;
            this.glow = null; 
            this.parentId = null; 
            this.stackType = null; // top, bottom, shift_up, puzzle_right, etc.
            this.note = "";
            this.imageKey = 'img_' + id;
            this.backImageKey = 'img_back_' + id;
            this.sourceId = null; // New: Link to source card (for Ability cards)
        }
    }
	
	// --- [取代] toggleAceSilent 函式 ---
	function toggleAceSilent(cardId, isAce) {
		if (isAce) {
			globalAceRegistry[cardId] = true;
		} else {
			delete globalAceRegistry[cardId];
		}

		// 只需重繪當前畫面，不用動歷史紀錄
		renderUI(true); 
		if(!document.body.classList.contains('mobile-mode')) saveToStorage();
	}

    class GameState {
        constructor() {
            this.cards = [];
            this.turnPlayer = 1;
            // Removed phase per requirement
            this.globalRotation = false; 
            this.cardIdCounter = 1;
			this.dialogueData = null; // 格式: { p1: {...}, p2: {...} }
			// [新增] BGM 狀態 (null 代表停止/無音樂)
            this.bgm = null;

			// [新增] 無月之門狀態 (存於 State 內)
			// 格式: { cardId: true, ... }
			this.moonless = {};
			// [新增] 猜拳結果 (用於顯示 UI)
			this.rpsResult = null; // { p1: 'rock', p2: 'scissors', winner: 1 }
        }
    }

    class Action {
        constructor(description) {
            this.id = Date.now() + Math.random();
            this.description = description;
            this.operations = []; 
        }
    }

    let history = [];
    let currentIndex = -1;
    let initialState = null;
    let isDrafting = false;
    let draftOperations = []; 
    let insertIndex = -1; 
    let tempState = null; 
    let selectedCardsInModal = []; 
    let pendingMove = null; 
	// [新增] 用於防止長按後自動取消選取的防呆變數
    let ignoreClickId = null;
    let playInterval = null;
    let lastRenderedState = null;
    let editModeType = 'INSERT';
    
    let isPointing = false;
    let pointerId = null;
	let forceNewStep = false;
    let pointTargets = []; 
    let currentStackTargetId = null;
	
	// [新增] 多重選取模式變數
    let isMultiSelectMode = false;
    let multiSelectedIds = [];
	
	let lastAnimatedStep = -1; // [補上這行] 用於記錄動畫狀態，避免重複播放
	let winOverlayTimeout = null; // [新增] 用來記錄勝利畫面的自動關閉計時器
    
    let globalImageRegistry = {}; 
	// [新增] 全域王牌註冊表 (只存 ID，不存卡片物件)
	// 格式: { cardId: true, ... }
	let globalAceRegistry = {};
    let globalAbilityStyleRegistry = {}; 
    let storageQuotaExceeded = false; 
    let hasAlertedQuota = false;    
    let pendingImportData = null;
	let globalLastUsedStyles = {}; // [新增] 用來記錄每張圖片最後一次使用的樣式

    const STORAGE_KEY = 'dm_editor_data_v1'; // Updated Key
    const STORAGE_EXPIRY = 7 * 24 * 60 * 60 * 1000; 

	document.addEventListener('keydown', (e) => {
		// 1. 處理 Ctrl+Z (復原)
		if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {
			if (isDrafting) {
				e.preventDefault();
				undoLastDraftOp();
				return;
			}
		}

		// [新增] 2. 處理 Ctrl+S (儲存此步)
		// 條件：正在編輯(isDrafting) 且 有編輯內容(draftOperations.length > 0)
		if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 's') {
			e.preventDefault(); // 阻止瀏覽器預設的網頁存檔
			if (isDrafting && draftOperations.length > 0) {
				saveDraft(); // 執行儲存
				return;
			}
		}

		// 3. 處理 ESC (取消/關閉視窗)
		if (e.key === 'Escape') {
			const cardModal = document.getElementById('card-selector-modal');
			const posModal = document.getElementById('position-selector-modal');
			const diagModal = document.getElementById('dialogue-modal');
			const setupModal = document.getElementById('setup-modal');

			if (posModal && posModal.style.display === 'flex') closePositionModal();
			else if (cardModal && cardModal.style.display === 'flex') closeSelectorModal();
			else if (diagModal && diagModal.style.display === 'flex') diagModal.style.display = 'none';
			else if (setupModal && setupModal.style.display === 'flex') setupModal.style.display = 'none';
			else if (isPointing) cancelPointMode();
			else cancelSelection();
		}
	});

	// [新增] 抽牌功能函式
	function actionDrawCard() {
		// 1. 取得當前狀態與回合玩家
		const state = getCurrentDisplayState();
		const pid = state.turnPlayer; // 1 或 2
		
		// 2. 定義來源(牌庫)與目標(手牌)
		const deckId = `p${pid}-deck`;
		const handId = `p${pid}-hand`;

		// 3. 檢查牌庫是否有牌
		// 注意：filter 出來的陣列順序，最後一張 (length-1) 通常視為牌庫頂 (Top)
		const deckCards = state.cards.filter(c => c.zone === deckId);
		
		if (deckCards.length === 0) {
			alert(pid === 1 ? "P1 牌庫已空 (Empty Deck)！" : "P2 牌庫已空 (Empty Deck)！");
			return;
		}

		// 4. 取出牌庫頂的一張牌
		const topCard = deckCards[deckCards.length - 1];

		// 5. 如果目前不在編輯模式，自動開啟新步驟 (讓這個動作被記錄)
		if (!isDrafting) startDraftAtEnd();

		// 6. 執行移動動作 (使用 MOVE 類型)
		addOperation({
			type: 'MOVE',
			cardIds: [topCard.id],
			toZone: handId,
			faceUp: true, // 手牌對玩家來說是可見的
			shuffleSelection: false
		});
	}
	
	document.addEventListener('keydown', (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {
            if (isDrafting) {
                e.preventDefault(); 
                undoLastDraftOp();
                return;
            }
        }
        if (e.key === 'Escape') {
            const cardModal = document.getElementById('card-selector-modal');
            const posModal = document.getElementById('position-selector-modal');
            const diagModal = document.getElementById('dialogue-modal');
            const setupModal = document.getElementById('setup-modal'); // [新增]
            
            if (posModal && posModal.style.display === 'flex') closePositionModal();
            else if (cardModal && cardModal.style.display === 'flex') closeSelectorModal();
            else if (diagModal && diagModal.style.display === 'flex') diagModal.style.display = 'none';
            else if (setupModal && setupModal.style.display === 'flex') setupModal.style.display = 'none'; // [新增]
            else if (isPointing) cancelPointMode();
            else cancelSelection();
        }
    });
    
    function pasteImageMode() {
        if (!pendingMove || pendingMove.cardIds.length !== 1) {
            alert("請先選擇一張卡片，然後按下 Ctrl+V 貼上圖片");
            return;
        }
        window.focus();
    }
    
    // --- [修改] 圖片處理 (畫質提升至 200x280) ---
	function processImage(dataUrl, targetId = null) {
		const img = new Image();
		img.onload = () => {
			const canvas = document.createElement('canvas');
			const ctx = canvas.getContext('2d');
			
			// [修改 1] 解析度提升 (原本 100x140 -> 200x280)
			// 這樣在手機版放大時依然清晰
			const targetW = 200;
			const targetH = 280;
			
			canvas.width = targetW;
			canvas.height = targetH;
			
			ctx.fillStyle = "#fff"; 
			ctx.fillRect(0, 0, targetW, targetH);
			ctx.drawImage(img, 0, 0, targetW, targetH);
			
			// 使用 0.85 品質壓縮，取得平衡
			const compressedBase64 = canvas.toDataURL('image/jpeg', 0.85);
			
			const idToUse = targetId || (pendingMove ? pendingMove.cardIds[0] : null);
			
			if (idToUse) {
				updateCardImageGlobal(idToUse, compressedBase64);
			}
		};
		img.src = dataUrl;
	}
    
	// --- [新增] 垃圾回收輔助：找出所有正在使用的圖片 Key ---
	function getUsedImageKeys() {
		const used = new Set();
		
		const scanState = (s) => {
			if (!s || !s.cards) return;
			s.cards.forEach(c => {
				if (c.imageKey) used.add(c.imageKey);
				if (c.backImageKey) used.add(c.backImageKey);
				// 也保留舊版樣式 Key (如果有的話)
				if (c.styleKey) used.add(c.styleKey); 
			});
			
			// 也要掃描對話系統用到的頭像 Key (格式 avatar_xxx)
			if (s.dialogueData) {
				['p1', 'p2'].forEach(p => {
					if (s.dialogueData[p] && s.dialogueData[p].emotion) {
						used.add(`avatar_${p}_${s.dialogueData[p].emotion}`);
					}
				});
			}
		};

		scanState(initialState);
		history.forEach(h => {
			scanState(h.state);
			if (h.detachedStartState) scanState(h.detachedStartState);
		});
		if (tempState) scanState(tempState);

		// 額外保留所有對話系統的預設頭像 (避免對話編輯器開起來沒圖)
		Object.keys(globalImageRegistry).forEach(k => {
			if (k.startsWith('avatar_')) used.add(k);
		});

		return used;
	}

	// --- [修改] 全域圖片更新 (含去重複化與引用更新) ---
	function updateCardImageGlobal(cardId, base64) {
		const state = getCurrentDisplayState();
		const targetCard = state.cards.find(c => c.id === cardId);
		if(!targetCard) return;

		// 1. [去重複化] 檢查這張圖片是否已經存在於圖庫中
		let finalKey = null;
		
		// 遍歷目前的圖庫尋找相同內容
		for (const [key, value] of Object.entries(globalImageRegistry)) {
			if (value === base64) {
				finalKey = key; // 找到了一模一樣的圖！直接借用它的 Key
				break;
			}
		}

		// 2. 如果沒找到，生成一個全新的 Key (不再綁定卡片 ID，改用時間戳+亂數)
		if (!finalKey) {
			// 使用 img_時間戳_亂數，確保唯一性
			finalKey = `img_${Date.now()}_${Math.floor(Math.random() * 10000)}`;
			// 寫入圖庫
			globalImageRegistry[finalKey] = base64;
		}

		// 3. 更新目標卡片的 Reference (指向 finalKey)
		// 注意：原本的邏輯是綁定 img_CardID，現在我們改變卡片本身的 imageKey 屬性
		
		// 判斷是要更新正面還是背面 (超次元背面)
		const isUpdatingBack = (targetCard.isHyper && !targetCard.faceUp);

		// 定義更新函式：走訪所有歷史紀錄，把這張卡(ID相同)的 key 更新
		const updateCardRef = (s) => {
			// 找出所有 ID 相同的卡片實例 (包含分身)
			s.cards.forEach(c => {
				if (c.id === cardId) {
					if (isUpdatingBack) {
						c.backImageKey = finalKey;
					} else {
						c.imageKey = finalKey;
						c.image = true; // 標記有圖
					}
				}
				// 同步更新：如果場上有其他卡片原本就跟這張卡共用舊圖片，
				// 且我們確定要把所有「長得像這張卡」的都換掉，可以在這裡處理。
				// 但為了安全起見，我們目前只更新 ID 吻合的卡片。
			});
		};
		
		updateCardRef(initialState);
		history.forEach(h => updateCardRef(h.state));
		if (tempState) updateCardRef(tempState);
		
		// 4. 觸發存檔與重繪
		renderUI();
		saveToStorage(); // saveToStorage 內會執行垃圾回收 (GC)，自動清理沒人用的舊圖

		// [UI 刷新邏輯維持不變]
		const selectorModal = document.getElementById('card-selector-modal');
		if (selectorModal && selectorModal.style.display === 'flex') {
			const zoneId = document.getElementById('modal-title').getAttribute('data-zone-id');
			if (zoneId) {
				openSelectorModal(zoneId);
				return;
			}
		}

		if (!isDrafting || draftOperations.length === 0) {
			cancelSelection();
		}
	}
    
    function removeImage() {
        if (!pendingMove || pendingMove.cardIds.length !== 1) return;
        const cardId = pendingMove.cardIds[0];
        const state = getCurrentDisplayState();
        const card = state.cards.find(c => c.id === cardId);
        if(!card) return;

        if (!card.imageKey) {
            card.imageKey = 'img_' + card.id;
            card.backImageKey = 'img_back_' + card.id;
        }

        let keyToUpdate = card.imageKey;
        if (card.isHyper && !card.faceUp) {
             keyToUpdate = card.backImageKey;
        }
        
        if(!confirm(t('msg_remove_img'))) return;
        
        delete globalImageRegistry[keyToUpdate];

        const unsetFlag = (s) => {
            const c = s.cards.find(x => x.id === cardId);
            if(c) c.image = false;
            
            s.cards.forEach(other => {
                if (other.imageKey === keyToUpdate || other.backImageKey === keyToUpdate) {
                    other.image = false;
                }
            });
        };

        unsetFlag(initialState);
        history.forEach(h => unsetFlag(h.state));
        if (tempState) unsetFlag(tempState);

        saveToStorage();
        renderUI();
    }

    function cloneState(state) {
        return JSON.parse(JSON.stringify(state));
    }

    function openSetupModal() {
        const modal = document.getElementById('setup-modal');
        if(modal) modal.style.display = 'flex';
    }

    function clearStorage(silent = false) {
        if(!silent && !confirm(t('msg_confirm_clear_storage'))) return;
        
        localStorage.removeItem(STORAGE_KEY_CORE);
        localStorage.removeItem(STORAGE_KEY_CARDS);
        localStorage.removeItem(STORAGE_KEY_PORTRAITS);
        localStorage.removeItem(STORAGE_KEY_LEGACY); // 也清一下舊的
        
        if (!silent) {
            alert(t('msg_cleared'));
            location.reload();
        }
    }
    
    function deleteAllActions() {
        if(!confirm(t('msg_confirm_delete_all'))) return;
        
        history = [];
        initialState = null;
        currentIndex = -1;
        draftOperations = [];
        isDrafting = false;
        
        // 清除所有存檔
        localStorage.removeItem(STORAGE_KEY_CORE);
        localStorage.removeItem(STORAGE_KEY_CARDS);
        localStorage.removeItem(STORAGE_KEY_PORTRAITS);
        localStorage.removeItem(STORAGE_KEY_LEGACY);
        
        storageQuotaExceeded = false;
        hasAlertedQuota = false;

        document.getElementById('action-list').innerHTML = '';
        document.getElementById('step-counter').innerText = '0/0';
        updateDraftBar();
        
        openSetupModal();
    }

    function finishSetup() {
        try {
            const getVal = (id, def) => {
                const el = document.getElementById(id);
                if(!el) return def;
                const val = parseInt(el.value);
                return isNaN(val) ? def : val;
            };

            const p1d = getVal('setup-p1-deck', 40);
            const p1h = getVal('setup-p1-hyper', 8);
            const p2d = getVal('setup-p2-deck', 40);
            const p2h = getVal('setup-p2-hyper', 8);
            
            initGame({p1d, p1h, p2d, p2h});
            document.getElementById('setup-modal').style.display = 'none';
        } catch (e) {
            console.error(e);
            alert(t('msg_init_fail') + e.message)
        }
    }

    function initGame(config) {
        const state = new GameState();
        globalImageRegistry = {}; 
        globalAbilityStyleRegistry = {};
		globalLastUsedStyles = {}; // [新增] 重置記憶
        globalAceRegistry = {}; // [修正] 確保新開局時清空王牌設定
        
        if(!config) config = {p1d:40, p1h:8, p2d:40, p2h:8};

        const zones = [
            {id: 'p1-deck', count: config.p1d, prefix: 'C'}, {id: 'p1-hyper', count: config.p1h, prefix: 'H', hyper:true},
            {id: 'p2-deck', count: config.p2d, prefix: 'C'}, {id: 'p2-hyper', count: config.p2h, prefix: 'H', hyper:true}
        ];
        
        state.cards = []; 
        
        zones.forEach(z => {
            for(let i=0; i<z.count; i++) {
                let c = new Card(state.cardIdCounter++, z.id.startsWith('p1')?1:2, `${z.prefix}-${i+1}`, z.id);
                if(z.hyper) { c.isHyper=true; c.faceUp=true; }
                state.cards.push(c);
            }
        });

        initialState = cloneState(state);
        history = [];
        let initAct = new Action('遊戲開始');
        initAct.operations.push({type: 'INIT'});
        history.push({ action: initAct, state: initialState });
        currentIndex = 0;

        isDrafting = false;
        draftOperations = [];
        updateDraftBar();
        renderUI();
        saveToStorage();
    }

	// 修改原有的 STORAGE_KEY 定義
    const STORAGE_KEY_CORE = 'dm_editor_data_v1_core';           // 核心：歷史紀錄、狀態
    const STORAGE_KEY_CARDS = 'dm_editor_data_v1_card_imgs';     // 圖片：卡片圖
    const STORAGE_KEY_PORTRAITS = 'dm_editor_data_v1_portraits'; // 圖片：對話頭像
    
    // 為了相容舊版，保留舊 Key 的參考
    const STORAGE_KEY_LEGACY = 'dm_editor_data_v1';
	
	function saveToStorage() {
        if (document.body.classList.contains('mobile-mode')) return;

        try {
            // 1. 準備核心資料 (不含圖片)
            // 修改為：
			const leanHistory = history.map((item, index) => {
				if (index === 0) return item; 
				
				// 建立精簡物件
				const leanItem = { action: item.action };
				
				// [關鍵] 如果這個步驟有紀錄「斷層起點 (detachedStartState)」，必須存下來！
				// 這樣重新整理網頁後，A5 才會記得它要接在舊的 A4 後面
				if (item.detachedStartState) {
					leanItem.detachedStartState = item.detachedStartState;
				}
				
				return leanItem;
			});

            // 在 saveToStorage 函式內，準備 coreData 物件時：
			const coreData = {
				timestamp: Date.now(),
				history: leanHistory,
				initialState: initialState,
				currentIndex: currentIndex,
				abilityRegistry: globalAbilityStyleRegistry,
				lastUsedStyles: globalLastUsedStyles, // [新增] 存檔
				lastDiagSettings: (typeof lastDiagSettings !== 'undefined') ? lastDiagSettings : null,
				aceRegistry: globalAceRegistry, // [新增]
			};

			// 2. [修改] 垃圾回收 (GC) 與 拆分圖片資料
            const usedKeys = getUsedImageKeys(); // 取得所有有在用的 Key
			
            const cardImages = {};
            const portraitImages = {};

            Object.keys(globalImageRegistry).forEach(key => {
                // 只儲存有被用到的 Key，或是頭像
                if (usedKeys.has(key)) {
                    if (key.startsWith('avatar_')) {
                        portraitImages[key] = globalImageRegistry[key];
                    } else {
                        cardImages[key] = globalImageRegistry[key];
                    }
                }
            });

            // 3. 分開寫入
            localStorage.setItem(STORAGE_KEY_CORE, JSON.stringify(coreData));
            
            // 這裡可以選擇性優化：如果圖片沒變動其實不用一直寫入，但為了保險先每次都寫
            localStorage.setItem(STORAGE_KEY_CARDS, JSON.stringify(cardImages));
            localStorage.setItem(STORAGE_KEY_PORTRAITS, JSON.stringify(portraitImages));

            // 清除舊版 Key 以釋放空間 (如果是從舊版遷移過來的)
            localStorage.removeItem(STORAGE_KEY_LEGACY);
            
            if (storageQuotaExceeded) {
                storageQuotaExceeded = false;
                hasAlertedQuota = false;
            }
        } catch(e) {
            console.warn("Storage save failed (Quota?)", e);
            storageQuotaExceeded = true;
            if (!hasAlertedQuota) {
                alert(t('msg_storage_full'));
                hasAlertedQuota = true;
            }
        }
    }

    function loadFromStorage() {
        // --- 階段 0: 檢查是否有新版結構 ---
        const coreRaw = localStorage.getItem(STORAGE_KEY_CORE);
        
        // 如果沒有新版資料，嘗試讀取舊版 (Migration)
        if (!coreRaw) {
            return loadFromLegacyStorage();
        }

        try {
            // --- 階段 1: 優先讀取核心邏輯 (最快，無圖片 I/O) ---
            const data = JSON.parse(coreRaw);
            
            // 檢查過期
            if (data.timestamp && (Date.now() - data.timestamp > STORAGE_EXPIRY)) {
                clearStorage(true); // 傳入 true 表示安靜清除，不 reload
                return false;
            }

            // 初始化設定
            globalImageRegistry = {}; 
            globalAbilityStyleRegistry = data.abilityRegistry || {};
            globalLastUsedStyles = data.lastUsedStyles || {};
            if (data.lastDiagSettings && typeof lastDiagSettings !== 'undefined') {
                lastDiagSettings = data.lastDiagSettings;
            }
            
            globalAceRegistry = data.aceRegistry || {};
            
            // [修改] 移除 globalMoonlessRegistry 賦值，改為遷移邏輯
            // 如果存檔中有舊版的無月資料，將其移轉至 initialState
            if (data.moonlessRegistry) {
                if (!data.initialState.moonless) data.initialState.moonless = {};
                Object.assign(data.initialState.moonless, data.moonlessRegistry);
            }

            // 重建狀態 (Replay Logic)
            initialState = data.initialState;
            // 防呆：確保 initialState 有 moonless 屬性 (避免舊存檔是 undefined)
            if (!initialState.moonless) initialState.moonless = {};

			// [建議新增] 確保舊存檔也有 rpsResult 欄位 (雖然 undefined 也不會報錯，但這樣比較乾淨)
            if (initialState.rpsResult === undefined) initialState.rpsResult = null;
			
            let loadedHistory = data.history;
            if (!loadedHistory[0].state) loadedHistory[0].state = cloneState(initialState);
            
            for (let i = 1; i < loadedHistory.length; i++) {
                if (!loadedHistory[i].state) {
                    const prevState = loadedHistory[i-1].state;
                    const newState = cloneState(prevState);
                    const ops = loadedHistory[i].action.operations;
                    ops.forEach(op => applyOperation(newState, op));
                    loadedHistory[i].state = newState;
                }
            }
            
            history = loadedHistory;
            currentIndex = (typeof data.currentIndex === 'number' && data.currentIndex >= -1 && data.currentIndex < history.length) 
                           ? data.currentIndex 
                           : (history.length - 1);
            
            // **關鍵點 1**: 馬上渲染 UI (此時是純文字版，使用者可以看到盤面了)
            try { renderUI(); } catch(e) { console.error(e); }

            // --- 階段 2: 延遲讀取卡片圖片 ---
            setTimeout(() => {
                const cardsRaw = localStorage.getItem(STORAGE_KEY_CARDS);
                if (cardsRaw) {
                    try {
                        const cardImgs = JSON.parse(cardsRaw);
                        Object.assign(globalImageRegistry, cardImgs);
                        
                        // **關鍵點 2**: 圖片載入完成，重新渲染 (圖片彈出)
                        renderUI(); 
                    } catch(e) { console.error("Error loading card images", e); }
                }

                // --- 階段 3: 最後讀取對話頭像 (優先級最低) ---
                setTimeout(() => {
                    const portRaw = localStorage.getItem(STORAGE_KEY_PORTRAITS);
                    if (portRaw) {
                        try {
                            const portImgs = JSON.parse(portRaw);
                            Object.assign(globalImageRegistry, portImgs);
                            
                            // 確保預設頭像存在 (若存檔中缺少某些表情)
                            if (typeof generateDefaultPortraits === 'function') {
                                generateDefaultPortraits();
                            }
                            // 不需要再次全盤 renderUI，除非當前正好開著對話框
                            // 但為了保險起見，可以再刷一次，或是只更新對話相關 DOM
                        } catch(e) { console.error("Error loading portraits", e); }
                    } else {
                        // 如果沒存檔，也要生成預設頭像
                        if (typeof generateDefaultPortraits === 'function') {
                            generateDefaultPortraits();
                        }
                    }
                }, 50); // 給瀏覽器一點喘息時間
                
            }, 50); // 給瀏覽器一點喘息時間

            return true;

        } catch (e) {
            console.error("Load failed", e);
            return false;
        }
    }

    // 輔助函式：舊版相容讀取
    function loadFromLegacyStorage() {
        const raw = localStorage.getItem(STORAGE_KEY_LEGACY);
        if (!raw) return false;
        
        try {
            const data = JSON.parse(raw);
            // ... (使用原本的解析邏輯) ...
            globalImageRegistry = data.imageRegistry || {};
            globalAbilityStyleRegistry = data.abilityRegistry || {};
            initialState = data.initialState;
            // ... Replay logic ...
            let loadedHistory = data.history;
            if (!loadedHistory[0].state) loadedHistory[0].state = cloneState(initialState);
            for (let i = 1; i < loadedHistory.length; i++) {
                if (!loadedHistory[i].state) {
                    const prevState = loadedHistory[i-1].state;
                    const newState = cloneState(prevState);
                    const ops = loadedHistory[i].action.operations;
                    ops.forEach(op => applyOperation(newState, op));
                    loadedHistory[i].state = newState;
                }
            }
            history = loadedHistory;
            currentIndex = data.currentIndex || (history.length - 1);
            
            if (typeof generateDefaultPortraits === 'function') generateDefaultPortraits();
            renderUI();
            
            // **關鍵**: 讀取成功後，馬上存成新格式，下次就會快了
            saveToStorage(); 
            return true;
        } catch(e) {
            return false;
        }
    }

    function getCurrentDisplayState() {
        return isDrafting ? tempState : ((currentIndex >= 0 && currentIndex < history.length) ? history[currentIndex].state : initialState);
    }

    function startDraftAtEnd() {
        startDraft(history.length);
    }

	function startDraft(index) {
		if (isDrafting) {
			if(!confirm(t('msg_unsaved_draft'))) return;
				document.getElementById('action-list').classList.remove('locked');
		}
		
		isDrafting = true;
		insertIndex = index;
		draftOperations = [];
		editModeType = 'INSERT';
		
		let baseIndex = index - 1;
		if (baseIndex < 0) baseIndex = 0; 
		
		// 複製上一步驟的狀態
		tempState = cloneState(history[baseIndex].state);

		// --- [修改] 清除殘留狀態邏輯 ---
		// 2. 清除對話狀態 (維持原樣)
		tempState.dialogueData = null; // 清除對話
		tempState.rpsResult = null;    // [新增] 清除猜拳結果
		
		// ---------------------------
		
		updateDraftBar();
		renderUI();

		const list = document.getElementById('action-list');
		const placeholder = document.getElementById('active-placeholder');
		
		if (placeholder) {
			// 使用 behavior: 'smooth' 可能會比較舒適，但 auto 較快
			placeholder.scrollIntoView({ block: "center", behavior: "auto" });
			setTimeout(() => {
				list.classList.add('locked');
			}, 50);
		}
	}

    function editAction(index) {
        if (isDrafting) {
            if(!confirm(t('msg_unsaved_edit'))) return;
            // 如果原本鎖定，先解鎖
            document.getElementById('action-list').classList.remove('locked');
        }
        
        isDrafting = true;
        insertIndex = index; 
        editModeType = 'EDIT';
        
        // 判斷是否要使用「斷層存檔」
		// 如果當前步驟 (Action 5) 有紀錄 detachedStartState，就用它當作編輯的起點
		if (history[index].detachedStartState) {
			console.log("發現斷層存檔，載入舊的時間軸狀態...");
			tempState = cloneState(history[index].detachedStartState);
		} 
		else {
			// 否則走原本的邏輯 (找上一步的結果)
			let baseIndex = index - 1;
			if (baseIndex < 0) {
				tempState = cloneState(initialState);
			} else {
				tempState = cloneState(history[baseIndex].state);
			}
		}
        
        tempState.dialogueData = null; // 清除對話
		tempState.rpsResult = null;    // [新增] 清除猜拳結果 (除非 Action 本身就是 RPS，那下面 applyOperation 會補回來，但這時 renderUI 的 !isDrafting 會擋住它)
        // ---------------------------------------------------

        const actionToEdit = history[index].action;
        
        // 使用深拷貝，避免直接修改到歷史紀錄 (直到按下儲存)
        draftOperations = JSON.parse(JSON.stringify(actionToEdit.operations));
        
        draftOperations.forEach(op => applyOperation(tempState, op));
        
        updateDraftBar();
        renderUI();

        // --- [新增] 自動開啟對話編輯視窗 ---
        const isDialogue = draftOperations.some(op => op.type === 'DIALOGUE');
        if (isDialogue) {
            openDialogueModal();
        }
        // --------------------------------

        // --- [同步修正] 鎖定 Scrollbar ---
        const list = document.getElementById('action-list');
        const placeholder = document.getElementById('active-placeholder');
        
        if (placeholder) {
            placeholder.scrollIntoView({ block: "center", behavior: "auto" });
            setTimeout(() => {
                list.classList.add('locked');
            }, 50);
        }
    }

    function addOperation(op) {
        // --- 新增：互斥鎖邏輯 ---
        const hasDialog = draftOperations.some(o => o.type === 'DIALOGUE');
        
        // 1. 如果已存在對話，禁止加入其他動作 (如移動卡片)
        if (hasDialog && op.type !== 'DIALOGUE') {
            alert(t('對話動作必須獨立，無法與其他動作混合 (請另開新步驟)。'));
            return;
        }
        
        // 2. 如果已存在其他動作，禁止加入對話
        if (!hasDialog && draftOperations.length > 0 && op.type === 'DIALOGUE') {
            alert(t('對話動作必須獨立，無法與其他動作混合 (請另開新步驟)。'));
            return;
        }
        // --- 結束 ---

        // [修改] 自動判斷編輯模式
        if (!isDrafting) {
            // 檢查是否在歷史紀錄範圍內
            if (currentIndex >= 0 && currentIndex < history.length) {
                
                // [關鍵修改] 判斷邏輯分流
                // 1. 如果是在最後一步，且旗標為 true (剛存檔完) -> 新增步驟
                if (currentIndex === history.length - 1 && forceNewStep) {
                    startDraftAtEnd();
                } 
                // 2. 否則 (剛點擊過列表，或是還在中間步驟) -> 編輯當前步驟
                else {
                    editAction(currentIndex);
                }

            } else {
                // 例外狀況 -> 新增步驟
                startDraftAtEnd();
            }
        }
        
        applyOperation(tempState, op);
        draftOperations.push(op);
        updateDraftBar();
        renderUI();
    }

	// --- 新增功能: 還原上一步 (Ctrl+Z) ---
    function undoLastDraftOp() {
        if (!isDrafting) return;
        if (draftOperations.length === 0) return;

        // 1. 移除 Draft 中的最後一個操作
        draftOperations.pop();

        // 2. 重新計算 tempState
        // 必須從 Draft 開始前的狀態 (Base State) 重新套用剩餘的操作
        let baseIndex = insertIndex - 1;
        let baseState;
        
        if (baseIndex < 0) {
            baseState = cloneState(initialState);
        } else {
            // 取出進入編輯模式前的狀態快照
            baseState = cloneState(history[baseIndex].state);
        }

        // 重置 tempState 為初始狀態
        tempState = baseState;

        // 依序重新執行剩餘的所有操作
        draftOperations.forEach(op => applyOperation(tempState, op));

        // 3. 更新介面
        updateDraftBar();
        renderUI();
        
        // 若剛好還原了移動操作，取消目前的選取狀態以避免 UI 錯亂
        cancelSelection(); 
    }
	
    function saveDraft(customDesc) {
        if (draftOperations.length === 0) {
            isDrafting = false;
            updateDraftBar();
            
            // 解鎖 Scrollbar
            document.getElementById('action-list').classList.remove('locked');
            
            renderUI();
            return;
        }

        let desc = customDesc;
        if (!desc && editModeType === 'EDIT' && insertIndex < history.length) {
             desc = history[insertIndex].action.description;
        }
        if (!desc) {
            const opCount = draftOperations.length;
            const firstOp = draftOperations[0];
            let typeDesc = t('op_' + firstOp.type);
            if (!typeDesc || typeDesc === ('op_' + firstOp.type)) {
                typeDesc = t('op_default'); 
            }
            if (firstOp.type === 'POINT') {
                desc = firstOp.desc || t('op_POINT');
            } else if (firstOp.type === 'ATTACK') {
                desc = firstOp.desc || t('op_ATTACK');
            } else if (firstOp.type === 'DIALOGUE') {
                // 對話動作的預設描述 (如果沒傳入 customDesc)
                const data = firstOp.data;
                desc = "[對話] ";
                if (data.p2 && data.p2.active) desc += `${data.p2.name}... `;
                if (data.p1 && data.p1.active) desc += `${data.p1.name}...`;
            } else {
                desc = `${typeDesc} ${t('lbl_draft_ops_prefix') || ''} ${opCount} ${t('op_count_suffix')}`;
            }
        }

        const newAction = new Action(desc);
        newAction.operations = [...draftOperations];
        const finalState = cloneState(tempState);
        const newItem = { action: newAction, state: finalState };

        const propagate = document.getElementById('propagate-check').checked;

        const head = history.slice(0, insertIndex);
        let tail = [];
        
        if (editModeType === 'EDIT') {
            tail = history.slice(insertIndex + 1);
        } else {
            tail = history.slice(insertIndex);
        }

        if (propagate) {
			// [情境 A：開啟連動] 
			// 1. 既然要連動，代表後續步驟應該要「認祖歸宗」，接上新的 A4'
			// 2. 所以如果 tail[0] (A5) 身上有「斷層存檔」，要把它刪掉
			if (tail.length > 0 && tail[0].detachedStartState) {
				delete tail[0].detachedStartState;
			}

			let runningState = cloneState(finalState);
			tail = tail.map(item => {
				// 連動時也要順便把後續步驟身上的斷層存檔都清乾淨，確保整條線重算
				if (item.detachedStartState) delete item.detachedStartState;
				
				try {
					item.action.operations.forEach(op => applyOperation(runningState, op));
				} catch(e) { console.error("Propagate Error", e); }
				return { action: item.action, state: cloneState(runningState) };
			});
		} 
		else {
			// [情境 B：不連動 (製造斷層)]
			// 如果還有下一步 (例如修改 A4，後面還有 A5)
			if (tail.length > 0) {
				// 我們要把「原本 A4 的結果」存給 A5 當作它的「私房起點」
				// 只有當 A5 還沒有私房起點時才存 (避免連續修改 A4 時覆蓋掉最早的狀態)
				
				// 注意：editModeType === 'EDIT' 時，history[insertIndex] 還是舊的 A4
				if (editModeType === 'EDIT' && !tail[0].detachedStartState) {
					// 把舊的 A4 結果狀態複製一份給 A5
					tail[0].detachedStartState = cloneState(history[insertIndex].state);
					console.log("已建立時間軸斷層快照，A5 將不受 A4' 影響");
				}
			}
		}

        history = [...head, newItem, ...tail];

        isDrafting = false;
        currentIndex = insertIndex; 
        insertIndex = -1;
        draftOperations = [];
        updateDraftBar();
        renderUI();
        
        // 這裡就是關鍵的存檔機制
        saveToStorage(); 
        
        // 解鎖 Scrollbar
        document.getElementById('action-list').classList.remove('locked');
		
		// [新增] 存檔後的狀態判斷
        // 如果剛剛存檔的是「最新的最後一步」，則將旗標設為 true
        // 這樣使用者的下一個動作就會自動變成「新增步驟」
        if (currentIndex === history.length - 1) {
            forceNewStep = true;
        } else {
            forceNewStep = false;
        }
    }

    function cancelDraft() {
        isDrafting = false;
        draftOperations = [];
        cancelSelection();
        updateDraftBar();
        if(currentIndex >= history.length) currentIndex = history.length - 1;
		// --- 新增：解鎖 Scrollbar ---
        document.getElementById('action-list').classList.remove('locked');
        renderUI();
    }

    function updateDraftBar() {
        const bar = document.getElementById('draft-bar');
        const hintEl = document.getElementById('draft-mode-hint');

        if (isDrafting) {
            bar.style.display = 'flex';
            
            // --- [新增] 狀態文字判斷邏輯 ---
            let hintText = "";
            if (editModeType === 'EDIT') {
                // 編輯模式：直接顯示當前 index
                hintText = t('msg_editing_step').replace('{n}', insertIndex);
            } else {
                // 新增模式：顯示插在誰後面 (index - 1)
                // 如果 insertIndex 為 0 (極少見)，顯示 "Start" 或 0
                const prevIndex = insertIndex > 0 ? (insertIndex - 1) : 0;
                hintText = t('msg_insert_after').replace('{n}', prevIndex);
            }
            if (hintEl) hintEl.innerText = hintText;
            // -----------------------------

            // 使用 t() 翻譯按鈕 (維持原有邏輯)
            const saveBtn = bar.querySelector('.primary');
            const cancelBtn = bar.querySelector('.danger');
            
            if (saveBtn) saveBtn.innerText = t('btn_save_step');
            if (cancelBtn) cancelBtn.innerText = t('btn_cancel_draft');
            document.getElementById('draft-count').innerText = draftOperations.length;
        } else {
            bar.style.display = 'none';
        }
    }

    // --- [取代] deleteAction 函式 (強化版) ---
	function deleteAction(index) {
		// 1. 安全檢查：編輯中禁止刪除
		if (typeof isDrafting !== 'undefined' && isDrafting) {
			alert("請先完成或取消目前的編輯動作 (Draft)，才能刪除步驟。");
			return;
		}

		if (index === 0) return alert(t('msg_cannot_del_init'));
		if (!confirm(t('msg_confirm_del_step'))) return;

		// 2. 切割陣列
		const head = history.slice(0, index);
		let tail = history.slice(index + 1);

		// [關鍵修正 A] 清除斷層快照
		// 因為 index 被刪除了，index+1 (現在的 tail[0]) 的快照是基於舊歷史的，必須作廢
		if (tail.length > 0) {
			if (tail[0].detachedStartState) {
				console.log("偵測到刪除操作，清除後續動作的斷層快照以避免殘留...");
				delete tail[0].detachedStartState;
			}
		}

		// [關鍵修正 B] 強制重算後續狀態 (Propagate)
		// 刪除中間一步後，後面的盤面狀態(State)其實都髒掉了，必須重算一遍
		// 否則記憶體裡的 State 還是舊的，直到下次編輯才會更新
		if (tail.length > 0) {
			// 取得新的基礎狀態 (來自 head 的最後一步)
			let runningState = cloneState(head[head.length - 1].state);
			
			tail = tail.map(item => {
				// 清除所有後續的快照，確保連動正確
				if (item.detachedStartState) delete item.detachedStartState;
				
				try {
					// 重新運算動作
					item.action.operations.forEach(op => applyOperation(runningState, op));
				} catch(e) { console.error("Recalc Error after delete", e); }
				
				// 更新狀態
				return { action: item.action, state: cloneState(runningState) };
			});
		}

		// 3. 組合新的歷史紀錄
		history = [...head, ...tail];

		// 4. UI 更新
		lastRenderedState = null; 
		
		// 強制將焦點設為被刪除者的「上一步」
		currentIndex = index - 1;
		if (currentIndex < 0) currentIndex = 0;
		
		if (typeof cancelSelection === 'function') cancelSelection(); 
		
		renderUI(true);
		saveToStorage();
	}

	function applyOperation(state, op) {
	
		// [新增] 每次操作前，預設清除上一步的猜拳結果 (除非這一步就是猜拳)
		// 這樣才不會讓猜拳圖示一直留在畫面上
		if (op.type !== 'RPS') {
			state.rpsResult = null;
		}

		// [修改] 如果不是對話動作，清除對話資料 (讓畫面消失)
		if (op.type !== 'DIALOGUE') {
			state.dialogueData = null;
		}
		
		if (op.type === 'PASS') return;

		// [新增] 對話處理
		if (op.type === 'DIALOGUE') {
			state.dialogueData = op.data; // 直接套用資料
			return; // 對話不涉及其他邏輯
		}
		
		// [新增] 處理無月之門切換
		if (op.type === 'TOGGLE_MOONLESS') {
            const { cardIds } = op;
            // 防呆初始化 (避免舊存檔沒有這個屬性)
            if (!state.moonless) state.moonless = {};
            
            cardIds.forEach(id => {
                if (state.moonless[id]) {
                    delete state.moonless[id];
                } else {
                    state.moonless[id] = true;
                }
            });
        }
		// [新增] 處理猜拳
		if (op.type === 'RPS') {
			state.rpsResult = op.data;
		}
		// --- 新增: 用於切斷連結的操作 ---
		if (op.type === 'BREAK_LINKS') {
			const { cardIds } = op;
			state.cards.forEach(c => {
				// [修正] 改用 some + == (寬鬆比對)，解決 1 與 "1" 不相等的問題
				if (cardIds.some(id => id == c.id)) { 
					c.parentId = null;
					c.stackType = null;
				}
				if (c.parentId && cardIds.some(id => id == c.parentId)) { 
					c.parentId = null;
					c.stackType = null;
				}
			});
		}
		// --- [新增] 勝利狀態 ---
		else if (op.type === 'GAME_WIN') {
			const { winnerId } = op;
			state.winner = winnerId;
		}
		// ----------------------
		else if (op.type === 'MOVE') {
			const { cardIds, toZone, faceUp, shuffleSelection, insertIndex, stackTargetId, stackType } = op;
			
            // 1. 先從狀態中找出這些卡片 (此時順序是依照原本 state 中的順序，不一定是我們想要的)
			let movingCards = state.cards.filter(c => cardIds.some(id => id == c.id));
			
            // [關鍵修正] 2. 依照 cardIds (指令中的順序) 對 movingCards 進行重排
            // 這樣才能確保「左上(第一張)」就是使用者「選的第一張」(或是牌庫的最上方)
            if (shuffleSelection) {
                movingCards.sort(() => Math.random() - 0.5); 
            } else {
                movingCards.sort((a, b) => {
                    // 使用 findIndex 確保能比對字串與數字 ID
                    const idxA = cardIds.findIndex(id => id == a.id);
                    const idxB = cardIds.findIndex(id => id == b.id);
                    return idxA - idxB;
                });
            }
			
            // 3. 從原區域移除
			state.cards = state.cards.filter(c => !cardIds.some(id => id == c.id)); 
			
            // 4. 設定新屬性
			movingCards.forEach(c => {
				c.zone = toZone;
				c.parentId = null;
				c.stackType = null;
				if (faceUp !== undefined) c.faceUp = faceUp;
				if (toZone.includes('hand')) c.rotation = 0; 
				if (stackTargetId) {
					c.parentId = stackTargetId;
					c.stackType = stackType;
				}
			});

            // 5. 放入目標區域
			if (insertIndex !== undefined && insertIndex !== -1) {
				let zoneCards = state.cards.filter(c => c.zone === toZone);
				let otherCards = state.cards.filter(c => c.zone !== toZone);
				zoneCards.splice(insertIndex, 0, ...movingCards);
				state.cards = [...otherCards, ...zoneCards];
			} else {
				state.cards.push(...movingCards);
			}
		} else if (op.type === 'SHUFFLE') {
			const { zoneId, order } = op; 
			let zoneCards = state.cards.filter(c => c.zone === zoneId);
			let otherCards = state.cards.filter(c => c.zone !== zoneId);
			if (order) {
				// [修正] 寬鬆比對
				zoneCards = order.map(id => state.cards.find(c => c.id == id)).filter(c=>c);
			} else {
				zoneCards.sort(() => Math.random() - 0.5);
			}
			state.cards = [...otherCards, ...zoneCards];

		} else if (op.type === 'ROTATE' || op.type === 'SWITCH_TURN') {
			state.turnPlayer = state.turnPlayer === 1 ? 2 : 1;
		} 
		else if (op.type === 'ROTATE_CARD') {
			const { cardIds, deg, finalRotation } = op;
			state.cards.forEach(c => {
				if (cardIds.some(id => id == c.id)) { // [修正]
					if (finalRotation !== undefined) c.rotation = finalRotation;
					else c.rotation = (c.rotation + deg) % 360;
				}
			});
		}
		else if (op.type === 'FLIP_CARD') {
			const { cardIds, finalFaceUp } = op;
			state.cards.forEach(c => {
				if (cardIds.some(id => id == c.id)) { // [修正]
					if (finalFaceUp !== undefined) c.faceUp = finalFaceUp;
					else c.faceUp = !c.faceUp;
				}
			});
		}
		else if (op.type === 'RENAME_CARD') {
			const { cardIds, text } = op;
			const targets = state.cards.filter(c => cardIds.some(id => id == c.id)); // [修正]
			targets.forEach(target => {
				 state.cards.forEach(c => {
					 if (c.imageKey === target.imageKey) {
						 c.text = text;
					 }
				 });
			});
		}
		else if (op.type === 'RESET_BOARD') {
			const { playerId } = op;
			state.cards.forEach(c => {
				if (c.zone.includes(`p${playerId}-battle`)) {
					c.rotation = 0;
				}
				else if (c.zone.includes(`p${playerId}-mana`)) {
					c.rotation = 180;
				}
			});
		}
		else if (op.type === 'SET_GLOW') {
			const { cardIds, color } = op;
			state.cards.forEach(c => {
				if (cardIds.some(id => id == c.id)) { // [修正]
					if (c.zone.includes('ability')) {
						c.glow = color;
						if (c.sourceId) {
							const source = state.cards.find(s => s.id == c.sourceId); // [修正]
							if (source) {
								source.glow = color;
							}
						}
					}
				}
			});
		}
		// --- 關鍵修正區塊：INJURED 操作 ---
		else if (op.type === 'INJURED') {
			const { cardIds, setInjured } = op;
			state.cards.forEach(c => {
				// [修正] 使用 some + == 進行寬鬆比對 (1 == "1" 為 true)
				// 這是修復匯入後自動清除受傷失效的關鍵
				if (cardIds.some(id => id == c.id)) {
					c.isInjured = setInjured;
				}
			});
		}
		// --------------------------------
		else if (op.type === 'CREATE_ABILITY') {
			const { sourceCardId, targetZone, newId, isContinuous } = op;
			const source = state.cards.find(c => c.id == sourceCardId);
			
			// 嘗試找回來源卡 (防呆邏輯保持不變)
			let effectiveSource = source;
			if (!effectiveSource) {
				effectiveSource = state.cards.find(c => 
					c.ownerId === (targetZone.includes('p1') ? 1 : 2) && 
					(c.zone.includes('battle') || c.zone.includes('mana')) &&
					true 
				);
			}

			if (effectiveSource) {
				// [核心修正] 直接使用操作指令中記錄的 ID，不再重新計算
				// 如果是舊版存檔沒有 newId，才使用 fallback (兼容舊版)
				let idToUse = newId;
				if (!idToUse) {
					// 只有舊版存檔會進來這裡
					idToUse = (state.cards.reduce((max, c) => Math.max(max, c.id), 0) + 1);
				}

				const suffix = isContinuous ? " (Cont)" : " (Eff)";
				const newCard = new Card(idToUse, effectiveSource.ownerId, effectiveSource.text + suffix, targetZone);
				
				newCard.faceUp = true;
				newCard.rotation = 0;
				newCard.imageKey = effectiveSource.imageKey; 
				newCard.backImageKey = effectiveSource.backImageKey;
				newCard.image = effectiveSource.image; 
				newCard.text = effectiveSource.text;
				newCard.sourceId = effectiveSource.id;
				
				if (isContinuous) newCard.isContinuous = true;

				// [關鍵] 設定唯一的 StyleKey，確保位置設定跟著這張卡跑，而不是跟著圖片跑
				// 這樣即使兩張卡用同一張圖，位置也可以不同
				newCard.styleKey = 'style_' + idToUse;

				// 初始化樣式：如果這張圖以前調過，繼承上次的位置；否則歸零
				if (!globalAbilityStyleRegistry[newCard.styleKey]) {
					let initialStyle = { x: 50, y: 50, scale: 1.2 };
					
					// 優先繼承「這張圖片最後一次被調整的樣子」(User Friendly)
					if (globalLastUsedStyles && globalLastUsedStyles[effectiveSource.imageKey]) {
						initialStyle = { ...globalLastUsedStyles[effectiveSource.imageKey] };
					} 
					// 其次繼承圖片本身的設定
					else if (globalAbilityStyleRegistry[effectiveSource.imageKey]) {
						initialStyle = { ...globalAbilityStyleRegistry[effectiveSource.imageKey] };
					}
					
					globalAbilityStyleRegistry[newCard.styleKey] = initialStyle;
				}

				state.cards.push(newCard);
			}
		}
		else if (op.type === 'DELETE_CARD') {
			const { cardIds } = op;
			cardIds.forEach(id => {
			   const c = state.cards.find(x => x.id == id); // [修正]
			   if (c && c.zone.includes('ability') && c.sourceId) {
				   const source = state.cards.find(s => s.id == c.sourceId); // [修正]
				   if (source) source.glow = null;
			   }
			});
			state.cards = state.cards.filter(c => !cardIds.some(id => id == c.id)); // [修正]
		}
		else if (op.type === 'POINT') { }
		else if (op.type === 'ATTACK') {
			const { attackerId } = op;
			const card = state.cards.find(c => c.id == attackerId); // [修正]
			if(card) {
				card.rotation = 90; 
			}
		}
		else if (op.type === 'ADD_NOTE') {
			const { cardIds, note } = op;
			state.cards.forEach(c => {
				if(cardIds.some(id => id == c.id)) c.note = note; // [修正]
			});
		}
		else if (op.type === 'ADJUST_STYLE') {
			const { cardIds, key, val, isDelta } = op;
			state.cards.forEach(c => {
				if(cardIds.some(id => id == c.id)) { // [修正]
					if (isDelta) c[key] += val;
					else c[key] = val;
				}
			});
		}
		else if (op.type === 'SET_BGM') {
            const { filename } = op;
            state.bgm = filename;
        }
		else if (op.type === 'GAME_END') {
            // 只有在自動播放時才觸發特效，避免編輯時一直跳出來煩人
            // 但如果你想在編輯時預覽，可以移除這個 if 檢查
            if (document.body.classList.contains('is-playing') || document.body.classList.contains('mobile-mode')) {
                triggerEnding();
            }
        }
	}
	
	
	// --- [取代] finishMove 函式 ---
	function finishMove(toZone, insertIdx, stackTargetId = null, stackType = null) {
		if (!pendingMove) return;

		// 先把要移動的 ID 存下來，因為函式最後會清空 pendingMove
		const movingIds = [...pendingMove.cardIds];

		// --- START: 移動前先切斷舊連結 ---
		const state = getCurrentDisplayState();
		const needsBreak = pendingMove.cardIds.some(id => {
			const c = state.cards.find(x => x.id === id);
			if (!c) return false;
			if (c.parentId) return true;
			const isParent = state.cards.some(child => child.parentId === c.id);
			if (isParent) return true;
			return false;
		});

		if (needsBreak) {
			addOperation({ type: 'BREAK_LINKS', cardIds: [...pendingMove.cardIds] });
		}
		// --- END: 切斷舊連結 ---
		
		// --- [新增] 自動同步旋轉角度 ---
        // 如果是堆疊操作 (有 stackTargetId)，新來的牌應該繼承目標牌的角度
        if (stackTargetId) {
            const state = getCurrentDisplayState();
            const targetCard = state.cards.find(c => c.id === stackTargetId);
            if (targetCard) {
                // 發送一個旋轉指令，將移動的卡片角度「強制設定」為跟目標一樣
                // 注意：這裡我們用 ROTATE_CARD 的 finalRotation 屬性
                addOperation({ 
                    type: 'ROTATE_CARD', 
                    cardIds: movingIds, 
                    finalRotation: targetCard.rotation // 強制同步角度
                });
            }
        }
		
		let finalCardIds = [...pendingMove.cardIds];
		if (pendingMove.shuffle) {
			finalCardIds.sort(() => Math.random() - 0.5);
		}

		let faceUp = true;
		if (toZone.includes('shield') || toZone.includes('deck')) faceUp = false;
		if (toZone.includes('hand') && toZone.includes('p2')) faceUp = true;

		// 1. 執行移動
		addOperation({
			type: 'MOVE',
			cardIds: finalCardIds, 
			toZone: toZone,
			faceUp: faceUp,
			shuffleSelection: false, 
			insertIndex: insertIdx,
			stackTargetId: stackTargetId,
			stackType: stackType
		});

		// [修改重點] 魔力區自動旋轉
		// 如果目標區域是魔力區 (p1-mana 或 p2-mana)，自動追加兩個 90 度旋轉
		// 這樣在 Draft 模式下，使用者可以按兩次 Ctrl+Z 來分別復原旋轉，最後才復原移動
		if (toZone.includes('mana')) {
			addOperation({ type: 'ROTATE_CARD', cardIds: movingIds, deg: 90 });
			addOperation({ type: 'ROTATE_CARD', cardIds: movingIds, deg: 90 });
		}

		cancelSelection();
		closeSelectorModal();
		closePositionModal();
	}

    function actionShuffleZone() {
        const zoneId = document.getElementById('modal-title').getAttribute('data-zone-id');
        if(!zoneId) return;
        
        const state = getCurrentDisplayState();
        const cards = getCardsInZone(state, zoneId);
        const ids = cards.map(c => c.id);
        ids.sort(() => Math.random() - 0.5); 
        
        addOperation({ type: 'SHUFFLE', zoneId: zoneId, order: ids });
        //closeSelectorModal();
		// 稍微延遲一點點，確保 addOperation 已經更新了 history/tempState
        setTimeout(() => {
            openSelectorModal(zoneId);
        }, 50);
    }
	
	// --- [新增] 拖曳中：只更新 UI 文字，不切換畫面/音樂 ---
    function handleSliderDragging(val) {
        const step = parseInt(val);
        const tooltip = document.getElementById('slider-tooltip');
        
        // 只更新 tooltip 文字，告訴使用者現在拖到第幾步了
        if (tooltip) {
            tooltip.innerText = `${step}/${history.length - 1}`;
        }
    }

    // --- [新增] 放開後：正式切換 ActionLog 與 音樂 ---
    function handleSliderRelease(val) {
        const step = parseInt(val);
        
        // 1. 更新全域步驟索引
        currentIndex = step;
        
        // 2. 重繪畫面 (ActionLog 會在這裡更新)
        renderUI();
        
        // 3. 存檔 (非手機版才存，避免覆蓋)
        if(!document.body.classList.contains('mobile-mode')) {
            saveToStorage();
        }

        // 4. [需求 2] 同步音樂狀態
        // 當使用者放開進度條，我們檢查該步驟的 BGM 設定
        const state = getCurrentDisplayState();
        const targetBgm = state.bgm;

        if (targetBgm) {
            const targetSrc = BGM_FOLDER + targetBgm;
            // 如果 BGM 不同，才進行切換
            // encodeURI 避免檔名空白造成誤判
            if (!globalAudioPlayer.src.includes(encodeURI(targetBgm))) {
                globalAudioPlayer.src = targetSrc;
                
                // 如果目前「不是靜音」，就自動播放新的 BGM
                // 如果是靜音 (muted=true)，這裡 play 也只會繼續靜音播放，符合預期
                globalAudioPlayer.play().catch(e => {});
            }
        } else {
            // 如果該步驟沒有 BGM，就暫停
            globalAudioPlayer.pause();
        }
    }

    // --- [修正版] 旋轉卡片 (修復堆疊連動 + 支援無月之門) ---
    function rotateCard(deg) {
        if (!pendingMove) return;
        
        const state = getCurrentDisplayState();
        
        // 步驟 1: 向上溯源 (這是 BK 版原本有的功能)
        // 找出被選取卡片所屬的「最底層主卡 (Root)」。
        // 無論你點擊堆疊中的哪一張，我們都視為你是在操作整疊卡片的主卡。
        const getRoot = (cardId) => {
            let current = state.cards.find(c => c.id === cardId);
            // 只要它還有 parentId，就繼續往上找
            while (current && current.parentId) {
                const parent = state.cards.find(c => c.id === current.parentId);
                if (!parent) break;
                current = parent;
            }
            return current;
        };

        const getRotatableTree = (rootIds) => {
            const results = new Set();
            const queue = [...rootIds];
            rootIds.forEach(id => results.add(id));
            
            while(queue.length > 0) {
                const currentId = queue.shift();
                const children = state.cards.filter(c => c.parentId === currentId);
                
                // [修改點] 讀取 state.moonless
                const isMoonless = state.moonless && state.moonless[currentId];
                
                children.forEach(child => {
                    if (isMoonless && child.stackType === 'bottom') {
                        return; 
                    }
                    if (!results.has(child.id)) {
                        results.add(child.id);
                        queue.push(child.id);
                    }
                });
            }
            return Array.from(results);
        };

        // --- 執行邏輯 ---
        
        // 1. 先找出所有選取目標的 Roots (解決 A, B, C 只轉一張的問題)
        const roots = new Set();
        pendingMove.cardIds.forEach(id => {
            const r = getRoot(id);
            if (r) roots.add(r.id);
        });

        // 2. 再從這些 Roots 往下計算整棵樹 (解決無月之門不該轉的問題)
        const allTargets = getRotatableTree(Array.from(roots));
        
        addOperation({ type: 'ROTATE_CARD', cardIds: allTargets, deg: deg });
    }

    function flipCard() {
        if (!pendingMove) return;
        const state = getCurrentDisplayState();
        const card = state.cards.find(c => c.id === pendingMove.cardIds[0]);
        const targetFace = !card.faceUp;
        addOperation({ type: 'FLIP_CARD', cardIds: pendingMove.cardIds, finalFaceUp: targetFace });
    }

    function renameCard() {
        if (!pendingMove || pendingMove.cardIds.length === 0) return;
        
        const text = document.getElementById('rename-input').value;
        const state = getCurrentDisplayState();
        
        const targetKeys = new Set();
        pendingMove.cardIds.forEach(id => {
            const c = state.cards.find(x => x.id === id);
            if(c) {
                if(c.imageKey) targetKeys.add(c.imageKey);
                if(c.backImageKey) targetKeys.add(c.backImageKey);
            }
        });

        const applyRename = (cardList) => {
            cardList.forEach(c => {
                const isTarget = pendingMove.cardIds.includes(c.id) || 
                                 (c.imageKey && targetKeys.has(c.imageKey)) ||
                                 (c.backImageKey && targetKeys.has(c.backImageKey));
                if (isTarget) {
                    c.text = text;
                }
            });
        };

        applyRename(initialState.cards);
        history.forEach(h => { if(h.state) applyRename(h.state.cards); });
        if(tempState) applyRename(tempState.cards);
        
        renderUI();
        saveToStorage();
    }
    
    // 2. 新增註記後存檔
	function addCardNote() {
		if (!pendingMove) return;
		const note = document.getElementById('note-input').value;
		addOperation({ type: 'ADD_NOTE', cardIds: pendingMove.cardIds, note: note });
		// addOperation 內部已經有 saveToStorage，所以這裡不用改，但請確認 addOperation 結尾有存檔
	}
    
    // 1. 調整位置後存檔
	function adjustAbilityCard(key, val) {
		if (!pendingMove || pendingMove.cardIds.length === 0) return;
		
		const state = getCurrentDisplayState();
		const targetIds = pendingMove.cardIds;
		let hasChanges = false;

		targetIds.forEach(id => {
			const c = state.cards.find(card => card.id === id);
			if (c) {
				// 確保 styleKey 存在
				let keyToUpdate = c.styleKey || ('style_' + c.id);
				c.styleKey = keyToUpdate;

				let currentStyle = globalAbilityStyleRegistry[keyToUpdate] || { x: 50, y: 50, scale: 1 };
				let newStyle = { ...currentStyle };

				if (key === 'panX') newStyle.x += val;
				else if (key === 'panY') newStyle.y += val;
				else if (key === 'scale') newStyle.scale += val;

				globalAbilityStyleRegistry[keyToUpdate] = newStyle;
				
				// 記憶這個樣式供下次生成使用
				if (c.imageKey) {
					globalLastUsedStyles[c.imageKey] = { ...newStyle };
				}

				hasChanges = true;
			}
		});

		if (hasChanges) {
			renderUI();
			// [修正] 強制存檔，確保刷新後位置還在
			if(!document.body.classList.contains('mobile-mode')) saveToStorage();
		}
	}
    
    function resetBoard(playerId) {
        if(!confirm(playerId === 1 ? t('msg_confirm_p1_reset') : t('msg_confirm_p2_reset'))) return;
        addOperation({ type: 'RESET_BOARD', playerId: playerId });
    }
	
	// --- [新增] 重置當前回合玩家的盤面 ---
    function resetCurrentTurnPlayer() {
        const state = getCurrentDisplayState();
        // 讀取當前是誰的回合 (1 或 2)，並呼叫原本的 resetBoard
        resetBoard(state.turnPlayer);
    }

    function toggleGlow() {
        if (!pendingMove) return;
        const state = getCurrentDisplayState();
        
        // Strict Check: Only Ability Zone cards can trigger Glow
        const invalid = pendingMove.cardIds.some(id => {
            const c = state.cards.find(x => x.id === id);
            return !c || !c.zone.includes('ability');
        });

        if (invalid) {
            alert(t('msg_glow_ability_only'));
            return;
        }

        const colors = ['red', 'yellow', 'green', 'blue', 'black', 'white', 'rainbow', null];
        const firstId = pendingMove.cardIds[0];
        const card = state.cards.find(c => c.id === firstId);
        let currentGlow = card ? card.glow : null;
        let idx = colors.indexOf(currentGlow);
        if (idx === -1) idx = 7; 
        let nextColor = colors[(idx + 1) % colors.length];
        
        addOperation({ type: 'SET_GLOW', cardIds: pendingMove.cardIds, color: nextColor });
    }
	
	// [新增] 獨立控制下半部發光
    function toggleBottomGlow() {
        if (!pendingMove) return;
        const state = getCurrentDisplayState();
        
        // 檢查是否為 Ability 區
        const invalid = pendingMove.cardIds.some(id => {
            const c = state.cards.find(x => x.id === id);
            return !c || !c.zone.includes('ability');
        });

        if (invalid) {
            alert(t('msg_glow_ability_only'));
            return;
        }

        // 僅包含底光的清單
        const bottomColors = [
            'bottom-red', 'bottom-yellow', 'bottom-green', 'bottom-blue', 
            'bottom-black', 'bottom-white', 'bottom-rainbow'
        ];
        
        const firstId = pendingMove.cardIds[0];
        const card = state.cards.find(c => c.id === firstId);
        let currentGlow = card ? card.glow : null;
        
        // 循環邏輯：如果現在不是底光(是全光或無)，就從第一個開始
        let idx = bottomColors.indexOf(currentGlow);
        let nextColor;
        
        if (idx === -1) {
            nextColor = bottomColors[0];
        } else {
            nextColor = bottomColors[(idx + 1) % bottomColors.length];
        }
        
        addOperation({ type: 'SET_GLOW', cardIds: pendingMove.cardIds, color: nextColor });
    }

    function removeGlow() {
        if (!pendingMove) return;
        // Same strict check for removing glow manually via UI
        const state = getCurrentDisplayState();
        const invalid = pendingMove.cardIds.some(id => {
            const c = state.cards.find(x => x.id === id);
            return !c || !c.zone.includes('ability');
        });
        
        if (invalid) {
             alert(t('msg_glow_ability_only'));
             return;
        }

        addOperation({ type: 'SET_GLOW', cardIds: pendingMove.cardIds, color: null });
    }
    
    function revealCards() {
        if(!pendingMove) return;
        finishMove('reveal-zone', undefined);
    }
    
    function revealFromSelector() {
        if(selectedCardsInModal.length === 0) return;
        pendingMove = { cardIds: [...selectedCardsInModal], shuffle: false };
        closeSelectorModal();
        finishMove('reveal-zone', undefined);
    }
    
    function closeRevealZone() {
        if(confirm(t('msg_confirm_reveal_close'))) {
             const state = getCurrentDisplayState();
             const cards = state.cards.filter(c => c.zone === 'reveal-zone');
             const p1Cards = cards.filter(c => c.ownerId === 1).map(c=>c.id);
             const p2Cards = cards.filter(c => c.ownerId === 2).map(c=>c.id);
             
             if (!isDrafting) startDraftAtEnd();
             
             if(p1Cards.length > 0) {
                 addOperation({
                    type: 'MOVE',
                    cardIds: p1Cards,
                    toZone: 'p1-grave',
                    faceUp: true,
                    shuffleSelection: false
                 });
             }
             if(p2Cards.length > 0) {
                 addOperation({
                    type: 'MOVE',
                    cardIds: p2Cards,
                    toZone: 'p2-grave',
                    faceUp: true,
                    shuffleSelection: false
                 });
             }
             saveDraft(t('desc_end_reveal'));
        }
    }

    function endPoint() {
        if (isDrafting) {
            alert(t('msg_point_save_first'));
            return;
        }
        startDraftAtEnd();
        addOperation({ type: 'PASS' });
        saveDraft(t('desc_end_point'));
    }
	
	// --- [新增] 觸發勝利 ---
    // --- [修正版] triggerWin ---
	function triggerWin(winnerId) {
		// 1. 如果不在編輯模式，開啟新步驟 (這會觸發 startDraft 的 50ms 鎖定計時器)
		if (!isDrafting) startDraftAtEnd();
		
		// 2. 加入勝利動作
		addOperation({ 
			type: 'GAME_WIN', 
			winnerId: winnerId 
		});
		
		// 3. 儲存 (這會嘗試解除鎖定)
		saveDraft(`Player ${winnerId} 獲勝!!`);

		// 4. [關鍵修正] 強制修復 ScrollBar
		// 設定一個比 startDraft (50ms) 更晚執行的計時器 (例如 100ms)
		// 確保最後狀態一定是「移除 locked」
		setTimeout(() => {
			const list = document.getElementById('action-list');
			if (list) list.classList.remove('locked');
		}, 100);
	}
	
	// --- [新增] 勝利選單處理函式 ---
    function handleWinSelect(el) {
        const val = el.value;
        if (!val) return; // 如果選的是預設值，不動作
        
        // 1. 執行勝利邏輯
        triggerWin(parseInt(val));
        
        // 2. 執行後自動歸位 (變回預設選項)，方便下次操作
        el.value = ""; 
        el.blur(); // 移除焦點，避免誤觸
    }
	
	// --- [新增] 切換受傷狀態 ---
    function toggleInjured() {
        if (!pendingMove) return;
        
        // 檢查是否符合區域限制 (僅戰鬥區與護盾區)
        const state = getCurrentDisplayState();
        const validZones = ['p1-battle', 'p2-battle', 'p1-shield', 'p2-shield'];
        const isValid = pendingMove.cardIds.every(id => {
            const c = state.cards.find(x => x.id === id);
            return c && validZones.includes(c.zone);
        });

        if (!isValid) {
            alert(t('msg_injured_err'));
            return;
        }

        // 判斷是要全部加受傷，還是全部取消 (若其中一張已受傷，則視為要取消)
        const hasInjured = pendingMove.cardIds.some(id => {
            const c = state.cards.find(x => x.id === id);
            return c.isInjured;
        });

        addOperation({ 
            type: 'INJURED', 
            cardIds: pendingMove.cardIds, 
            setInjured: !hasInjured // 如果有人受傷就全部取消，否則全部設為受傷
        });
		
		// 【新增這行】操作完畢後，強制刷新操作面板狀態
        updateSelectionUI();
    }

	// --- [新增] BGM 相關邏輯 ---

    let tempSelectedBgm = null; // 暫存使用者在 Modal 中選的音樂

    function openBGMModal() {
        // 如果正在編輯非 BGM 的動作，阻止 (Optional)
        if (isDrafting && draftOperations.length > 0 && !draftOperations.some(o => o.type === 'SET_BGM')) {
            alert("請先完成目前的編輯動作。");
            return;
        }

        const listEl = document.getElementById('bgm-list');
        listEl.innerHTML = '';
        tempSelectedBgm = null;

        // 1. 加入「停止播放」選項
        const stopItem = createBGMItem(null, '🛑 停止播放 (Stop Music)');
        listEl.appendChild(stopItem);

        // 2. 加入檔案列表
        BGM_FILES.forEach(filename => {
            listEl.appendChild(createBGMItem(filename, filename));
        });

        // 預設選取當前狀態的 BGM (如果有的話)
        const currentState = getCurrentDisplayState();
        if (currentState.bgm) {
            selectBGMPreview(currentState.bgm);
        } else {
            selectBGMPreview(null);
        }

        document.getElementById('bgm-modal').style.display = 'flex';
    }

    function createBGMItem(filename, label) {
        const div = document.createElement('div');
        div.className = 'bgm-item';
        div.dataset.file = filename || '';
        div.innerText = label;
        div.onclick = () => selectBGMPreview(filename);
        return div;
    }

    function selectBGMPreview(filename) {
        tempSelectedBgm = filename;
        
        // UI 更新
        document.querySelectorAll('.bgm-item').forEach(el => {
            el.classList.remove('selected', 'playing-preview');
            // dataset.file 是字串，null 會變空字串
            const targetVal = filename === null ? '' : filename;
            if (el.dataset.file === targetVal) {
                el.classList.add('selected');
                if (filename) el.classList.add('playing-preview'); // 只有非停止才有喇叭圖示
            }
        });

        // 試聽邏輯
        if (filename) {
            previewAudioPlayer.src = BGM_FOLDER + filename;
            previewAudioPlayer.currentTime = 0;
            previewAudioPlayer.play().catch(e => console.warn("Preview play failed", e));
        } else {
            previewAudioPlayer.pause();
        }
    }

    function closeBGMModal() {
        document.getElementById('bgm-modal').style.display = 'none';
        previewAudioPlayer.pause(); // 關閉視窗即停止試聽
    }

    function confirmBGM() {
        closeBGMModal();

        // 判斷：如果目前已經是編輯模式且有 SET_BGM，則覆蓋；否則新增
        if (draftOperations.length > 0 && draftOperations[0].type === 'SET_BGM') {
            draftOperations = [];
        }

        addOperation({
            type: 'SET_BGM',
            filename: tempSelectedBgm
        });

        // 自動存檔並結束這一步 (因為 BGM 設定通常是獨立動作)
        let desc = tempSelectedBgm ? `[BGM] 播放 ${tempSelectedBgm}` : `[BGM] 停止音樂`;
        saveDraft(desc);
    }
	
	// --- [新增] 猜拳動作 ---
    function actionRPS() {
        // 1. 定義選項 (0:石頭, 1:布, 2:剪刀)
        // 為了方便判斷勝負： (A - B + 3) % 3
        // 結果 0=平手, 1=A贏, 2=B贏
        const CHOICES = ['rock', 'paper', 'scissors'];
        
        // 2. 隨機產生結果
        const p1ChoiceIdx = Math.floor(Math.random() * 3);
        const p2ChoiceIdx = Math.floor(Math.random() * 3);
        
        const p1Val = CHOICES[p1ChoiceIdx];
        const p2Val = CHOICES[p2ChoiceIdx];
        
        // 3. 判斷勝負
        // 0: Draw, 1: P1 Win, 2: P2 Win
        const resultCalc = (p1ChoiceIdx - p2ChoiceIdx + 3) % 3;
        let winner = null;
        if (resultCalc === 1) winner = 1;
        if (resultCalc === 2) winner = 2;

        // 4. 如果不在編輯模式，開啟新步驟
        if (!isDrafting) startDraftAtEnd();

        // 5. 加入操作指令 (將結果寫死在 data 裡)
        addOperation({
            type: 'RPS',
            data: {
                p1: p1Val,
                p2: p2Val,
                winner: winner
            }
        });

        // 6. 產生描述並存檔
        // 為了讓 Action Log 顯示清楚，我們把結果寫在描述裡
        const p1Label = t('rps_' + p1Val);
        const p2Label = t('rps_' + p2Val);
        let resultLabel = "";
        
        if (winner === 1) resultLabel = t('rps_p1_win');
        else if (winner === 2) resultLabel = t('rps_p2_win');
        else resultLabel = t('rps_draw');

        saveDraft(`[${t('act_rps')}] P1:${p1Label} vs P2:${p2Label} -> ${resultLabel}`);
        
        // 7. 如果平手，自動跳出提示，詢問是否要再來一把
        if (winner === null) {
            // 延遲一下讓畫面先畫出來，再跳提示
            setTimeout(() => {
                // 如果是在自動播放中，就不跳 confirm，直接繼續 (模擬連續猜拳)
                // 如果是手動操作，才跳 confirm
                if (!document.body.classList.contains('is-playing') && confirm(`${t('rps_draw')}\n要繼續猜拳嗎？`)) {
                    actionRPS(); // 遞迴呼叫，產生下一局
                }
            }, 500);
        }
    }
	
    // [新增] 清除受傷狀態
	function clearInjured() {
		if (!pendingMove) return;
		
		

		// 檢查區域限制 (僅戰鬥區與護盾區)
		const state = getCurrentDisplayState();
		const validZones = ['p1-battle', 'p2-battle', 'p1-shield', 'p2-shield'];
		const isValid = pendingMove.cardIds.every(id => {
			const c = state.cards.find(x => x.id === id);
			return c && validZones.includes(c.zone);
		});

		if (!isValid) {
			alert(t('msg_injured_err'));
			return;
		}

		// 強制設定為 false (治癒)
		addOperation({ 
			type: 'INJURED', 
			cardIds: pendingMove.cardIds, 
			setInjured: false 
		});
		
		// 【新增這行】強制刷新操作面板狀態
        updateSelectionUI();
	}
	
	// --- [修正版] 複製到能力區 (使用絕對 ID) ---
	function copyToAbility(isContinuous = false) {
		if (!pendingMove) return;
		if (pendingMove.cardIds.length !== 1) return alert(t('msg_select_one_copy'));
		
		const state = getCurrentDisplayState();
		const card = state.cards.find(c => c.id === pendingMove.cardIds[0]);
		if (!card) return;
		
		const targetZone = card.ownerId === 1 ? 'p1-ability' : 'p2-ability';
		
		// [核心修正] 使用時間戳記 + 隨機數生成「絕對唯一 ID」
		// 不再使用 "max + 1"，確保即使在歷史中間插入步驟，這個 ID 也不會跟後面的衝突
		const fixedId = parseInt(`${Date.now()}${Math.floor(Math.random() * 1000)}`);
		
		addOperation({ 
			type: 'CREATE_ABILITY', 
			sourceCardId: card.id, 
			targetZone: targetZone, 
			newId: fixedId, // 將這個鐵打的 ID 寫入歷史
			isContinuous: isContinuous 
		});
	}

    function deleteSelectedCard() {
        if (!pendingMove) return;
        if(!confirm(t('msg_delete_card_confirm'))) return;
        
        addOperation({ type: 'DELETE_CARD', cardIds: pendingMove.cardIds });
        cancelSelection();
    }

    // --- Point Mode Logic ---
    function enterPointMode() {
        if (!pendingMove || pendingMove.cardIds.length !== 1) return alert(t('msg_select_one_point'));
        pointerId = pendingMove.cardIds[0];
        isPointing = true;
        pointTargets = [];
        
        document.getElementById('card-action-panel').style.display = 'none';
        document.getElementById('point-bar').style.display = 'flex';
        updatePointInfo();
        document.querySelectorAll('.zone').forEach(el => el.classList.add('point-target-highlight'));
        renderUI(); 
    }

    function cancelPointMode() {
        isPointing = false;
        pointerId = null;
        pointTargets = [];
        document.getElementById('point-bar').style.display = 'none';
        document.querySelectorAll('.point-target-highlight').forEach(el => el.classList.remove('point-target-highlight'));
        document.querySelectorAll('.point-target-selected').forEach(el => el.classList.remove('point-target-selected'));
        cancelSelection(); 
    }

	function handlePointClick(zoneId, cardId) {
        if (!isPointing) return;
        
        // [修正] 允許指向 牌庫(Deck)、超次元(Hyper)、墓地(Grave)
		if (!cardId && (zoneId.includes('deck') || zoneId.includes('hyper') || zoneId.includes('grave'))) {
			let zoneName = t('zone_generic');
			if(zoneId.includes('deck')) zoneName = t('zone_player_deck');
			if(zoneId.includes('hyper')) zoneName = t('zone_hyper_area');
			if(zoneId.includes('grave')) zoneName = t('zone_grave_area');

			// 使用 replace 處理參數字串
			const msg = t('msg_confirm_point_zone').replace('{zone}', zoneName);
			if (confirm(msg)) {
				// [關鍵修正] 這裡原本傳 null，改成傳入陣列 [zoneId]
				// 這樣畫箭頭的函式才知道目標是誰
				finishPoint('ZONE', [zoneId]);
			}
			return;
		}
        
        if (cardId) {
            if (pointTargets.includes(cardId)) {
                pointTargets = pointTargets.filter(id => id !== cardId);
            } else {
                pointTargets.push(cardId);
            }
            updatePointInfo();
            renderUI(); 
        }
    }

    function updatePointInfo() {
        const btn = document.getElementById('btn-confirm-point');
        const info = document.getElementById('point-target-info');
        if (pointTargets.length > 0) {
            info.innerText = `已選擇 ${pointTargets.length} 個目標`;
            btn.style.display = 'block';
        } else {
            info.innerText = "請點擊目標...";
            btn.style.display = 'none';
        }
    }

    function confirmPointTargets() {
        if (pointTargets.length === 0) return;
        finishPoint('CARD', pointTargets);
    }

    function finishPoint(type, targetIds) {
        const state = getCurrentDisplayState();
        const pointer = state.cards.find(c => c.id === pointerId);
        let desc = `[指向] ${pointer.text} 指向 `;
        if (type === 'PLAYER') desc += '玩家/牌庫';
        else if (type === 'CARD') desc += `${targetIds.length} 個目標`;

        addOperation({
            type: 'POINT',
            attackerId: pointerId,
            targetType: type,
            targetIds: targetIds,
            desc: desc
        });
        cancelPointMode();
    }

    // --- [取代] handleZoneClick 函式 ---
	// --- [修正] 區域點擊處理 ---
	function handleZoneClick(zoneId) {
		// [新增] 手機版強制阻擋所有區域點擊 (包含牌庫、墓地等清單開啟行為)
		if (document.body.classList.contains('mobile-mode')) {
			return; 
		}

		if (isPointing) {
			handlePointClick(zoneId, null); 
			return;
		}

		if (pendingMove) {
			const state = getCurrentDisplayState();
			// FILTER: Prevent moving Ability cards
			const hasAbilityCard = pendingMove.cardIds.some(id => {
				const c = state.cards.find(card => card.id === id);
				return c && c.zone.includes('ability');
			});
			if(hasAbilityCard) {
				alert(t('msg_ability_cant_move'));
				return;
			}

			if (isStackZone(zoneId)) {
				const cardsInZone = getCardsInZone(state, zoneId);
				if (zoneId.includes('shield') && cardsInZone.length === 0) {
					finishMove(zoneId, undefined);
					return;
				}
				openPositionSelector(zoneId, pendingMove);
			} else {
				finishMove(zoneId, undefined);
			}
			return;
		}
		openSelectorModal(zoneId);
	}
    
    document.addEventListener('click', (e) => {
        // [修改] 增加 e.target.closest('#card-action-panel') 
        // 這樣點擊或拖曳面板本身時，就不會觸發取消選取
        if (e.target.closest('.card') || 
            e.target.closest('.zone') || 
            e.target.closest('button') || 
            e.target.closest('input') || 
            e.target.closest('.modal') || 
            e.target.closest('#card-action-panel')) { // <--- 加入這行
            return;
        }

        if (!isPointing) cancelSelection();
    });

    function cancelSelection() {
        if (pendingMove) {
            pendingMove = null;
            document.querySelectorAll('.zone').forEach(el => el.classList.remove('target-highlight'));
            document.querySelectorAll('.card.selected').forEach(el => el.classList.remove('selected'));
            document.getElementById('card-action-panel').style.display = 'none';
        }
    }

    function isStackZone(zid) {
        return zid.includes('deck') || zid.includes('shield') || zid.includes('hyper');
    }
	
	// [新增] 從面板切換王牌狀態
    function toggleAceFromPanel() {
        if (!pendingMove || pendingMove.cardIds.length !== 1) return;
        
        const cardId = pendingMove.cardIds[0];
        // 檢查目前是否已經是 Ace
        const isAce = !!globalAceRegistry[cardId];
        
        // 切換狀態 (toggle)
        toggleAceSilent(cardId, !isAce);
        
        // 更新按鈕外觀
        updateSelectionUI();
    }

	// --- [新增] 多重選取模式切換 ---
    function toggleMultiSelectMode() {
        // 如果正在一般選取模式(單張)，先取消
        if (pendingMove) cancelSelection();

        isMultiSelectMode = !isMultiSelectMode;
        const btn = document.getElementById('btn-multi-move');

        if (isMultiSelectMode) {
            // 進入模式
            multiSelectedIds = [];
            btn.classList.add('active');
            // 更新按鈕文字為「取消/確認」
            btn.innerText = t('btn_multi_confirm');
            
            // 為了不讓使用者混淆，可以暫時隱藏下方的 Action Panel
            document.getElementById('card-action-panel').style.display = 'none';
        } else {
            // 離開模式 (或是按下確認)
            btn.classList.remove('active');
            btn.innerText = t('btn_multi_move'); // 改回原本文字

            if (multiSelectedIds.length === 0) {
                // 如果沒選半張，就單純取消，什麼都不做
                renderUI(); // 清除勾勾
                return;
            }

            // 如果有選卡片，進入「準備移動」狀態
            // 設定 pendingMove，讓系統以為這是使用者選好的一組牌
            pendingMove = { cardIds: [...multiSelectedIds], shuffle: false };
            
            // 提示使用者
            const msg = t('msg_select_dest').replace('{n}', multiSelectedIds.length);
            alert(msg);
            
            // 此時 isMultiSelectMode 已經 false，但 pendingMove 有值
            // 所以使用者的下一個點擊動作 (handleZoneClick) 就會觸發 finishMove
            updateSelectionUI(); // 這會讓畫面上的卡片顯示選取框
        }
        renderUI();
    }

    function openStackingModal(targetCard) {
        const modal = document.getElementById('position-selector-modal');
        const list = document.getElementById('position-list');
        list.innerHTML = '';
        
        const titleTemplate = t('title_stack_target') || '堆疊操作: 目標 [{target}]';
		document.getElementById('pos-modal-title').innerText = titleTemplate.replace('{target}', targetCard.text);
        document.getElementById('position-list').style.display = 'none';
        document.getElementById('stack-gui').style.display = 'grid';
        
        window.confirmStackMove = (type) => {
            finishMove(targetCard.zone, undefined, targetCard.id, type);
        };
        modal.style.display = 'flex';
    }

    function updateSelectionUI() {
        // 清除舊的選取樣式
        document.querySelectorAll('.card.selected').forEach(el => el.classList.remove('selected'));
        
        // --- 1. 更新多選提示列 ---
        const multiBar = document.getElementById('multi-select-bar');
        const multiCount = document.getElementById('multi-count-val');
        if (isMultiSelectMode) {
            multiBar.style.display = 'flex';
            multiCount.innerText = multiSelectedIds.length;
            document.getElementById('card-action-panel').style.display = 'none';
        } else {
            multiBar.style.display = 'none';
        }
        
        // --- 2. 處理單選/多選操作面板 ---
        if (pendingMove && pendingMove.cardIds.length > 0) {
            const state = getCurrentDisplayState();
            
            // --- [位置設定] ---
            const firstCard = state.cards.find(c => c.id === pendingMove.cardIds[0]);
            if (firstCard) {
                currentPanelOwner = (firstCard.ownerId === 1) ? 'p1' : 'p2';
                const savedPos = panelPosSettings[currentPanelOwner];
                const panel = document.getElementById('card-action-panel');
                panel.style.left = savedPos.x + 'px';
                panel.style.top = savedPos.y + 'px';
            }
            
            // --- [狀態判斷] 掃描所有選取卡片 ---
            let allAbility = true;      
            let isBattleOrShield = true; 
            let hasInjuredCard = false;  
            
            pendingMove.cardIds.forEach(id => {
                const c = state.cards.find(card => card.id === id);
                if (!c) return;
                
                if (!c.zone.includes('ability')) {
                    allAbility = false;
                }
                const z = c.zone;
                if (!z.includes('battle') && !z.includes('shield')) {
                    isBattleOrShield = false;
                }
                if (c.isInjured) {
                    hasInjuredCard = true;
                }
            });
            
            // --- [UI 按鈕顯示邏輯] ---
            
            // A. 取得所有按鈕元素
            const btnRotateL = document.getElementById('btn-rotate-l');
            const btnRotateR = document.getElementById('btn-rotate-r');
            const btnFlip = document.getElementById('btn-flip');
            const btnAce = document.getElementById('btn-ace');
            const btnReveal = document.getElementById('btn-reveal');
            const btnPaste = document.getElementById('btn-paste'); 
            const btnRemoveImg = document.getElementById('btn-remove-image');
            const btnGlow = document.getElementById('btn-glow');
            const btnGlowBottom = document.getElementById('btn-glow-bottom');
            const btnUnglow = document.getElementById('btn-unglow');
            const btnCopyOne = document.getElementById('btn-copy-ability');
            const btnCopyCont = document.getElementById('btn-copy-continuous');
            const adjustControls = document.getElementById('ability-adjust-controls');
            const adjustButtons = document.getElementById('ability-adjust-buttons');
            const btnInjured = document.getElementById('btn-injured');
            const btnClearInjured = document.getElementById('btn-clear-injured');
            const btnMoonless = document.getElementById('btn-moonless'); 

            // B. 預設將所有「功能類」按鈕重置為顯示
            btnRotateL.style.display = 'block';
            btnRotateR.style.display = 'block';
            btnFlip.style.display = 'block';
            btnAce.style.display = 'block';
            btnReveal.style.display = 'block';
            btnPaste.style.display = 'block';
            btnGlow.style.display = 'block';
            btnGlowBottom.style.display = 'block';
            btnCopyOne.style.display = 'block';
            btnCopyCont.style.display = 'block';
            adjustControls.style.display = 'block';
            adjustButtons.style.display = 'flex';
            
            // C. 狀態依賴型按鈕先預設隱藏
            btnRemoveImg.style.display = 'none';
            btnUnglow.style.display = 'none';
            btnInjured.style.display = 'none';
            btnClearInjured.style.display = 'none';
            
            // D. 依據「卡片類型」執行刪去法
            if (allAbility) {
                // =========== 情境 A：效果小卡 ===========
                btnRotateL.style.display = 'none';
                btnRotateR.style.display = 'none';
                btnFlip.style.display = 'none';
                btnAce.style.display = 'none';
                btnReveal.style.display = 'none';
                btnPaste.style.display = 'none';
                btnCopyOne.style.display = 'none';
                btnCopyCont.style.display = 'none';
                btnMoonless.style.display = 'none'; // 效果卡不能開無月

                // 移除 disabled 樣式
                btnGlow.classList.remove('disabled-gray');
                btnGlowBottom.classList.remove('disabled-gray');

            } else {
                // =========== 情境 B：一般卡片 ===========
                btnGlow.style.display = 'none';
                btnGlowBottom.style.display = 'none';
                adjustControls.style.display = 'none';
                adjustButtons.style.display = 'none';
            }

            // E. 依據「卡片狀態/區域」進行細部顯示
            
            // 1. 受傷/治癒
            if (isBattleOrShield) {
                if (hasInjuredCard) {
                    btnClearInjured.style.display = 'block'; 
                } else {
                    btnInjured.style.display = 'block';      
                }
            }

            // 2. 移除圖片
            if (!allAbility && firstCard && firstCard.image) {
                btnRemoveImg.style.display = 'block';
            }

            // 3. 取消發光
            if (allAbility && firstCard && firstCard.glow) {
                btnUnglow.style.display = 'block';
            }

            // 4. 王牌按鈕狀態 & 無月之門按鈕狀態 (單選一般卡時)
            if (!allAbility && pendingMove.cardIds.length === 1) {
                const cid = pendingMove.cardIds[0];
                
                // --- 王牌 ---
                if (globalAceRegistry[cid]) {
                    btnAce.classList.add('active');
                    btnAce.innerText = "👑 取消王牌";
                } else {
                    btnAce.classList.remove('active');
                    btnAce.innerText = "👑 設為王牌";
                }

                // --- 無月之門 (修改點：讀取 state.moonless) ---
                if (state.moonless && state.moonless[cid]) {
                    btnMoonless.classList.add('active');
                    btnMoonless.style.display = 'block';
                } else {
                    btnMoonless.classList.remove('active');
                    btnMoonless.style.display = 'block';
                }
                
            } else {
                // 多選時隱藏這些特殊按鈕
                btnAce.style.display = 'none';
                btnMoonless.style.display = 'none';
            }

            // --- 3. 顯示面板與高亮 ---
            if (!isMultiSelectMode) {
                document.getElementById('card-action-panel').style.display = 'flex';
                
                // 載入名稱與註記
                if (pendingMove.cardIds.length === 1 && firstCard) {
                    document.getElementById('rename-input').value = firstCard.text;
                    document.getElementById('note-input').value = firstCard.note || "";
                } else {
                    document.getElementById('rename-input').value = '';
                    document.getElementById('note-input').value = '';
                }
            } else {
                 document.getElementById('card-action-panel').style.display = 'none';
            }
            document.querySelectorAll('.zone').forEach(el => el.classList.add('target-highlight'));
            
        } else {
            // 沒有選取任何卡片 -> 隱藏所有選單與高亮
            document.getElementById('card-action-panel').style.display = 'none';
            document.querySelectorAll('.zone').forEach(el => el.classList.remove('target-highlight'));
        }
    }
	
	function updateToolbarState() {
        const btnDiag = document.getElementById('btn-add-dialogue');
        if (!btnDiag) return;

        // 如果正在編輯非對話動作，則停用對話按鈕
        const isEditingNonDialog = isDrafting && draftOperations.length > 0 && !draftOperations.some(o => o.type === 'DIALOGUE');
        
        if (isEditingNonDialog) {
            btnDiag.classList.add('disabled-gray');
        } else {
            btnDiag.classList.remove('disabled-gray');
        }
    }

    function getCardPositions() {
        const positions = {};
        document.querySelectorAll('.card').forEach(el => {
            if(el.dataset.id) {
                const rect = el.getBoundingClientRect();
                positions[el.dataset.id] = { top: rect.top, left: rect.left, width: rect.width, height: rect.height };
            }
        });
        document.querySelectorAll('.zone').forEach(el => {
            if(el.dataset.zone) {
                const rect = el.getBoundingClientRect();
                positions['ZONE_' + el.dataset.zone] = { top: rect.top, left: rect.left, width: rect.width, height: rect.height };
            }
        });
        return positions;
    }

    function getCardsInZone(state, zoneName) {
        return state.cards.filter(c => c.zone === zoneName);
    }

    function getZoneName(zoneId) {
        return zoneId.toUpperCase(); 
    }

	function renderUI(skipScroll) {
        const firstPositions = getCardPositions();
        const state = getCurrentDisplayState();
        
        let winOverlay = document.getElementById('win-overlay');
        if (!winOverlay) {
            winOverlay = document.createElement('div');
            winOverlay.id = 'win-overlay';
            document.body.appendChild(winOverlay);
        }

        const board = document.getElementById('game-board-container');
        const abilityZone = document.getElementById('ability-stack-zone');
        
        const p1Area = document.getElementById('player1-area');
        const p2Area = document.getElementById('player2-area');
        
        if (p1Area && p2Area) {
            p1Area.classList.remove('active-turn');
            p2Area.classList.remove('active-turn');
            if (state.turnPlayer === 1) p1Area.classList.add('active-turn');
            else p2Area.classList.add('active-turn');
        }
        
        if (state.globalRotation) {
            board.classList.add('rotated-view');
            abilityZone.classList.add('rotated-view');
        } else {
            board.classList.remove('rotated-view');
            abilityZone.classList.remove('rotated-view');
        }

        document.querySelectorAll('.zone, .ability-column').forEach(el => {
            const label = el.querySelector('.zone-label, .ability-label');
            el.innerHTML = '';
            if(label) el.appendChild(label);
            el.classList.remove('target-highlight');
            el.classList.remove('point-target-highlight'); 
            el.className = el.className.replace(/\bglow-\S+/g, '');
        });
        
        const revealZoneEl = document.getElementById('reveal-zone');
        const revealCards = state.cards.filter(c => c.zone === 'reveal-zone');
        if (revealCards.length > 0) {
            revealZoneEl.style.display = 'flex';
            // 修改這裡：使用 t() 和 data-i18n
            revealZoneEl.innerHTML = `
                <span class="zone-label" data-i18n="lbl_reveal_zone">${t('lbl_reveal_zone')}</span>
                <button class="mini-btn danger" style="position:absolute; top:5px; right:5px;" onclick="closeRevealZone()">✕</button>
            `;
            revealCards.forEach(c => revealZoneEl.appendChild(createCardElement(c)));
        } else {
            revealZoneEl.style.display = 'none';
            revealZoneEl.innerHTML = '';
        }

        if (pendingMove) document.querySelectorAll('.zone').forEach(el => el.classList.add('target-highlight'));
        if (isPointing) document.querySelectorAll('.zone').forEach(el => el.classList.add('point-target-highlight'));

        const zoneMap = {};
        const childMap = {}; 
        const rootCards = []; 

        state.cards.forEach(card => {
            if (card.zone === 'reveal-zone') return;
            if(!zoneMap[card.zone]) zoneMap[card.zone] = [];
            zoneMap[card.zone].push(card);
            if (card.parentId) {
                if (!childMap[card.parentId]) childMap[card.parentId] = [];
                childMap[card.parentId].push(card);
            } else {
                rootCards.push(card);
            }
        });

        ['p1-deck', 'p1-grave', 'p1-hyper', 'p2-deck', 'p2-grave', 'p2-hyper'].forEach(zid => {
            const cards = zoneMap[zid] || [];
            const glowingCard = cards.find(c => c.glow);
            if (glowingCard) {
                const zoneEl = document.querySelector(`.zone[data-zone="${zid}"]`);
                if (zoneEl) zoneEl.classList.add(`glow-${glowingCard.glow}`);
            }
        });

        const stackedZones = ['p1-deck', 'p1-grave', 'p1-hyper', 'p2-deck', 'p2-grave', 'p2-hyper', 'p1-shield', 'p2-shield'];

		// --- [核心修改] 渲染堆疊 (標準模式 vs 無月例外模式) ---
        // --- [核心修改] 渲染堆疊 (讀取 state.moonless) ---
        const renderCardTree = (rootCard, container) => {
            const isSpreadZone = !stackedZones.includes(rootCard.zone) || rootCard.zone.includes('shield');
            if (!isSpreadZone) return;

            // 預先掃描家族成員
            const familyMembers = [];
            const queue = [rootCard];
            while(queue.length > 0) {
                const node = queue.shift();
                familyMembers.push(node);
                const children = (childMap[node.id] || []);
                children.forEach(c => queue.push(c));
            }

            // --- [修改點] 從 state.moonless 判斷 ---
            const moonlessAce = familyMembers.find(c => state.moonless && state.moonless[c.id]);

            const createContainer = (bounds) => {
                const totalW = bounds.maxX - bounds.minX;
                const totalH = bounds.maxY - bounds.minY;
                const div = document.createElement('div');
                div.className = 'card-group';
                div.style.width = `${totalW}px`;
                div.style.height = `${totalH}px`;
                div.style.position = 'relative'; 
                div.style.margin = '5px 10px';
                container.appendChild(div);
                return { div, offsetX: -bounds.minX, offsetY: -bounds.minY };
            };

            // Mode 1: 無月之門例外渲染
            if (moonlessAce) {
                const isPuzzle = (c) => c.stackType && c.stackType.includes('puzzle');
                const subjects = familyMembers.filter(c => c.id !== moonlessAce.id && !isPuzzle(c));
                const puzzlePartners = familyMembers.filter(c => c.id !== moonlessAce.id && isPuzzle(c));

                const count = subjects.length;
                const radius = 15; 
                let bounds = { minX: 0, maxX: 50, minY: 0, maxY: 70 };
                
                const layoutCache = new Map(); 
                if (count > 0) {
                    const step = 360 / count;
                    const startAngle = -90 + (step / 2); 

                    subjects.forEach((sub, idx) => {
                        const angleDeg = startAngle + step * idx;
                        const rad = angleDeg * (Math.PI / 180);
                        const offX = radius * Math.cos(rad);
                        const offY = radius * Math.sin(rad);
                        const visualRot = angleDeg + 270;

                        layoutCache.set(sub.id, { x: offX, y: offY, rot: visualRot });

                        const margin = 40; 
                        bounds.minX = Math.min(bounds.minX, offX - margin);
                        bounds.maxX = Math.max(bounds.maxX, offX + margin);
                        bounds.minY = Math.min(bounds.minY, offY - margin);
                        bounds.maxY = Math.max(bounds.maxY, offY + margin);
                    });
                } else {
                    bounds = { minX: -5, maxX: 55, minY: -5, maxY: 75 };
                }

                const puzzleCache = new Map();
                const measurePuzzleRecursive = (currentCard, parentX, parentY) => {
                    const baseOffset = getBaseStackOffset(currentCard.stackType);
                    const r = rotateVector(baseOffset.x, baseOffset.y, moonlessAce.rotation);
                    const myX = parentX + r.x;
                    const myY = parentY + r.y;
                    puzzleCache.set(currentCard.id, { x: myX, y: myY });
                    bounds.minX = Math.min(bounds.minX, myX);
                    bounds.maxX = Math.max(bounds.maxX, myX + 50);
                    bounds.minY = Math.min(bounds.minY, myY);
                    bounds.maxY = Math.max(bounds.maxY, myY + 70);
                    const children = puzzlePartners.filter(p => p.parentId === currentCard.id);
                    children.forEach(child => measurePuzzleRecursive(child, myX, myY));
                };
                const directPuzzles = puzzlePartners.filter(p => p.parentId === moonlessAce.id);
                directPuzzles.forEach(p => measurePuzzleRecursive(p, 0, 0));

                const { div, offsetX, offsetY } = createContainer(bounds);

                subjects.forEach(sub => {
                    const layout = layoutCache.get(sub.id);
                    const cardEl = createCardElement(sub);
                    cardEl.style.position = 'absolute';
                    cardEl.style.left = `${offsetX + layout.x}px`;
                    cardEl.style.top = `${offsetY + layout.y}px`;
                    cardEl.style.zIndex = 5; 
                    cardEl.dataset.visualRot = layout.rot;
                    cardEl.style.transform = `rotate(${layout.rot}deg)`;
                    div.appendChild(cardEl);
                });

                const aceEl = createCardElement(moonlessAce);
                aceEl.style.position = 'absolute';
                aceEl.style.left = `${offsetX}px`;
                aceEl.style.top = `${offsetY}px`;
                aceEl.style.zIndex = 50; 
                aceEl.classList.add('stack-base');
                let aceTransform = `rotate(${moonlessAce.rotation}deg)`;
                if (pendingMove && pendingMove.cardIds.includes(moonlessAce.id)) {
                    aceTransform += ` translateY(-5px)`;
                }
                aceEl.style.transform = aceTransform;
                div.appendChild(aceEl);

                puzzlePartners.forEach(p => {
                    const pos = puzzleCache.get(p.id);
                    if (!pos) return; 
                    const pEl = createCardElement(p);
                    pEl.style.position = 'absolute';
                    pEl.style.left = `${offsetX + pos.x}px`;
                    pEl.style.top = `${offsetY + pos.y}px`;
                    pEl.style.zIndex = 51;
                    let pTransform = `rotate(${moonlessAce.rotation}deg)`; 
                    if (pendingMove && pendingMove.cardIds.includes(p.id)) {
                        pTransform += ` translateY(-5px)`;
                    }
                    pEl.style.transform = pTransform;
                    div.appendChild(pEl);
                });

            } else {
                // Mode 2: Standard (保持不變)
                let bounds = { minX: Infinity, maxX: -Infinity, minY: Infinity, maxY: -Infinity };
                const nodePositions = new Map(); 
                const measureNode = (card, currentX, currentY) => {
                    nodePositions.set(card.id, { x: currentX, y: currentY });
                    const cx = currentX + 25; 
                    const cy = currentY + 35;
                    const corners = [{x:-25,y:-35}, {x:25,y:-35}, {x:25,y:35}, {x:-25,y:35}];
                    corners.forEach(p => {
                        const r = rotateVector(p.x, p.y, card.rotation);
                        const finalX = cx + r.x;
                        const finalY = cy + r.y;
                        if (finalX < bounds.minX) bounds.minX = finalX;
                        if (finalX > bounds.maxX) bounds.maxX = finalX;
                        if (finalY < bounds.minY) bounds.minY = finalY;
                        if (finalY > bounds.maxY) bounds.maxY = finalY;
                    });
                    const children = childMap[card.id] || [];
                    children.forEach(child => {
                        const baseOffset = getBaseStackOffset(child.stackType);
                        const rotatedOffset = rotateVector(baseOffset.x, baseOffset.y, card.rotation);
                        measureNode(child, currentX + rotatedOffset.x, currentY + rotatedOffset.y);
                    });
                };
                measureNode(rootCard, 0, 0);
                if (bounds.minX === Infinity) bounds = { minX:0, maxX:50, minY:0, maxY:70 };
                const { div, offsetX, offsetY } = createContainer(bounds);
                const renderNodeRecursive = (card, zIndex) => {
                    const pos = nodePositions.get(card.id);
                    if (!pos) return;
                    const cardEl = createCardElement(card);
                    cardEl.style.position = 'absolute';
                    cardEl.style.left = `${pos.x + offsetX}px`;
                    cardEl.style.top = `${pos.y + offsetY}px`;
                    cardEl.style.zIndex = zIndex;
                    let transformCSS = `rotate(${card.rotation}deg)`;
                    if (pendingMove && pendingMove.cardIds.includes(card.id)) {
                        transformCSS += ` translateY(-5px)`;
                    }
                    cardEl.style.transform = transformCSS;
                    if (!card.parentId) cardEl.classList.add('stack-base');
                    div.appendChild(cardEl);
                    const children = childMap[card.id] || [];
                    children.forEach(child => {
                        let nextZ = zIndex;
                        const type = child.stackType;
                        if (['top','shift_up','puzzle_top','shift_down'].includes(type)) nextZ += 1;
                        else nextZ -= 1;
                        renderNodeRecursive(child, nextZ);
                    });
                };
                renderNodeRecursive(rootCard, 10);
            }
        };

        Object.keys(zoneMap).forEach(zoneId => {
            const cardsInZone = zoneMap[zoneId];
            if (zoneId.includes('ability')) {
				const zoneEl = document.getElementById(zoneId === 'p1-ability' ? 'ability-zone-p1' : 'ability-zone-p2');
				
				// [新增] 排序邏輯：持續效果 (isContinuous) 優先排在前面 (視覺上的上方)
				cardsInZone.sort((a, b) => {
					const valA = a.isContinuous ? 1 : 0;
					const valB = b.isContinuous ? 1 : 0;
					return valB - valA; // 大的排前面 (1 > 0)
				});

				cardsInZone.forEach(card => zoneEl.appendChild(createCardElement(card)));
				return;
			}
            const zoneEl = document.querySelector(`.zone[data-zone="${zoneId}"]`);
            if (!zoneEl) return;
            if (stackedZones.includes(zoneId) && !zoneId.includes('shield')) {
				const count = cardsInZone.length;
				
				if (count > 0) {
					// [智慧渲染演算法]
					// 為了效能，我們不渲染所有卡片，只渲染「會造成視覺差異」的關鍵卡片
					// 1. 最底下的卡 (Base)
					// 2. 最上面的卡 (Top)
					// 3. 任何與下一張卡角度不同的卡 (Transition)
					
					const indicesToRender = new Set();
					indicesToRender.add(0);          // 底
					indicesToRender.add(count - 1);  // 頂
					
					for (let i = 0; i < count - 1; i++) {
						const current = cardsInZone[i];
						const next = cardsInZone[i+1];
						// 如果這張跟上面那張角度不一樣，兩張都要畫出來，才能呈現交錯感
						if (current.rotation !== next.rotation) {
							indicesToRender.add(i);
							indicesToRender.add(i+1);
						}
					}
					
					// 將 Set 轉為陣列並排序，確保 Z-Index 正確 (由底到頂)
					const sortedIndices = Array.from(indicesToRender).sort((a,b) => a - b);
					
					sortedIndices.forEach(index => {
						const card = cardsInZone[index];
						const cardEl = createCardElement(card);
						
						// 強制堆疊樣式
						cardEl.style.position = 'absolute';
						// 居中定位
						cardEl.style.top = '0';
						cardEl.style.left = '0';
						cardEl.style.right = '0';
						cardEl.style.bottom = '0';
						cardEl.style.margin = 'auto';
						
						// 設定層級，確保上面的蓋住下面的
						cardEl.style.zIndex = index + 1; 
						
						// 如果卡片有旋轉，createCardElement 已經設定了 transform: rotate(...)
						// 這裡不需要額外處理，瀏覽器會自己處理旋轉後的遮擋關係
						
						zoneEl.appendChild(cardEl);
					});
				}

				// 數量標記 (Badge)
				const badge = document.createElement('div');
				badge.className = 'count-badge';
				badge.innerText = count;
				// 確保數字永遠浮在最上面
				badge.style.zIndex = 1000; 
				zoneEl.appendChild(badge);
			} else {
                const roots = rootCards.filter(c => c.zone === zoneId);
                roots.forEach(root => renderCardTree(root, zoneEl));
            }
        });

        renderTimeline();
        renderArrows();

		// --- Dialogue Rendering ---
		const diagLayer = document.getElementById('dialogue-layer');
		if (state.dialogueData) {
			diagLayer.classList.add('active');
			['p1', 'p2'].forEach(id => {
				const data = state.dialogueData[id];
				const row = document.getElementById(`diag-row-${id}`);
				const img = document.getElementById(`diag-img-${id}`);
				const name = document.getElementById(`diag-name-${id}`);
				const text = document.getElementById(`diag-text-${id}`);
				
				// [新增] 取得對話框本體
				const box = row.querySelector('.diag-box');

				if (data && data.active) {
					row.classList.add('visible');
					
					// [關鍵修改] 讓對話框可以被點擊
					box.style.pointerEvents = 'auto'; 
					box.style.cursor = 'pointer';
					box.title = "點擊編輯對話";
					
					// 綁定點擊事件
					box.onclick = (e) => {
						e.stopPropagation();
						// 如果還沒在編輯模式，就觸發編輯當前步驟
						// editAction 會自動判斷如果是對話動作，就開啟對話視窗
						if (!isDrafting) {
							editAction(currentIndex);
						} else {
							// 如果已經在編輯模式，直接開窗
							openDialogueModal();
						}
					};

					// 重置動畫 Class 以觸發重播
					row.classList.remove('fx-fade', 'fx-slide', 'fx-direct');
					void row.offsetWidth; // 強制重繪 (Reflow)
					row.classList.add(`fx-${data.effect}`);

					name.innerText = data.name;
					text.innerText = data.dataText; 
					text.className = `diag-text text-${data.size}`;
					
					const imgKey = `avatar_${id}_${data.emotion}`;
					const src = globalImageRegistry[imgKey];
					img.style.backgroundImage = src ? `url(${src})` : 'none';
				} else {
					row.classList.remove('visible');
					// 隱藏時確保不可點擊 (避免擋到下方的卡片)
					if (box) box.style.pointerEvents = 'none';
				}
			});
		} else {
			diagLayer.classList.remove('active');
			document.querySelectorAll('.diag-row').forEach(el => el.classList.remove('visible'));
		}

		// --- [修改] 勝利畫面渲染邏輯 (限制僅在觸發當下播放) ---
        
        // 1. 判斷當前步驟是否為「觸發勝利」的那一步
        let isWinActionStep = false;
        if (currentIndex >= 0 && history[currentIndex]) {
            // 檢查當前的 Action 裡面有沒有包含 GAME_WIN 操作
            isWinActionStep = history[currentIndex].action.operations.some(o => o.type === 'GAME_WIN');
        }

        // 2. 只有在「狀態有贏家」且「當前步驟正是勝利時刻」才顯示特效
        if (state.winner && isWinActionStep) {
            
            // 如果畫面還沒顯示，才進行內容生成
            if (winOverlay.style.display !== 'flex') {
                winOverlay.style.display = 'flex';
                
                const winnerText = state.winner === 1 ? "1P WIN!" : "2P WIN!";
                const color = state.winner === 1 ? "#3498db" : "#e91e63"; 
                
                winOverlay.innerHTML = `
                    <div class="win-text" style="color: ${color}">${winnerText}</div>
                    <div class="win-sub">Congratulations!</div>
                `;
                
                // 生成彩帶特效
                const colors = ['#f1c40f', '#e74c3c', '#3498db', '#9b59b6', '#2ecc71'];
                for (let i = 0; i < 50; i++) {
                    const conf = document.createElement('div');
                    conf.className = 'confetti';
                    conf.style.left = Math.random() * 100 + 'vw';
                    conf.style.animationDuration = (Math.random() * 3 + 2) + 's';
                    conf.style.animationDelay = (Math.random() * 2) + 's';
                    conf.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    winOverlay.appendChild(conf);
                }
                
                // 自動清除計時器
                if (winOverlayTimeout) clearTimeout(winOverlayTimeout);
                winOverlayTimeout = setTimeout(() => {
                    winOverlay.style.display = 'none';
                    winOverlay.innerHTML = '';
                }, 4500);

                winOverlay.onclick = () => {
                    winOverlay.style.display = 'none';
                    if (winOverlayTimeout) clearTimeout(winOverlayTimeout);
                };
            }
        } else {
            // [關鍵] 如果不是勝利當下的步驟 (例如後續的補述、移動)，強制隱藏遮罩
            winOverlay.style.display = 'none';
            winOverlay.innerHTML = ''; 
        }
        // ------------------------------
        // ------------------------------

		// --- [修改] 取得當前步驟的移動卡片 (通用化) ---
        // 原本只檢查 reveal-zone，現在改為抓取任何 MOVE 操作
        let movingCardIds = [];

        // 只有在播放或重繪當下，檢查當前 Action
        if (currentIndex >= 0 && history[currentIndex]) {
            const action = history[currentIndex].action;
            // 找出這一步驟中的移動操作 (MOVE)
            const moveOp = action.operations.find(o => o.type === 'MOVE');
            if (moveOp) {
                // 記錄正在移動的卡片 ID 列表 (已有順序)
                movingCardIds = moveOp.cardIds;
            }
        }

        requestAnimationFrame(() => {
            const lastPositions = getCardPositions();
            
            Object.keys(lastPositions).forEach(id => {
                if (id.startsWith('ZONE_')) return;
                const cardEl = document.querySelector(`.card[data-id="${id}"]`);
                if (!cardEl) return;
                
                let start = firstPositions[id];
                if (!start && lastRenderedState) {
                    const prevCard = lastRenderedState.cards.find(c => c.id == id);
                    if (prevCard) start = firstPositions['ZONE_' + prevCard.zone];
                }
                
                if (start) {
                    const last = lastPositions[id];
                    const deltaX = start.left - last.left;
                    const deltaY = start.top - last.top;
                    
                    // 只有當位置真的有變動時才執行動畫
                    if (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1) {
                        const cardData = state.cards.find(c => c.id == id);
                        let rotation = cardData ? cardData.rotation : 0;
                        const isAbility = cardData && cardData.zone.includes('ability');

                        // [修正] 如果 DOM 元素上有標記「視覺角度」(來自無月模式)，優先使用它
                        if (cardEl.dataset.visualRot) {
                            rotation = parseFloat(cardEl.dataset.visualRot);
                        }

                        if (cardData && cardData.stackType && cardData.stackType.includes('puzzle')) {
                             // puzzle 卡片通常是跟隨移動，暫不處理個別動畫
                        } else {
                            // 1. 先瞬間移動回起點 (保持在原區域的位置)
                            cardEl.style.transition = 'none';
                            cardEl.style.transform = `translate(${deltaX}px, ${deltaY}px) rotate(${isAbility?0:rotation}deg)`;
                            
                            // 2. 下一幀執行移動動畫
                            requestAnimationFrame(() => {
                                const flyTime = 0.5; // 單張飛行時間 0.5秒
                                
                                let duration = `${flyTime}s`;
                                let delay = '0s';
                                let easing = 'cubic-bezier(0.25, 0.8, 0.25, 1)';

                                // --- [核心修改] 通用序列動畫邏輯 ---
                                // 檢查這張卡片是否在當前的移動清單中
                                // 使用 loose equality (==) 避免字串/數字型別問題
                                const moveIndex = movingCardIds.findIndex(mid => mid == id);

                                if (moveIndex !== -1) {
                                    const totalCards = movingCardIds.length;
                                    
                                    // 如果只有一張牌，就不需要延遲
                                    if (totalCards > 1) {
                                        // 演算法：每張牌間隔飛行時間的 20%
                                        let interval = flyTime * 0.2;
                                        
                                        // 防呆：如果一次移動超多張 (如整副牌 40張)，限制總發牌時間不超過 1.5 秒
                                        // 這樣會變成機關槍式的快速發牌，而不是慢慢發
                                        const maxTotalLag = 1.5;
                                        if ((interval * totalCards) > maxTotalLag) {
                                            interval = maxTotalLag / totalCards;
                                        }
                                        
                                        // 設定延遲：第 N 張牌延遲 N * interval 秒
                                        delay = `${moveIndex * interval}s`;
                                    }
                                }
                                // -------------------------------

                                cardEl.style.transition = `transform ${duration} ${easing} ${delay}`;
                                cardEl.style.transform = `translate(0, 0) rotate(${isAbility?0:rotation}deg)`;
                            });
                        }
                    }
                }
            });
			
            lastRenderedState = cloneState(state);

            // [新增] 王牌進場特效觸發檢查
            // 檢查當前這一步 (currentIndex) 是否有移動操作
            if (currentIndex >= 0 && history[currentIndex]) {
                const action = history[currentIndex].action;
                
                // 1. 找出這一步驟中「所有」的移動操作，而不只是第一個
                const moveOps = action.operations.filter(o => o.type === 'MOVE');
                
                let foundAceEntry = false;

                // 2. 遍歷所有移動操作，檢查是否有王牌進入戰鬥區
                for (const op of moveOps) {
                    if (op.toZone && op.toZone.includes('battle')) {
                        // 使用寬鬆比對 (==) 避免 ID 型態 (字串/數字) 不符的問題
                        const aceId = op.cardIds.find(id => globalAceRegistry[id]);
                        
                        if (aceId) {
                            // --- [修正開始] ---
                            // 3. 檢查「來源區域」：如果它原本就在戰鬥區，就不算「進場」
                            let wasInBattle = false;

                            // 取得「移動前」的狀態 (上一步的狀態，如果是第0步則取初始狀態)
                            const prevState = (currentIndex > 0) ? history[currentIndex - 1].state : initialState;
                            
                            if (prevState) {
                                // 在舊狀態中找到這張卡
                                const prevCard = prevState.cards.find(c => c.id == aceId);
                                // 如果它原本的區域包含 'battle'，表示它只是在戰場內移動
                                if (prevCard && prevCard.zone.includes('battle')) {
                                    wasInBattle = true;
                                }
                            }

                            // 4. 只有當「原本不在戰鬥區」且「還沒播放過」才觸發
                            if (!wasInBattle) {
                                if (currentIndex !== lastAnimatedStep) {
                                    
                                    // [核心修改] 計算精確的落地時間
                                    const flyTime = 0.5; // CSS動畫時間 0.5s
                                    let arrivalTime = flyTime * 1000; // 基礎時間 ms

                                    // 計算這張王牌在移動隊列中的位置，加上延遲時間
                                    // 注意：這裡必須使用寬鬆比對 (mid == aceId)
                                    const mIndex = movingCardIds.findIndex(mid => mid == aceId);
                                    
                                    if (mIndex !== -1 && movingCardIds.length > 1) {
                                        let interval = flyTime * 0.2; // 0.1s
                                        const maxTotalLag = 1.5;
                                        if ((interval * movingCardIds.length) > maxTotalLag) {
                                            interval = maxTotalLag / movingCardIds.length;
                                        }
                                        // 加上它的排隊延遲
                                        arrivalTime += (mIndex * interval * 1000);
                                    }

                                    console.log("觸發王牌特效 (進場) ID:", aceId, "預計落地時間(ms):", arrivalTime);
                                    
                                    // 傳入計算好的時間，確保剛好落地才觸發
                                    triggerAceAnimation(aceId, arrivalTime);
                                    foundAceEntry = true;
                                }
                            }
                            // --- [修正結束] ---

                            // 只要處理過一張王牌就不再繼續 (避免同一步驟多張王牌時重複判斷)
                            break;
                        }
                    }
                }

                // 3. 更新動畫步數紀錄
                // 無論有沒有觸發特效，只要檢查過這一步，就更新 lastAnimatedStep
                // 這樣可以避免重複觸發，也能確保沒特效的步驟被正確標記為「已讀」
                if (currentIndex !== lastAnimatedStep) {
                    lastAnimatedStep = currentIndex;
                }
            }
        });
		
		// --- [修改] 渲染猜拳結果 (加入 !isDrafting 判斷) ---
        const rpsOverlay = document.getElementById('rps-overlay');
        
        // 只有在「有結果」且「不在編輯模式」時才顯示
        if (state.rpsResult && !isDrafting) { 
            const { p1, p2, winner } = state.rpsResult;
            
            // ... (原本的 emoji 與 HTML 生成邏輯保持不變) ...
            const iconMap = { rock: '✊', paper: '🖐️', scissors: '✌️' };
            const p1Class = winner === 1 ? 'winner' : (winner === 2 ? 'loser' : '');
            const p2Class = winner === 2 ? 'winner' : (winner === 1 ? 'loser' : '');

            rpsOverlay.innerHTML = `
                <div class="rps-hand p2 ${p2Class}" style="position:absolute; top:20%;">
                    <div>${iconMap[p2]}</div>
                    <div class="rps-tag">P2</div>
                </div>
                
                <div class="rps-vs">VS</div>
                
                <div class="rps-hand p1 ${p1Class}" style="position:absolute; bottom:20%;">
                    <div>${iconMap[p1]}</div>
                    <div class="rps-tag">P1</div>
                </div>
                
                ${winner === null ? '<div style="position:absolute; font-size:2rem; color:white; font-weight:bold; text-shadow:0 0 5px black; background:rgba(230,126,34,0.9); padding:5px 20px; border-radius:10px;">DRAW!</div>' : ''}
            `;
            
            rpsOverlay.style.display = 'flex';
        } else {
            rpsOverlay.style.display = 'none';
        }
		
		updateSliderUI();
		
		// [新增] 檢查手機版音樂按鈕可見性
		checkMobileMusicButtonVisibility(); // <--- 加入這行

		// [修改] 增加 !skipScroll 判斷，手動點擊時不捲動
        if (!document.body.classList.contains('mobile-mode') && !skipScroll) {
             scrollToActiveStep();
        }
    }
	
	// --- [修正版] 切換無月之門 (Action 版本) ---
    function toggleMoonless() {
        if (!pendingMove || pendingMove.cardIds.length !== 1) return;
        
        // 發送操作指令 (addOperation 會自動處理 state 更新、存檔與重繪)
        addOperation({ 
            type: 'TOGGLE_MOONLESS', 
            cardIds: [...pendingMove.cardIds] 
        });
    }
	
	function checkMobileMusicButtonVisibility() {
		const btn = document.getElementById('mob-music-btn');
		if (!btn) return;

		// 取得當前狀態
		const state = getCurrentDisplayState();
		const currentBgm = state.bgm;

		// [修改需求 3] 當 ActionLog 設定為無音樂 (null/undefined) 時，隱藏按鈕
		if (currentBgm) {
			btn.style.display = 'flex'; // 有音樂：顯示按鈕
			updateMobileMusicUI(); // 同步顯示靜音/播放圖示
		} else {
			btn.style.display = 'none'; // 無音樂：隱藏按鈕
			
			// [補充] 既然沒音樂，確保播放器是安靜的
			if (!globalAudioPlayer.paused) {
				globalAudioPlayer.pause();
			}
		}
	}
	
	// --- [新增] 堆疊偏移量計算系統 ---

    // 1. 定義各種堆疊類型的「原始偏移量」 (假設卡片是直立 0度時的相對位置)
    // --- [數學輔助] 向量旋轉與偏移 ---

    // 1. 定義各種堆疊類型的「原始偏移量」
    function getBaseStackOffset(type) {
        switch (type) {
            case 'top':           return { x: 0, y: 0 };
            case 'bottom':        return { x: 0, y: 0 };
            case 'shift_up':      return { x: 0, y: -25 };
            case 'shift_down':    return { x: 0, y: 25 };
            case 'bottom_exposed':return { x: 0, y: 20 };
            case 'puzzle_top':    return { x: 0, y: -70 };
            case 'puzzle_bottom': return { x: 0, y: 70 };
            case 'puzzle_left':   return { x: -50, y: 0 };
            case 'puzzle_right':  return { x: 50, y: 0 };
            default:              return { x: 0, y: 0 };
        }
    }

    // 2. 向量旋轉公式
    function rotateVector(x, y, deg) {
        const rad = deg * (Math.PI / 180);
        const cos = Math.cos(rad);
        const sin = Math.sin(rad);
        return {
            x: x * cos - y * sin,
            y: x * sin + y * cos
        };
    }
	
	// --- [內部注入版 + Debug Log] 王牌特效函式 ---
	// 修改：增加 startDelay 參數，預設為 400ms (相容舊呼叫)，但我們會傳入計算後的精確時間
	function triggerAceAnimation(cardId, startDelay = 400) {
		console.log(`%c[AceAnim] 收到指令: ID ${cardId} (準備等待 ${startDelay/1000}s...)`, "color: orange");

		// 使用傳入的 startDelay，確保卡片已經飛到位
		setTimeout(() => {
			// 1. 抓取目標卡牌的 DOM
			const cardEl = document.querySelector(`.card[data-id="${cardId}"]`);
			
			if (!cardEl) {
				console.error(`[AceAnim] 錯誤: 找不到 DOM 元素 (ID: ${cardId})`);
				return;
			}

			// 2. 準備顏色邏輯
			const state = getCurrentDisplayState();
			const cardData = state.cards.find(c => c.id === cardId);
			
			if (!cardData) {
				console.warn(`[AceAnim] 警告: 狀態中找不到卡片資料 (ID: ${cardId})`);
				return;
			}

			const colorMap = {
				'red': '255, 0, 0',
				'blue': '0, 191, 255',
				'green': '0, 255, 0',
				'yellow': '255, 215, 0',
				'white': '255, 255, 255',
				'black': '100, 100, 100',
				'rainbow': '255, 0, 255'
			};

			let finalColor = '255, 215, 0'; // 預設金色
			let debugSource = "預設 (金色)"; // 用於 Log 紀錄來源

			// --- 顏色判定邏輯 ---
			let colorFoundFromProxy = false;
			
			// 檢查連結的小卡 (Proxy)
			const proxyCards = state.cards.filter(c => c.zone.includes('ability') && c.sourceId == cardId);
			
			if (proxyCards.length > 0) {
				// ID 越大代表越新
				proxyCards.sort((a, b) => b.id - a.id);
				const activeProxy = proxyCards.find(c => c.glow && colorMap[c.glow]);
				
				if (activeProxy) {
					finalColor = colorMap[activeProxy.glow];
					colorFoundFromProxy = true;
					debugSource = `小卡 (ID:${activeProxy.id}, Glow:${activeProxy.glow})`;
				}
			}

			// 檢查本體 (Self)
			if (!colorFoundFromProxy) {
				if (cardData.glow && colorMap[cardData.glow]) {
					finalColor = colorMap[cardData.glow];
					debugSource = `本體 (Glow:${cardData.glow})`;
				}
			}
			
			console.log(`%c[AceAnim] 判定結果 -> 來源: ${debugSource} | RGB: ${finalColor}`, "color: #2ecc71; font-weight: bold;");
			// -----------------------------

			// 3. 內部注入光暈
			cardEl.classList.add('animating-ace');

			const glowDiv = document.createElement('div');
			glowDiv.className = 'ace-internal-glow';
			glowDiv.style.setProperty('--ace-color', finalColor);

			cardEl.appendChild(glowDiv);

			// 4. 觸發全螢幕白光
			setTimeout(() => {
				const flashLayer = document.getElementById('ace-flash-layer');
				if (flashLayer) {
					flashLayer.classList.remove('anim-flash-white');
					void flashLayer.offsetWidth; // Trigger reflow
					flashLayer.classList.add('anim-flash-white');
				}
			}, 300);

			// 5. 清理工作
			setTimeout(() => {
				if (glowDiv.parentNode) {
					glowDiv.parentNode.removeChild(glowDiv);
				}
				cardEl.classList.remove('animating-ace');
				console.log(`[AceAnim] 動畫結束，清理完成 (ID: ${cardId})`);
			}, 900); 

		}, startDelay); 
	}

    // --- [修改] createCardElement 函式 ---
	function createCardElement(card) {
		const el = document.createElement('div');
		el.className = `card ${card.faceUp ? '' : 'face-down'}`; 
		el.dataset.id = card.id; 

		// [新增] 大紅勾 HTML
        // 注意：這不會覆蓋掉後面的 SVG 或圖片，因為這只是 append 進去
        const checkDiv = document.createElement('div');
        checkDiv.className = 'check-mark';
        checkDiv.innerText = '✔';
        el.appendChild(checkDiv);

        // [新增] 檢查是否在多選清單中
        if (isMultiSelectMode && multiSelectedIds.includes(card.id)) {
            el.classList.add('multi-selected');
        }
		
		// [新增] 1. 插入集氣用的 SVG (長按時顯示)
		// viewBox 設為 0 0 50 70 (配合 CSS var --card-width/height)
		// [修改] 王牌星星 (移除點擊事件，純展示)
        const isAce = !!globalAceRegistry[card.id];
        if (isAce) {
            const star = document.createElement('div');
            star.className = 'ace-star-mark';
            star.innerText = '★';
            // 移除 onclick / onpointerdown，讓事件穿透到卡片本身
            el.appendChild(star);
        }

		// [原有邏輯] 受傷效果 (claw)
		if (card.isInjured) {
			const clawDiv = document.createElement('div');
			const animClass = isDrafting ? '' : 'claw-anim';
			clawDiv.className = `claw-overlay ${animClass}`;
			clawDiv.innerHTML = `
				<svg class="claw-svg" viewBox="0 0 100 100">
					<path class="claw-path p1" d="M20,20 Q50,50 80,80" />
					<path class="claw-path p2" d="M30,10 Q60,40 90,70" />
					<path class="claw-path p3" d="M10,30 Q40,60 70,90" />
				</svg>
			`;
			el.appendChild(clawDiv);
		}
		
		// [原有邏輯] 發光
		if (card.glow) el.classList.add(`glow-${card.glow}`);
		if (card.isContinuous) el.classList.add('continuous');

		// [原有邏輯] 圖片處理
		if (card.image && (card.faceUp || card.isHyper)) {
			// ... (省略圖片處理細節，請保持您原本的程式碼) ...
			// 為了節省篇幅，這裡請保留您原本判斷 imageKey, styleKey, backgroundPosition 的邏輯
			const imageSrc = globalImageRegistry[card.imageKey];
			if (imageSrc) {
				el.style.backgroundImage = `url(${imageSrc})`;
				el.classList.add('has-image');
				if (card.zone.includes('ability')) {
					// ... (Ability 樣式邏輯)
					const lookupKey = card.styleKey || card.imageKey;
					const style = globalAbilityStyleRegistry ? (globalAbilityStyleRegistry[lookupKey] || { x: 50, y: 50, scale: 1 }) : { x: 50, y: 50, scale: 1 };
					el.style.backgroundPosition = `${style.x}% ${style.y}%`;
					el.style.backgroundSize = `${100 * style.scale}%`;
				} else {
					 el.style.backgroundSize = 'cover';
					 el.style.backgroundPosition = 'center';
					 el.style.backgroundRepeat = 'no-repeat';
				}
			}
		}

		// [原有邏輯] 能力卡樣式
		if (card.zone.includes('ability')) {
			el.classList.add('ability-card');
			if (!card.faceUp) el.className = `card ability-card`; 
		} else {
			if (!card.stackType || !card.stackType.includes('puzzle')) {
				el.style.transform = `rotate(${card.rotation}deg)`;
			}
		}
		
		// [原有邏輯] 選取狀態
		if (pendingMove && pendingMove.cardIds.includes(card.id)) {
			el.classList.add('selected');
			if (!card.zone.includes('ability') && el.classList.contains('selected')) {
			   if (!card.stackType || !card.stackType.includes('puzzle')) {
				   el.style.transform = `rotate(${card.rotation}deg) translateY(-5px)`;
			   }
			}
		}
		
		// [原有邏輯] 指向狀態
		if (isPointing && pointTargets.includes(card.id)) {
			el.classList.add('point-target-selected');
		}
		
		// [原有邏輯] 註記
		if (card.note) {
			const noteEl = document.createElement('div');
			noteEl.className = 'card-note';
			noteEl.innerText = card.note;
			el.appendChild(noteEl);
		}

		// [原有邏輯] 文字
		if (card.faceUp || card.zone.includes('ability')) {
			const contentDiv = document.createElement('div');
			contentDiv.style.marginTop = card.note ? '10px' : '0';
			contentDiv.innerHTML = `<div class="card-text">${card.text}</div>`;
			if (card.power > 0) contentDiv.innerHTML += `<div class="card-power">${card.power}</div>`;
			el.appendChild(contentDiv);
		}
		
		let pressTimer = null;
		const startPress = (e) => {
            // 只接受左鍵
            if (e.button !== 0) return;
            
            // 如果已經在多選模式，就不需要長按邏輯了，直接交給 click 處理
            if (isMultiSelectMode) return;

            pressTimer = setTimeout(() => {
                // 1秒後觸發
                // 強制進入多選模式，並將此卡加入選擇
                enterMultiSelectModeByCard(card.id);
                
                // 手機震動回饋
                if (navigator.vibrate) navigator.vibrate(50);
            }, 1000); // 1秒
        };

        const cancelPress = () => {
            if (pressTimer) clearTimeout(pressTimer);
        };

        el.onpointerdown = startPress;
        el.onpointerup = cancelPress;
        el.onpointerleave = cancelPress;
        el.onpointercancel = cancelPress;

		// [原有邏輯] 點擊事件
		const isViewerZone = card.zone.includes('deck') || card.zone.includes('grave') || card.zone.includes('hyper');
		if (!isViewerZone) {
			 el.onclick = (e) => handleCardSingleClick(e, card.id);
		} else {
			 el.onclick = (e) => { e.stopPropagation(); handleZoneClick(card.zone); };
		}
		
		setTimeout(() => el.classList.add('interactive'), 0);
		return el;
	}
	
	// [修正] 透過長按卡片進入多選模式
    function enterMultiSelectModeByCard(cardId) {
        if (isMultiSelectMode) return;
        
        // 切換模式標記
        isMultiSelectMode = true;
        multiSelectedIds = [cardId];
        
        // 設定 pendingMove
        pendingMove = { cardIds: [...multiSelectedIds], shuffle: false };
        
        // 更新 UI
        const el = document.querySelector(`.card[data-id="${cardId}"]`);
        if (el) el.classList.add('multi-selected');
        
        updateSelectionUI();

        // --- [新增] 防呆邏輯 ---
        // 記錄這張卡片的 ID，告訴 handleCardSingleClick 忽略它接下來的「放開」點擊事件
        ignoreClickId = cardId;
        
        // 設定 2 秒後自動清除 (以防使用者長按後一直不放開，或拖曳到別處沒觸發點擊)
        setTimeout(() => {
            if (ignoreClickId === cardId) ignoreClickId = null;
        }, 2000);
    }

    // --- [修改] 點擊卡片處理 ---
	// --- [修正] 點擊卡片處理 (效果卡強制單選) ---
	function handleCardSingleClick(e, cardId) {
		e.stopPropagation(); 
		
		// --- [新增] 檢查是否需要忽略此點擊 (來自長按觸發) ---
        if (ignoreClickId === cardId) {
            ignoreClickId = null; // 消耗掉這次防呆，下次點擊恢復正常
            return; // 直接結束，不執行選取/取消邏輯
        }

		// 1. 手機版點擊檢視邏輯 (維持不變)
		if (document.body.classList.contains('mobile-mode')) {
			const state = getCurrentDisplayState();
			const card = state.cards.find(c => c.id === cardId);
			if (!card) return;
			const ignoredZones = ['p1-deck', 'p2-deck', 'p1-grave', 'p2-grave', 'p1-hyper', 'p2-hyper'];
			const isIgnored = ignoredZones.includes(card.zone) || card.zone.includes('ability');
			if (card.image && card.faceUp && !isIgnored) {
				showMobileCardZoom(card.id);
			}
			return; 
		}
		
		// 2. 多選模式 (維持不變 - 在此模式下依然允許選多張效果卡，方便批次刪除)
		if (isMultiSelectMode) {
			const index = multiSelectedIds.indexOf(cardId);
			const el = document.querySelector(`.card[data-id="${cardId}"]`);
			
			if (index > -1) {
				multiSelectedIds.splice(index, 1);
				if (el) el.classList.remove('multi-selected');
				if (multiSelectedIds.length === 0) {
					cancelSelection(); 
					return;
				}
			} else {
				multiSelectedIds.push(cardId);
				if (el) el.classList.add('multi-selected');
			}
			pendingMove = { cardIds: [...multiSelectedIds], shuffle: false };
			updateSelectionUI();
			return;
		}

		// 3. 指向模式 (維持不變)
		if (isPointing) {
			handlePointClick(null, cardId);
			return;
		}

		// 4. 一般點擊邏輯
		if (pendingMove) {
            // 如果點擊的是「已經被選取」的卡片 -> 取消選取該張
			if (pendingMove.cardIds.includes(cardId)) {
				 pendingMove.cardIds = pendingMove.cardIds.filter(id => id !== cardId);
				 if (pendingMove.cardIds.length === 0) {
					 cancelSelection();
					 return;
				 }
				 updateSelectionUI();
				 return;
			}
			
			const state = getCurrentDisplayState();
			const targetCard = state.cards.find(c => c.id === cardId);
			
            // 堆疊操作邏輯 (維持不變 - 排除能力卡、牌庫等)
			if (targetCard && !targetCard.zone.includes('deck') && !targetCard.zone.includes('grave') && !targetCard.zone.includes('ability')) {
				openStackingModal(targetCard);
				return;
			}

            // --- [關鍵修改] 判斷是否為效果小卡 ---
            if (targetCard && targetCard.zone.includes('ability')) {
                // 如果點擊的是效果小卡，強制變成「單選新卡片」
                // (捨棄原本已經選取的卡片，直接切換焦點到這張新卡)
                pendingMove = { cardIds: [cardId], shuffle: false };
            } else {
                // 如果是普通卡片，維持原本的「加選」行為
                pendingMove.cardIds.push(cardId);
            }
            // ------------------------------------
		} else {
            // 如果沒有選取任何卡片，建立新選取
			pendingMove = { cardIds: [cardId], shuffle: false };
		}
        
		updateSelectionUI();
	}

	// --- [新增] 手機版放大卡圖函式 ---
	function showMobileCardZoom(cardId) {
		const state = getCurrentDisplayState();
		const card = state.cards.find(c => c.id === cardId);
		
		// 取得圖片 (優先找正面圖)
		const imgKey = card.imageKey;
		const src = globalImageRegistry[imgKey];
		
		if (!src) return; // 沒圖就不動作

		// 1. 執行「視覺暫停」 (但不關音樂)
		if (playTimeout) {
			clearTimeout(playTimeout);
			playTimeout = null;
			updatePlayButtonUI(); // 更新按鈕為「暫停」圖示
			// 注意：這裡故意不呼叫 globalAudioPlayer.pause()，以達成背景音樂繼續的需求
		}

		// 2. 顯示放大視窗
		const viewer = document.getElementById('mobile-card-viewer');
		viewer.innerHTML = `<img src="${src}" />`;
		viewer.style.display = 'flex';
	}

	function hideMobileCardZoom() {
		// 1. 關閉視窗
		document.getElementById('mobile-card-viewer').style.display = 'none';
		
		// 2. 恢復播放 (視為按下 Play 鍵)
		togglePlay();
	}
    
    // [修改] 取消選取 (確保也會關閉多選模式)
    function cancelSelection() {
        // 重置多選相關變數
        isMultiSelectMode = false;
        multiSelectedIds = [];
        document.querySelectorAll('.multi-selected').forEach(el => el.classList.remove('multi-selected'));
        
        if (pendingMove) {
            // ... (原本的取消邏輯) ...
            pendingMove = null;
            document.querySelectorAll('.zone').forEach(el => el.classList.remove('target-highlight'));
            document.querySelectorAll('.card.selected').forEach(el => el.classList.remove('selected'));
            document.getElementById('card-action-panel').style.display = 'none';
        }
        
        // 隱藏多選提示列
        const multiBar = document.getElementById('multi-select-bar');
        if(multiBar) multiBar.style.display = 'none';
    }

    function renderArrows() {
        const svg = document.getElementById('svg-layer');
        const workspace = document.getElementById('workspace');
        
        // 防呆：如果 SVG 還是不在 workspace 裡面，強制把它移進去
        if (svg && workspace && svg.parentNode !== workspace) {
            workspace.insertBefore(svg, workspace.firstChild);
        }

        // 清空並重繪 Marker 定義
        svg.innerHTML = `
            <defs>
                <marker id="arrowhead" markerWidth="12" markerHeight="12" refX="10" refY="6" orient="auto" markerUnits="userSpaceOnUse">
                    <path d="M0,0 L12,6 L0,12" fill="#e74c3c" />
                </marker>
            </defs>
        `;
        
        // 取得當前的操作步驟
        let ops = [];
        if (isDrafting) {
            ops = draftOperations;
        } else if (currentIndex >= 0 && history[currentIndex]) {
            ops = history[currentIndex].action.operations;
        }

        if (!ops || ops.length === 0) return;

        // --- 核心修改：計算座標轉換比例 ---
        // 我們需要算出「螢幕像素」轉成「畫布內部像素」的比例
        // workspace.getBoundingClientRect() 取得的是縮放後(螢幕上)的尺寸
        // workspace.offsetWidth 取得的是原始排版(內部)的尺寸 (手機版固定為 1200)
        
        const wsRect = workspace.getBoundingClientRect();
        const scaleX = wsRect.width / workspace.offsetWidth;
        const scaleY = wsRect.height / workspace.offsetHeight;
        
        // 畫布在螢幕上的左上角起點
        const offsetX = wsRect.left;
        const offsetY = wsRect.top;

        // 轉換函式：將螢幕座標 (Screen Coords) 轉為 畫布座標 (Local Coords)
        const toLocal = (rect) => {
            // 1. 算出元素的中心點 (螢幕座標)
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            // 2. 減去畫布起點，並除以縮放比例
            return {
                x: (centerX - offsetX) / scaleX,
                y: (centerY - offsetY) / scaleY
            };
        };

        const pointOps = ops.filter(o => o.type === 'POINT' || o.type === 'ATTACK'); 
        
        pointOps.forEach(op => {
            const attacker = document.querySelector(`.card[data-id="${op.attackerId}"]`);
            if (!attacker) return;
            let targetEls = [];
            // [修正] 增加 || op.targetType === 'ZONE'
            if (op.targetType === 'CARD' || op.targetType === 'CREATURE' || op.targetType === 'SHIELD') {
                if (Array.isArray(op.targetIds)) {
                    op.targetIds.forEach(tid => {
                        const el = document.querySelector(`.card[data-id="${tid}"]`);
                        if(el) targetEls.push(el);
                    });
                }
            } 
            // [新增] 專門處理區域指向 (Zone) 的邏輯
            else if (op.targetType === 'ZONE') {
                if (Array.isArray(op.targetIds)) {
                    op.targetIds.forEach(zid => {
                        // 尋找對應的區域元素
                        const el = document.querySelector(`.zone[data-zone="${zid}"]`);
                        if(el) targetEls.push(el);
                    });
                }
            }
            else if (op.targetType === 'PLAYER') {
                // ... (原本的 PLAYER 邏輯保持不變) ...
                const attackerOwner = attacker.closest('.player-area').id.includes('player1') ? 1 : 2;
                const oppId = attackerOwner === 1 ? 2 : 1;
                const deck = document.querySelector(`.deck-zone[data-zone="p${oppId}-deck"]`);
                if(deck) targetEls.push(deck);
            }
            
            // 使用轉換函式計算起點
            const startPoint = toLocal(attacker.getBoundingClientRect());
            
            targetEls.forEach(target => {
                const endPoint = toLocal(target.getBoundingClientRect());
                const isSelf = (target === attacker);
                
                if (isSelf) {
                    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    const r = 40; 
                    const d = `M ${startPoint.x},${startPoint.y} C ${startPoint.x+r*2},${startPoint.y-r*2} ${startPoint.x-r*2},${startPoint.y-r*2} ${startPoint.x},${startPoint.y}`;
                    path.setAttribute("d", d);
                    path.setAttribute("class", "arrow-line");
                    path.setAttribute("fill", "none");
                    svg.appendChild(path);
                } else {
                    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    line.setAttribute("x1", startPoint.x);
                    line.setAttribute("y1", startPoint.y);
                    line.setAttribute("x2", endPoint.x);
                    line.setAttribute("y2", endPoint.y);
                    line.setAttribute("class", "arrow-line");
                    svg.appendChild(line);
                }
            });
        });
    }

    function renderTimeline() {
        const list = document.getElementById('action-list');
        list.innerHTML = '';
        
        // 輔助函式：建立佔位符 (虛線框)
        const createPlaceholder = () => {
            const li = document.createElement('li');
            li.className = 'action-item placeholder';
            li.innerText = '... 編輯中 (Editing) ...';
            li.id = 'active-placeholder'; // 給個 ID 方便定位
            return li;
        };

        history.forEach((item, index) => {
            const gap = document.createElement('div');
            gap.className = 'timeline-gap';
            gap.title = "插入新步驟";
            
            // [修改] 如果正在編輯且插入點在這裡，gap 失去點擊功能(或隱藏)，並顯示佔位符
            if (isDrafting && editModeType === 'INSERT' && insertIndex === index) {
                gap.style.pointerEvents = 'none'; 
                list.appendChild(gap);
                list.appendChild(createPlaceholder());
            } else {
                gap.onclick = () => startDraft(index);
                list.appendChild(gap);
            }

            const li = document.createElement('li');
            
            let colorClass = '';
            if (item.action.operations && item.action.operations.length > 0) {
                const op = item.action.operations.find(o => o.cardIds && o.cardIds.length > 0);
                if (op) {
                    const cardId = op.cardIds[0];
                    const card = item.state.cards.find(c => c.id === cardId);
                    if (card) {
                        if (card.ownerId === 1) colorClass = 'p1-action';
                        else if (card.ownerId === 2) colorClass = 'p2-action';
                    }
                }
            }

            // 如果正在編輯這一步 (Edit Mode)，給它一個特殊的樣式
            if (isDrafting && editModeType === 'EDIT' && insertIndex === index) {
                li.className = `action-item editing ${colorClass}`;
            } else {
                li.className = `action-item ${index === currentIndex ? 'active' : ''} ${colorClass}`;
            }

            const delBtn = `<button class="icon-btn delete" onclick="event.stopPropagation(); deleteAction(${index})" title="${t('btn_delete_step')}">🗑</button>`;
            //const editBtn = `<button class="mini-btn edit" onclick="event.stopPropagation(); editAction(${index})" data-i18n="btn_edit_step">${t('btn_edit_step')}</button>`;
            
            const controls = `
                <div class="action-controls">
                    <button class="mini-btn play-from" onclick="event.stopPropagation(); playFromStep(${index})" data-i18n="btn_play_from">${t('btn_play_from')}</button>
                    <button class="mini-btn play-step" onclick="event.stopPropagation(); playSingleStep(${index})" data-i18n="btn_play_step">${t('btn_play_step')}</button>
                    ${delBtn}
                </div>
            `;

            // 在 renderTimeline 函式內，找到 li.onclick 設定的部分
			li.onclick = (e) => {
				// 鎖定時禁止點擊切換步驟
				if (isDrafting) return; 
				if(e.target.tagName === 'BUTTON') return;
				
				currentIndex = index;
				
				// [新增] 使用者主動點擊了歷史紀錄，代表他想聚焦在這一步 (可能是為了修改)
                // 所以重置旗標，讓下一個動作觸發 editAction 而不是 startDraftAtEnd
                forceNewStep = false;

                renderUI(true); 
                saveToStorage();
			};

            li.innerHTML = `
                <div class="action-header">
                    <span class="action-index">${index}</span>
                    <span class="action-desc">${item.action.description}</span>
                </div>
                ${controls}
            `;
            list.appendChild(li);
        });
        
        // 處理列表最後面的 Gap
        const endGap = document.createElement('div');
        endGap.className = 'timeline-gap';
        
        // [修改] 如果插入點在最後
        if (isDrafting && editModeType === 'INSERT' && insertIndex === history.length) {
            endGap.style.pointerEvents = 'none';
            list.appendChild(endGap);
            list.appendChild(createPlaceholder());
        } else {
            endGap.onclick = () => startDraftAtEnd();
            list.appendChild(endGap);
        }

        document.getElementById('step-counter').innerText = `${currentIndex}/${history.length-1}`;
        
        // [新增] 如果有佔位符，自動捲動到該位置
        if (isDrafting) {
            const placeholder = document.getElementById('active-placeholder');
            if (placeholder) {
                // 這裡我們不強制 scrollIntoView，因為 startDraft 會處理「鎖定前」的捲動
                // 但如果是因為操作(如貼上圖片)導致的重繪，這裡可以確保它在視野內
                // placeholder.scrollIntoView({ block: 'center', behavior: 'auto' });
            }
        }
    }

    function prevStep() { if (currentIndex > 0) { currentIndex--; renderUI(); saveToStorage(); } }
    function nextStep() { if (currentIndex < history.length - 1) { currentIndex++; renderUI(); saveToStorage(); } }
    
    function playFromStep(idx) { 
        currentIndex = idx; renderUI(); saveToStorage();
        if (!playInterval) togglePlay(); 
    }

    function playSingleStep(idx) {
        if (playTimeout) togglePlay(); 
        if (idx > 0) {
            currentIndex = idx - 1; renderUI();
            setTimeout(() => { currentIndex = idx; renderUI(); saveToStorage(); }, 500);
        } else {
            currentIndex = 0; renderUI(); saveToStorage();
        }
    }

    let playTimeout = null; // 取代 playInterval
	// --- 手機版專用狀態變數 ---
	let wasPlayingBeforePortrait = false; // 記錄轉直前是否正在播放
	let hasEnteredLandscapeOnce = false;  // 記錄是否已經進入過橫向模式(用於第一次自動播放)

    // --- [整合版] 播放控制 (包含 BGM 起始同步) ---
    // --- [整合版] 播放控制 (修復 iOS Safari 音樂問題) ---
    function togglePlay() {
		const isMobile = isMobileDevice();
        if (playTimeout) {
            // --- [暫停邏輯] ---
			clearTimeout(playTimeout);
			playTimeout = null;
			
			updatePlayButtonUI();
			document.body.classList.remove('is-playing');
			
			// [修改需求 1] 手機版暫停時，音樂也要暫停
			if (isMobile) {
				globalAudioPlayer.pause();
			}

        } else {
            // --- [開始播放] ---
            
            // 1. [iOS 關鍵修正] 
            // 在使用者點擊的當下，強制「解鎖」Audio 物件
            // 哪怕現在沒有音樂，也要 play 一下再 pause，或是載入空音軌
            // 這裡我們直接嘗試播放當前應有的音樂，或者讓它處於「準備就緒」狀態
            if (globalAudioPlayer.paused) {
                // 嘗試播放一個空的 Promise 來觸發 AudioContext
                globalAudioPlayer.play().then(() => {
                    // 如果當前其實不該有音樂 (null)，那就立刻暫停，但此時 Audio 已解鎖
                    const currState = (currentIndex >= 0 && history[currentIndex]) ? history[currentIndex].state : initialState;
                    if (!currState.bgm) {
                        globalAudioPlayer.pause();
                    }
                }).catch(e => {
                    console.log("Audio unlock attempt", e);
                });
            }
			
			removePlayHighlight();
			
            if (currentIndex >= history.length - 1) {
                currentIndex = -1; // 從頭開始
            }
            
            document.body.classList.add('is-playing');
            
			// [修改需求 1 延伸] 手機版恢復播放時，如果當前有 BGM 且不是靜音狀態，要恢復音樂
			if (isMobile) {
				 const state = getCurrentDisplayState();
				 if (state.bgm && !globalAudioPlayer.muted) {
					 globalAudioPlayer.play().catch(e => {});
				 }
			}
			
            // 2. BGM 同步邏輯 (確保按下播放的瞬間音樂正確)
            let startBgm = null;
            if (currentIndex >= 0 && history[currentIndex]) {
                startBgm = history[currentIndex].state.bgm;
            } else if (initialState) {
                startBgm = initialState.bgm;
            }

            if (startBgm) {
                const targetSrc = BGM_FOLDER + startBgm;
                // 只有當來源不同時才重置，避免中斷連續播放的音樂
                // 注意：iOS 上 src 若未包含完整路徑可能會有差異，用 includes 判斷較保險
                if (!globalAudioPlayer.src.includes(encodeURI(startBgm))) {
                    globalAudioPlayer.src = targetSrc;
                    globalAudioPlayer.currentTime = 0;
                }
                // 這裡再呼叫一次 play 確保萬無一失
                globalAudioPlayer.play().catch(e => {});
            } else {
                globalAudioPlayer.pause();
            }

            // 開始跑下一步
            playNextStep();
            updatePlayButtonUI();
        }
    }
	
	// --- [新增] 手機版靜音切換 ---
    function toggleMute() {
        // 1. 切換 Audio 物件的靜音狀態
        globalAudioPlayer.muted = !globalAudioPlayer.muted;
        
        // 2. 更新按鈕外觀
        updateMuteButtonUI();
    }

    function updateMuteButtonUI() {
        const btn = document.getElementById('mob-mute-btn');
        if (!btn) return;

        const isMuted = globalAudioPlayer.muted;
        
        if (isMuted) {
            btn.innerText = "🔇";
            // 靜音時按鈕變紅，提示比較明顯
            btn.style.borderColor = "#e74c3c";
            btn.style.color = "#e74c3c";
        } else {
            btn.innerText = "🔊";
            // 回復原本樣式
            btn.style.borderColor = "white";
            btn.style.color = "white";
        }
    }
	
	// --- [新增] Play 鍵發光引導邏輯 ---
    function checkFirstTimePlayHighlight() {
        // 使用 localStorage 記錄使用者是否曾經按過播放
        // 如果沒有紀錄 (null)，代表是第一次
        const hasPlayed = localStorage.getItem('dm_has_played_mobile');
        
        if (!hasPlayed) {
            const btn = document.getElementById('mob-play-btn');
            if (btn) btn.classList.add('btn-highlight');
        }
    }

    function removePlayHighlight() {
        const btn = document.getElementById('mob-play-btn');
        if (btn && btn.classList.contains('btn-highlight')) {
            btn.classList.remove('btn-highlight');
            // 寫入紀錄，下次進來就不會再閃了
            localStorage.setItem('dm_has_played_mobile', 'true');
        }
    }

	// --- [新增] 停止播放函式 ---
    function stopPlayback() {
        // 1. 停止計時器
        if (playTimeout) {
            clearTimeout(playTimeout);
            playTimeout = null;
        }

        // 2. 重置狀態
        currentIndex = 0; // 回到第一步 (初始狀態)
        
        // 3. UI 重置
        updatePlayButtonUI();
        document.body.classList.remove('is-playing'); // 顯示星星/編輯器

        // 4. 音樂重置
        globalAudioPlayer.pause();
        globalAudioPlayer.currentTime = 0;

        // 5. 畫面重繪
        renderUI();
        if(!document.body.classList.contains('mobile-mode')) saveToStorage();
    }

    // --- [修改] playNextStep 函式 (結束時移除 class) ---
	// [修改] playNextStep 函式
    function playNextStep() {
        if (currentIndex < history.length - 1) {
            // 1. 取得「上一步」的 BGM 狀態 (用來比對是否有變化)
            const prevBgm = history[currentIndex].state.bgm;
            
            currentIndex++;
            renderUI(); // 這會渲染畫面
            if(!document.body.classList.contains('mobile-mode')) saveToStorage();
            
            // 2. 取得「這一步」的 BGM 狀態
            const currState = history[currentIndex].state;
            const currBgm = currState.bgm;

            // 3. [核心] 檢查 BGM 是否改變
            // 只有在連續播放模式下 (playTimeout != null) 才執行音樂切換
            // 注意：togglePlay 設定 playTimeout 是在 playNextStep 之前，所以這裡可以判斷
            if (currBgm !== prevBgm) {
                if (currBgm) {
                    // 切換新歌
                    // 只有當 src 真的不同時才重置 (避免同首歌重新播放，雖然這裡邏輯是狀態變了才會進來)
                    if (!globalAudioPlayer.src.includes(currBgm)) {
                        globalAudioPlayer.src = BGM_FOLDER + currBgm;
                        globalAudioPlayer.play().catch(e => console.log("Auto-play blocked", e));
                    } else {
                        // 如果狀態變了但檔名一樣 (罕見，或是從 null 變回同一首)，確保播放
                        globalAudioPlayer.play().catch(e => {});
                    }
                } else {
                    // 狀態變成 null -> 停止
                    globalAudioPlayer.pause();
                }
            }

            // 4. 計算延遲 (No Delay Logic)
            let delay = TIME_ACTION_BASE;
            const currAction = history[currentIndex].action;
            const currOp = currAction.operations ? currAction.operations[0] : null;

            // 如果這一步「只有」設定 BGM，則延遲設為極短 (0 或 50ms)，達成無延遲效果
            // 讓它馬上跳下一步
            if (currAction.operations.length === 1 && currOp && currOp.type === 'SET_BGM') {
                delay = 50; 
            }
            else if (currOp && currOp.type === 'DIALOGUE') {
                // ... (原本的對話延遲邏輯) ...
                const currData = currOp.data;
                // ... (省略原本的字數計算代碼，請保留原樣) ...
                // 為了簡潔，這裡不重複貼上對話計算代碼，請確保原本的邏輯還在
                // 範例：delay = 1000 + textLength * 100;
            }

            // 套用速度倍率
            let finalDelay = delay * currentSpeedFactor;

            playTimeout = setTimeout(playNextStep, finalDelay);
            
        } else {
            // --- [修改這裡] 播放結束的邏輯 ---
			playTimeout = null;
			updatePlayButtonUI(); // 按鈕變回 ▶
			
			// [修改 1] 保持 'is-playing' 狀態
			// 不要執行 document.body.classList.remove('is-playing');
			// 這樣可以隱藏編輯器介面，等待 Ending 特效出現，視覺比較連貫。

			// [修改 2] 也不要立刻暫停音樂，交給 triggerEnding 去做淡出
			// globalAudioPlayer.pause(); 

			// [修改 3] 設定 2 秒後觸發 Ending
			setTimeout(() => {
				triggerEnding();
			}, 2000);
        }
    }
    
    function rotateBoard() { addOperation({type: 'ROTATE'}); }
    
    function exportData() {
        // [新增] 在匯出前執行一次遷移腳本，確保舊資料都被優化
        optimizeAndMigrateImages(); 

        const historyToExport = JSON.parse(JSON.stringify(history));
        historyToExport.forEach((item, index) => { if (index > 0) delete item.state; });
        
        // 執行 GC 過濾，只匯出有用的圖片
        const usedKeys = getUsedImageKeys();
        const cleanImageRegistry = {};
        
        Object.keys(globalImageRegistry).forEach(key => {
            if (usedKeys.has(key)) {
                cleanImageRegistry[key] = globalImageRegistry[key];
            }
        });
        
        const data = {
            history: historyToExport,
            initialState: initialState,
            currentIndex: currentIndex,
            timestamp: Date.now(),
            imageRegistry: cleanImageRegistry, // 使用乾淨的圖庫
            abilityRegistry: globalAbilityStyleRegistry,
			lastUsedStyles: globalLastUsedStyles,
            lastDiagSettings: (typeof lastDiagSettings !== 'undefined') ? lastDiagSettings : null,
            aceRegistry: globalAceRegistry,
        };
        
        const blob = new Blob([JSON.stringify(data, null, 2)], {type:"text/plain"});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `dm-script-${Date.now()}.txt`;
        a.click();
    }
	
	// --- [新增] 圖片最佳化與遷移腳本 ---
	function optimizeAndMigrateImages() {
		console.log("開始執行圖片最佳化與遷移...");
		
		// 1. 建立內容雜湊表 (Base64 -> FirstKey)
		const contentMap = new Map();
		const replacementMap = new Map(); // OldKey -> NewKey

		// 遍歷目前的 Registry，找出重複的圖片
		for (const [key, base64] of Object.entries(globalImageRegistry)) {
			// 跳過頭像
			if (key.startsWith('avatar_')) continue;

			if (contentMap.has(base64)) {
				// 發現重複！記錄下來：這個 key 應該被換成 contentMap 裡存的那個 key
				const existingKey = contentMap.get(base64);
				replacementMap.set(key, existingKey);
			} else {
				// 第一次看到這張圖，以此 key 為主
				contentMap.set(base64, key);
			}
		}

		if (replacementMap.size === 0) {
			console.log("沒有發現重複圖片，無需遷移。");
			return;
		}

		console.log(`發現 ${replacementMap.size} 個重複圖片 Key，開始替換 Reference...`);

		// 2. 遍歷所有狀態，替換卡片的 imageKey
		const replaceInState = (s) => {
			if (!s || !s.cards) return;
			s.cards.forEach(c => {
				// 檢查 imageKey
				if (c.imageKey && replacementMap.has(c.imageKey)) {
					c.imageKey = replacementMap.get(c.imageKey);
				}
				// 檢查 backImageKey
				if (c.backImageKey && replacementMap.has(c.backImageKey)) {
					c.backImageKey = replacementMap.get(c.backImageKey);
				}
			});
		};

		replaceInState(initialState);
		history.forEach(h => {
			replaceInState(h.state);
			if (h.detachedStartState) replaceInState(h.detachedStartState);
		});
		if (tempState) replaceInState(tempState);

		// 3. 清理 globalImageRegistry (刪除被替換掉的 Key)
		// 其實這步可以省略，因為 save/export 時會執行 GC (getUsedImageKeys)，
		// 但為了記憶體整潔，我們手動清一下
		replacementMap.forEach((newKey, oldKey) => {
			delete globalImageRegistry[oldKey];
		});

		console.log("圖片遷移完成！");
		renderUI(); // 重繪確保顯示正常
	}

    function processGameData(data, resetToStart = false) {
        globalImageRegistry = data.imageRegistry || {}; 
		globalAbilityStyleRegistry = data.abilityRegistry || {};
		globalLastUsedStyles = data.lastUsedStyles || {};
		// [新增] 讀取王牌設定
		globalAceRegistry = data.aceRegistry || {};
        
        // [修改] 移除 globalMoonlessRegistry = ...
        // 改為：如果是舊版存檔，將無月設定合併進 initialState
        if (data.moonlessRegistry) {
            if (!data.initialState.moonless) data.initialState.moonless = {};
            Object.assign(data.initialState.moonless, data.moonlessRegistry);
        }

        initialState = data.initialState;
		// 防呆補強
        if (!initialState.moonless) initialState.moonless = {};
		// [建議新增] 確保舊存檔也有 rpsResult 欄位 (雖然 undefined 也不會報錯，但這樣比較乾淨)
		if (initialState.rpsResult === undefined) initialState.rpsResult = null;
        let loadedHistory = data.history;
        if (!loadedHistory[0].state) loadedHistory[0].state = cloneState(initialState);
        for (let i = 1; i < loadedHistory.length; i++) {
			// [新增] BGM 檔案檢查
			const ops = loadedHistory[i].action.operations;
			if (ops) {
				ops.forEach(op => {
					if (op.type === 'SET_BGM' && op.filename) {
						if (!BGM_FILES.includes(op.filename)) {
						// 僅在 Console 顯示警告，方便除錯，但【不將 filename 設為 null】
						console.warn(`[BGM Warning] Script uses: "${op.filename}", which is not in BGM_FILES list.`);
						
						// 註解掉下面這行，因為它會把您的音樂設定刪除！
						// op.filename = null; 
						
						// 註解掉這行，不要修改描述
						// loadedHistory[i].action.description += " (File Missing)";
					}
					}
				});
			}
            if (!loadedHistory[i].state) {
                // [關鍵修改] 匯入重建邏輯
				// 檢查這一步是否有「斷層存檔 (detachedStartState)」
				if (loadedHistory[i].detachedStartState) {
					// 情境 A：有斷層存檔
					// 直接使用存檔中的狀態，忽略「上一步 + 運算」的標準流程
					// 這能確保「不連動」的效果在匯入後依然存在
					loadedHistory[i].state = cloneState(loadedHistory[i].detachedStartState);
				} 
				else {
					// 情境 B：正常連動
					// 抓取上一步的狀態，並執行動作運算
					const prevState = loadedHistory[i-1].state;
					const newState = cloneState(prevState);
					const ops = loadedHistory[i].action.operations;
					ops.forEach(op => applyOperation(newState, op));
					loadedHistory[i].state = newState;
				}
            }
        }
        history = loadedHistory;
        currentIndex = resetToStart ? 0 : (data.currentIndex || 0);
        storageQuotaExceeded = false;
        hasAlertedQuota = false;
        lastRenderedState = null; 
        renderUI();
        saveToStorage();
		// 確保讀取舊存檔後，缺失的預設頭像會被補回來
		if (typeof generateDefaultPortraits === 'function') {
			generateDefaultPortraits();
		}
    }

    function resolveImportConflict(choice) {
        document.getElementById('import-conflict-modal').style.display = 'none';
        if (choice === 'cancel') { pendingImportData = null; return; }
        if (choice === 'save') exportData(); 
        if (choice === 'save' || choice === 'overwrite') {
            if (pendingImportData) {
                try { processGameData(pendingImportData, true); alert(t('msg_import_success')); } 
                catch(e) { alert(t('msg_import_fail')); }
            }
        }
        pendingImportData = null;
    }

    function importData(input) {
        const file = input.files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const data = JSON.parse(e.target.result);
                if(!data.history || !data.initialState) throw new Error("Invalid format");
                if(confirm(t('msg_confirm_import'))) {
                    processGameData(data);
                    alert(t('msg_import_success'));
                }
            } catch(err) { alert(t('msg_import_fail')); console.error(err); }
            input.value = ''; 
        };
        reader.readAsText(file);
    }

    // --- [取代] openSelectorModal 函式 ---
	function openSelectorModal(zoneId) {
		const state = getCurrentDisplayState();
		const cards = getCardsInZone(state, zoneId);
		const body = document.getElementById('modal-body');
		body.innerHTML = '';
		selectedCardsInModal = [];
		
		const title = document.getElementById('modal-title');
		title.innerText = `${getZoneName(zoneId)} (${cards.length})`;
		title.setAttribute('data-zone-id', zoneId); 

		// 反向排序 (Top 在左上)
		for (let i = cards.length - 1; i >= 0; i--) {
			const card = cards[i];
			const index = i; 
			
			const el = document.createElement('div');
			el.className = 'card';
			
			if (card.image && (globalImageRegistry[card.imageKey] || globalImageRegistry[card.backImageKey])) {
				const imgKey = card.imageKey || card.backImageKey;
				el.style.backgroundImage = `url(${globalImageRegistry[imgKey]})`;
				el.classList.add('has-image-icon');
			}

			// [關鍵新增] 視覺呈現：如果卡片有旋轉，在清單中也要轉給使用者看
			if (card.rotation) {
				// 縮小一點避免轉向時遮擋到隔壁的牌
				el.style.transform = `rotate(${card.rotation}deg) scale(0.9)`;
				// 加個邊框提示，讓橫置狀態更明顯
				el.style.boxShadow = '0 0 5px rgba(0,0,0,0.5)';
			}

			el.innerHTML += `<div style="position:absolute; top:2px; left:2px; font-size:10px; color:#888; font-weight:bold; z-index:10;">#${index+1}</div>
							<div class="card-text">${card.text}</div>`;
			
			// 點擊選取邏輯
			el.onclick = () => {
				if (selectedCardsInModal.includes(card.id)) {
					selectedCardsInModal = selectedCardsInModal.filter(id=>id!==card.id);
					el.classList.remove('selected');
				} else {
					selectedCardsInModal.push(card.id);
					el.classList.add('selected');
				}
			};
			body.appendChild(el);
		}
		
		// [UI 新增] 動態插入旋轉按鈕到 Modal 底部
		// 檢查底部是否已經有旋轉控制區，沒有才加 (避免重複添加)
		const modalFooter = document.querySelector('#card-selector-modal .modal-content > div:last-child');
		let rotControls = document.getElementById('modal-rotate-controls');
		
		if (!rotControls && modalFooter) {
			rotControls = document.createElement('div');
			rotControls.id = 'modal-rotate-controls';
			rotControls.style.display = 'inline-flex';
			rotControls.style.gap = '5px';
			rotControls.style.marginRight = '10px';
			
			rotControls.innerHTML = `
				<button onclick="rotateSelectedInModal(-90)" style="background:#7f8c8d;">↶</button>
				<button onclick="rotateSelectedInModal(90)" style="background:#7f8c8d;">↷</button>
			`;
			
			// 插入到 footer 的最前面
			modalFooter.insertBefore(rotControls, modalFooter.firstChild);
		}

		document.getElementById('card-selector-modal').style.display = 'flex';
	}
	
	// --- [新增] 在清單視窗內旋轉卡片 ---
	function rotateSelectedInModal(deg) {
		if (selectedCardsInModal.length === 0) {
			alert("請先選擇要旋轉的卡片");
			return;
		}

		// 1. 執行旋轉動作
		addOperation({ type: 'ROTATE_CARD', cardIds: [...selectedCardsInModal], deg: deg });
		
		// 2. 為了讓使用者立刻看到結果，我們需要重新整理視窗內容
		// 雖然 addOperation 會觸發 renderUI，但不會重繪 modal 內容，所以要手動呼叫
		const zoneId = document.getElementById('modal-title').getAttribute('data-zone-id');
		if (zoneId) {
			// 稍微延遲一下確保 State 更新後再重繪
			setTimeout(() => {
				openSelectorModal(zoneId);
				
				// 恢復選取狀態 (UX 優化：旋轉完不要取消選取，方便連續轉)
				// 注意：openSelectorModal 會清空 selectedCardsInModal，所以我們要重新選上
				// 這裡需要全域變數配合，但簡單的做法是讓使用者重選，或者
				// 我們可以讓 openSelectorModal 支援傳入「預選ID」，但為了不改動太多架構，這裡先讓使用者看到結果即可。
			}, 50);
		}
	}

    function closeSelectorModal() { document.getElementById('card-selector-modal').style.display = 'none'; }
    function prepareMove(shuffle) {
        if(selectedCardsInModal.length===0) return;
        pendingMove = { cardIds: [...selectedCardsInModal], shuffle };
        closeSelectorModal();
        updateSelectionUI();
    }

	function openPositionSelector(zoneId, moveData) {
		const modal = document.getElementById('position-selector-modal');
		const list = document.getElementById('position-list');
		const gui = document.getElementById('stack-gui');
		
		document.getElementById('pos-modal-title').innerText = t('msg_insert_pos_title');
		gui.style.display = 'none';
		list.style.display = 'flex'; 
		list.innerHTML = ''; 
		
		const state = getCurrentDisplayState();
		const cards = getCardsInZone(state, zoneId);

		// [修改] 反向排列邏輯：讓視覺上方 = 牌庫頂 (Array Last)

		// 1. 先放「最頂端」的插槽 (索引 = length)，這代表插在整副牌的最上面
		// 我們給它標示 "Top" (若您的翻譯檔有 val_top 可改用 t('val_top'))
		list.appendChild(createSlotElement(cards.length, "Top", zoneId, true));
		
		// 2. 倒序放入卡片與其下方的插槽
		for (let i = cards.length - 1; i >= 0; i--) {
			const card = cards[i];
			
			// 卡片本體 (參考用)
			const refCard = document.createElement('div');
			refCard.className = 'position-card-ref';
			
			if (card.image && (globalImageRegistry[card.imageKey] || globalImageRegistry[card.backImageKey])) {
				const imgKey = card.imageKey || card.backImageKey;
				refCard.style.backgroundImage = `url(${globalImageRegistry[imgKey]})`;
				refCard.classList.add('has-image-icon');
				refCard.innerHTML = `<span style="display:none;">${card.text}</span>`;
			} else {
				refCard.innerHTML = `<span style="padding:2px; word-break:break-all; line-height:1;">${card.text}</span>`;
			}
			
			const idxBadge = document.createElement('div');
			idxBadge.style.cssText = "position:absolute; top:0; left:0; background:rgba(0,0,0,0.6); color:white; font-size:8px; padding:1px 3px; border-bottom-right-radius:3px;";
			idxBadge.innerText = i + 1;
			refCard.appendChild(idxBadge);
			
			list.appendChild(refCard);

			// 3. 放入該卡片下方的插槽 (索引 = i)
			// 如果 i=0，代表這是最底部的插槽，標示 "Bottom"
			const isBottom = (i === 0);
			list.appendChild(createSlotElement(i, isBottom ? "Bottom" : "", zoneId, isBottom));
		}

		modal.style.display = 'flex';
	}

    // 建立插槽的輔助函式
    function createSlotElement(index, text, zoneId, isTop) {
        const div = document.createElement('div');
        div.className = 'position-slot';
        
        // 如果有傳入文字(底/頂)就顯示文字，否則顯示一個 '+'
        if (text) {
            div.innerHTML = `<span style="font-weight:bold; ${isTop ? 'color:#e74c3c;' : ''}">${text}</span>`;
        } else {
            div.innerHTML = `<span style="opacity:0.3; font-size:1.2rem;">+</span>`;
        }
        
        div.title = `插入至第 ${index} 張牌的位置`;
        div.onclick = () => finishMove(zoneId, index);
        return div;
    }

    function closePositionModal() {
        document.getElementById('position-selector-modal').style.display = 'none';
    }

    window.addEventListener('beforeunload', (e) => {
        if (storageQuotaExceeded) {
            e.preventDefault();
            e.returnValue = '儲存空間已滿，您的資料可能尚未儲存。建議先匯出資料。';
            return e.returnValue;
        }
    });

	// --- [新增] 手機版劇本選擇器邏輯 ---
    // --- [修正] 手機版劇本選擇器邏輯 (含預選修復) ---
    let selectedMobileScript = null;

    function showMobileScriptSelector(defaultFilename) {
        const modal = document.getElementById('mobile-script-selector');
        const listBody = document.getElementById('script-list-body');
        const startBtn = document.getElementById('btn-mobile-start');
        
        listBody.innerHTML = '';
        selectedMobileScript = null;
        startBtn.disabled = true;

        // 1. 處理傳入的預設值 (移除路徑前綴，只留檔名，以防參數帶有 scripts/)
        const cleanDefault = defaultFilename ? defaultFilename.replace(/^scripts\//, '') : '';

        // 2. 渲染清單
        AVAILABLE_SCRIPTS.forEach(script => {
            const el = document.createElement('div');
            el.className = 'script-item';
            
            // 顯示標題與描述
            el.innerHTML = `
                <div class="script-item-title">${script.title}</div>
                <div class="script-item-desc">${script.description}</div>
            `;
            
            // 點擊事件
            el.onclick = () => {
                document.querySelectorAll('.script-item').forEach(i => i.classList.remove('selected'));
                el.classList.add('selected');
                selectedMobileScript = script.filename;
                startBtn.disabled = false;
            };

            // 3. [修正] 預選邏輯 (比對純檔名)
            const cleanScript = script.filename.replace(/^scripts\//, '');
            
            if (cleanDefault && cleanScript === cleanDefault) {
                // 加樣式
                el.classList.add('selected');
                // 設定值
                selectedMobileScript = script.filename;
                // 開按鈕
                startBtn.disabled = false;
                
                // [新增] 自動捲動到該項目 (延遲一下確保 DOM 渲染完畢)
                setTimeout(() => {
                    el.scrollIntoView({ block: 'center', behavior: 'smooth' });
                }, 100);
            }

            listBody.appendChild(el);
        });

        // 顯示介面
        modal.style.display = 'flex';
    }

	// --- [修改] 通用計數器載入函式 (圖片版) ---
    function updateVisitorCounter(targetUrl) {
        const counterDiv = document.getElementById('visitor-counter');
        
        // 1. 如果沒有網址，就隱藏計數器並離開
        if (!targetUrl) {
            counterDiv.style.display = 'none';
            counterDiv.innerHTML = '';
            return;
        }

        // 2. 清空舊的，顯示容器
        counterDiv.innerHTML = '';
        counterDiv.style.display = 'block';

        // 3. 建立 Iframe
        const iframe = document.createElement('iframe');
        iframe.style.width = "120px";
        iframe.style.height = "25px";
        iframe.style.border = "none";
        iframe.style.overflow = "hidden";
        iframe.scrolling = "no";
        
        counterDiv.appendChild(iframe);

        // 4. [關鍵修改] 改用 img 標籤來載入
        const doc = iframe.contentWindow.document;
        doc.open();
        // 設定 body 樣式讓圖片垂直置中
        doc.write(`<body style="margin:0; padding:0; background:transparent; display:flex; align-items:center;">`);
        
        // 舊的寫法 (錯誤原因)： doc.write(`<script src="${targetUrl}"><\/script>`);
        // 新的寫法 (正確)：當作圖片載入
        doc.write(`<img src="${targetUrl}" alt="counter" border="0" style="display:block;">`);
        
        doc.write(`</body>`);
        doc.close();
    }
	
    function confirmMobileScript() {
        if (!selectedMobileScript) return;

        // 1. 關閉選單
        document.getElementById('mobile-script-selector').style.display = 'none';

        // 2. 處理路徑
        const timestamp = Date.now(); 
        const fullPath = 'scripts/' + selectedMobileScript + '?v=' + timestamp;

        // 3. 初始化行動版
        initMobileMode(fullPath);
        
        // 4. 找出劇本資料
        const scriptData = AVAILABLE_SCRIPTS.find(s => s.filename === selectedMobileScript);

        // --- [新增] 語言設定邏輯 (URL優先 > 劇本設定 > 預設zh) ---
        
        // A. 嘗試讀取 URL 參數 (doGet)
        const urlLang = getUrlParameter('lang');
        
        // B. 嘗試讀取劇本設定
        const scriptLang = (scriptData && scriptData.lang) ? scriptData.lang : 'zh';
        
        // C. 判定最終語言
        let targetLang = 'zh'; // 預設值
        
        if (urlLang && ['zh', 'en', 'jp'].includes(urlLang)) {
            targetLang = urlLang; // 如果 URL 有帶有效參數，絕對優先
        } else {
            targetLang = scriptLang; // 否則使用劇本設定 (若劇本沒設，上面已預設為 zh)
        }
        
        // D. 套用語言 (更新 UI 文字與下拉選單)
        changeLanguage(targetLang);
        // 同步更新下拉選單顯示 (雖然手機版看不到，但保持狀態一致)
        const langSelect = document.getElementById('lang-select');
        if (langSelect) langSelect.value = targetLang;

        // -------------------------------------------------------

        // 5. 套用劇本預設速度
        let targetSpeed = 1.0;
        if (scriptData && scriptData.speed !== undefined) {
            targetSpeed = scriptData.speed;
        }
        changePlaybackSpeed(targetSpeed);

        // 6. 音訊解鎖
        globalAudioPlayer.muted = true; 
        globalAudioPlayer.play().catch(e => {
            console.log("Audio context unlocked (muted)");
        });
        
        // 7. 更新劇本專屬計數器
        let urlToLoad = (scriptData && scriptData.counter_url) ? scriptData.counter_url : null;
        updateVisitorCounter(urlToLoad);

        // 8. 更新靜音按鈕 UI
        updateMuteButtonUI();
    }

// --- 新增的手機端邏輯 ---

    function isMobileDevice() {
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }

	function initMobileMode(scriptUrl) {
		document.body.classList.add('mobile-mode');
		
		// 只有在真的是手機裝置時才預設靜音
		if (isMobileDevice()) {
			globalAudioPlayer.muted = true;
		} 

		fetch(scriptUrl, { cache: "no-store" })
			.then(res => { if(!res.ok) throw new Error(res.status); return res.json(); })
			.then(data => {
				if(!data.history || !data.initialState) throw new Error("Invalid script");
				processGameData(data, true);
				
				window.addEventListener('resize', handleOrientation);
				window.addEventListener('orientationchange', handleOrientation);
				
				// 初始檢查
				handleOrientation();
			})
			.catch(e => {
				alert("無法載入劇本: " + e.message);
			});
	}

	function handleOrientation() {
        const overlay = document.getElementById('orientation-overlay');
		const controls = document.getElementById('mobile-controls');
		const isLandscape = window.innerWidth > window.innerHeight;
        
        if (isLandscape) {
            // --- 橫向模式 (播放/繼續) ---
			overlay.style.display = 'none';
			if (controls) controls.style.display = 'flex';
			
			setTimeout(autoScaleBoard, 100);

			// [需求2] 第一次進入橫向 -> 自動播放
			if (!hasEnteredLandscapeOnce) {
				hasEnteredLandscapeOnce = true;
				if (!playTimeout) togglePlay(); 
			} 
			// [需求2] 非第一次，檢查「轉直前」是否為播放狀態
			else if (wasPlayingBeforePortrait) {
				if (!playTimeout) togglePlay(); // 恢復播放
				wasPlayingBeforePortrait = false; // 重置狀態
			}
			// 如果轉直前是暫停，這裡什麼都不做，保持暫停

        } else {
            // --- 直向模式 (暫停) ---
			overlay.style.display = 'flex';
			if (controls) controls.style.display = 'none';

			// [需求1] 轉直就暫停，並記錄狀態
			if (playTimeout) {
				wasPlayingBeforePortrait = true; // 記錄：原本是播的
				togglePlay(); // 執行暫停
			} else {
				wasPlayingBeforePortrait = false; // 記錄：原本就是停的
			}
        }
        
        // 確保按鈕 UI 同步
		updatePlayButtonUI();
    }
	
	// --- [修正版] 手機版音樂開關 (強制同步狀態) ---
	function toggleMobileMusic() {
		const btn = document.getElementById('mob-music-btn');
		
		// 1. 切換靜音狀態
		globalAudioPlayer.muted = !globalAudioPlayer.muted;
		
		// 2. 如果是「解除靜音」(要聽音樂)
		if (!globalAudioPlayer.muted) {
			
			// A. 取得當前盤面狀態
			const state = getCurrentDisplayState();
			const currentBgm = state ? state.bgm : null;

			if (currentBgm) {
				// B. 檢查播放器是否已經載入這首歌
				// 注意：BGM_FOLDER 變數必須存在 (預設是 'bgm/')
				const targetSrc = BGM_FOLDER + currentBgm;
				
				// 如果還沒設定 src，或者 src 不對，就強制設定
				// encodeURI 是為了處理檔名可能有空白或特殊字元
				if (!globalAudioPlayer.src || !globalAudioPlayer.src.includes(encodeURI(currentBgm))) {
					console.log(`[MobileMusic] 初始化載入音樂: ${currentBgm}`);
					globalAudioPlayer.src = targetSrc;
				}

				// C. 強制播放 (因為這是在 click 事件中，瀏覽器會允許)
				const playPromise = globalAudioPlayer.play();
				
				if (playPromise !== undefined) {
					playPromise.then(() => {
						console.log("[MobileMusic] 播放成功");
					})
					.catch(error => {
						console.error("[MobileMusic] 播放失敗 (可能是檔案路徑錯誤或瀏覽器阻擋):", error);
						// 如果失敗，可能是檔案找不到，為避免按鈕狀態顯示為播放但沒聲音，可視情況處理
					});
				}
			} else {
				console.log("[MobileMusic] 當前劇本步驟沒有設定 BGM");
			}
		} else {
			// 如果是「設為靜音」，就不用暫停，只要 mute 即可，保持進度
			// 但如果您希望靜音就暫停省電，也可以加上 globalAudioPlayer.pause();
		}

		// 3. 更新按鈕 UI
		updateMobileMusicUI();
	}

	// 更新音樂按鈕的外觀 (紅/綠/圖示)
	function updateMobileMusicUI() {
		const btn = document.getElementById('mob-music-btn');
		if (!btn) return;

		if (globalAudioPlayer.muted) {
			btn.innerText = "🔇";
			btn.classList.remove('active'); // 沒亮燈代表靜音
		} else {
			btn.innerText = "🔊";
			btn.classList.add('active'); // 亮燈代表播放中
		}
	}

    function autoScaleBoard() {
        const workspace = document.getElementById('workspace');
        if (!workspace) return;

        // 1. 設定虛擬畫布尺寸 (配合 CSS 修改為 1600)
        const VIRTUAL_WIDTH = 1600; 
        const VIRTUAL_HEIGHT = 800;

        // 2. 取得螢幕尺寸
        const screenW = window.innerWidth;
        const screenH = window.innerHeight;

        // 3. 計算縮放比例
        const scaleW = screenW / VIRTUAL_WIDTH;
        const scaleH = screenH / VIRTUAL_HEIGHT;
        let scale = Math.min(scaleW, scaleH);
        
        scale = scale * 0.98; // 留一點邊距

        // 4. 計算置中偏移
        const offsetX = (screenW - VIRTUAL_WIDTH * scale) / 2;
        const offsetY = (screenH - VIRTUAL_HEIGHT * scale) / 2;

        // 5. 應用樣式
        workspace.style.transform = `scale(${scale})`;
        workspace.style.left = `${offsetX}px`;
        workspace.style.top = `${offsetY}px`;
        
        // 重繪 SVG
        const svg = document.getElementById('svg-layer');
        if(svg) {
            svg.style.display = 'none';
            svg.offsetHeight; 
            svg.style.display = 'block';
        }
    }

    // 監聽轉向與視窗變化
    window.addEventListener('resize', () => {
        if(document.body.classList.contains('mobile-mode')) {
             requestAnimationFrame(() => {
                 const isLandscape = window.innerWidth > window.innerHeight;
                 if(isLandscape) autoScaleBoard();
             });
        }
    });
	
	// --- [新增] 開啟關於視窗 ---
    function openAboutModal() {
        document.getElementById('about-modal').style.display = 'flex';
    }

	/*
    // 改寫 togglePlay 以同步更新手機版按鈕文字
    const originalTogglePlay = togglePlay;
    togglePlay = function() {
        // 呼叫原本的邏輯
        originalTogglePlay();
        
        // 更新手機版按鈕
        const mobBtn = document.getElementById('mob-play-btn');
        const deskBtn = document.getElementById('btn-play');
        
        // [Bug 原因] 這裡還在用舊變數 playInterval，導致判斷錯誤
        const icon = playInterval ? "⏸" : "▶"; 
        if(mobBtn) mobBtn.innerText = icon;
    };
	*/

    // --- Main Entry Point ---
    window.onload = function() {
        // 1. 基本初始化
        const urlParams = new URLSearchParams(window.location.search);
        let scriptUrl = urlParams.get('scriptUrl');
        if (scriptUrl) {
            scriptUrl = 'scripts/' + scriptUrl;
        }
        const isMobile = isMobileDevice();

        // 生成預設頭像
        generateDefaultPortraits();

        // 啟動面板拖曳功能 (電腦版/手機版皆初始化，雖然手機版主要隱藏面板，但防止報錯)
        initDraggablePanel();

        // ----------------------------------------------------
        // [修改] 2. 優先處理 URL 參數 (lang & speed) - 通用邏輯
        // 這樣無論是手機還是電腦，都會吃到設定
        // ----------------------------------------------------

        // A. 處理語言 (lang)
        const pLang = getUrlParameter('lang');
        if (pLang && ['zh', 'en', 'jp'].includes(pLang)) {
            // 同步下拉選單 (電腦版有選單，手機版雖隱藏但 DOM 存在)
            const langSelect = document.getElementById('lang-select');
            if (langSelect) langSelect.value = pLang;
            
            // 套用語言設定 (更新全域變數 currentLang 並刷新 UI 文字)
            changeLanguage(pLang);
        }

        // ----------------------------------------------------


        // 3. 根據裝置載入資料
        if (isMobile) {
            // --- [修改] 手機版邏輯 ---
            
            // 判斷 URL 是否有帶 scriptUrl
            // 注意：這裡 urlParams.get('scriptUrl') 抓到的是純檔名 (例如 demo.json)
            const rawScriptParam = urlParams.get('scriptUrl');

            if (!rawScriptParam) {
                // 如果沒帶參數，預設顯示選單，並且不選取任何項目 (或您可以指定第一個為預設)
                showMobileScriptSelector(null);
            } else {
                // 如果有帶參數，顯示選單並將該檔案設為預設選取
                showMobileScriptSelector(rawScriptParam);
            }
            
            // 初始化靜音按鈕狀態
            updateMuteButtonUI();
            
        } else {
		
			// [新增] 載入預設計數器 (桌機版專用)
            updateVisitorCounter(DEFAULT_COUNTER_URL);
			
            // --- 電腦版邏輯 ---
            const hasLocalData = loadFromStorage();

            if (scriptUrl) {
                console.log("Found scriptUrl:", scriptUrl);
                fetch(scriptUrl)
                    .then(res => { if(!res.ok) throw new Error(res.status); return res.json(); })
                    .then(data => {
                        if(!data.history || !data.initialState) throw new Error("Invalid script");
                        if (hasLocalData) {
                            pendingImportData = data;
                            document.getElementById('import-conflict-modal').style.display = 'flex';
                        } else {
                            processGameData(data, true);
                        }
                        // 清除 URL 避免重新整理重複觸發 (電腦版行為)
                        window.history.replaceState({}, document.title, window.location.pathname);
                    })
                    .catch(e => {
                        alert(t('msg_load_script_fail') + e.message);
                        if(!hasLocalData) openSetupModal();
                    });
            } else {
                if (!hasLocalData) openSetupModal();
            }
        }
    };
	
	// --- 進度條控制函式 ---

    function handleSliderChange(val) {
        const step = parseInt(val);
        // 如果正在播放，先暫停以免衝突，或者保持播放但跳轉
        // 這裡選擇直接跳轉並更新畫面
        currentIndex = step;
        renderUI();
        
        // 只有在非手機模式才存檔，避免覆蓋
        if(!document.body.classList.contains('mobile-mode')) {
            saveToStorage();
        }
    }

    function updateSliderUI() {
        const slider = document.getElementById('playback-slider');
        const tooltip = document.getElementById('slider-tooltip');
        
        if (slider && history.length > 0) {
            // 設定最大值為歷史紀錄長度
            slider.max = history.length - 1;
            
            // 設定當前值
            slider.value = currentIndex;
            
            // 更新文字提示 (例如: 5/120)
            tooltip.innerText = `${currentIndex}/${history.length - 1}`;
            
            // 視覺優化：根據進度改變軌道背景顏色 (已讀部分亮，未讀部分暗)
            const percent = (currentIndex / (history.length - 1)) * 100;
            slider.style.background = `linear-gradient(to right, #3498db ${percent}%, rgba(255,255,255,0.3) ${percent}%)`;
        }
    }
	
	function scrollToActiveStep() {
        // 1. 找到目前被標記為 active 的步驟項目
        const activeItem = document.querySelector('.action-item.active');
        const listContainer = document.getElementById('action-list');
        
        if (activeItem && listContainer) {
            // 2. 計算捲動位置，讓該項目出現在列表視窗的中間
            // 使用 scrollIntoView 是最簡單的 API
            // block: 'center' 會盡量將該元素置中
            // behavior: 'auto' 瞬間跳轉，避免拖曳進度條時畫面晃動太厲害
            activeItem.scrollIntoView({ block: 'center', behavior: 'auto' });
        }
    }
	
	// --- Dialogue Editor Logic ---
    let lastDiagSettings = { 
        p1: { name: 'Player', emotion: 'normal' }, 
        p2: { name: 'Rival', emotion: 'normal' } 
    };
	
	// [新增] 用來記錄最後點擊的是哪一邊 (p1 或 p2)
    let lastFocusPid = 'p1';

    function openDialogueModal() {
        // 1. 檢查是否正在編輯非對話的動作
        if (isDrafting && draftOperations.length > 0 && !draftOperations.some(o => o.type === 'DIALOGUE')) {
            alert("目前正在編輯其他動作，請先 [儲存] 或 [取消] 後再插入對話。");
            return;
        }

        // 2. 智慧插入點：如果沒在編輯，預設插入在「當前步驟之後」
        if (!isDrafting) {
            // currentIndex 是當前看到的步驟，+1 代表插在它後面 (即 #12 和 #13 之間，若當前是 #12)
            // 如果是初始狀態 (-1)，則插在 0
            const nextIndex = currentIndex + 1;
            startDraft(nextIndex);
        }

        generateDefaultPortraits();
        renderEmotionGrid('p1');
        renderEmotionGrid('p2');
        
        // 3. 讀取資料或預設值
        let found = false;
        // 如果是編輯模式且已經有對話資料，載入它
        if (draftOperations.length > 0 && draftOperations[0].type === 'DIALOGUE') {
             loadDiagToForm(draftOperations[0].data);
             found = true;
        } else {
            // 否則往回找最近的設定當作預設
            for(let i=currentIndex; i>=0; i--) {
                const op = history[i].action.operations.find(o => o.type === 'DIALOGUE');
                if (op) {
                    loadDiagToForm(op.data); // 繼承上次的設定 (包含頭像、特效)
                    found = true;
                    break;
                }
            }
        }

        if (!found) {
            // 全新預設
            document.getElementById('edit-p1-emotion').value = lastDiagSettings.p1.emotion;
            document.getElementById('edit-p2-emotion').value = lastDiagSettings.p2.emotion;
            selectEmotion('p1', lastDiagSettings.p1.emotion);
            selectEmotion('p2', lastDiagSettings.p2.emotion);
        }

        document.getElementById('dialogue-modal').style.display = 'flex';
    }
	
	// --- [新增] P1/P2 圖片全交換與翻轉邏輯 ---

    // 1. 輔助函式：產生預設頭像的 Base64 (用於比對是否為預設圖)
    function getFaceData(pid, emotion) {
        const color = pid === 'p1' ? '#3498db' : '#c0392b';
        const canvas = document.createElement('canvas');
        canvas.width = 160; canvas.height = 160;
        const ctx = canvas.getContext('2d');
        
        // 繪製邏輯 (與 generateDefaultPortraits 保持一致)
        ctx.fillStyle = '#222'; ctx.fillRect(0,0,160,160);
        ctx.lineWidth = 4; ctx.strokeStyle = color; ctx.strokeRect(5,5,150,150);
        ctx.beginPath(); ctx.arc(80, 80, 50, 0, Math.PI*2); ctx.stroke();
        
        // 眼睛
        ctx.beginPath();
        if(emotion==='blank') { ctx.arc(65, 70, 3, 0, Math.PI*2); ctx.arc(95, 70, 3, 0, Math.PI*2); }
        else if(emotion==='serious') { ctx.moveTo(55,65); ctx.lineTo(75,75); ctx.moveTo(105,65); ctx.lineTo(85,75); }
        else if(emotion==='furious') { ctx.moveTo(55,60); ctx.lineTo(75,80); ctx.moveTo(105,60); ctx.lineTo(85,80); }
        else if(emotion==='terrified') { ctx.arc(65, 70, 8, 0, Math.PI*2); ctx.arc(95, 70, 8, 0, Math.PI*2); }
        else { ctx.arc(65, 70, 5, 0, Math.PI*2); ctx.arc(95, 70, 5, 0, Math.PI*2); }
        ctx.stroke();

        // 嘴巴
        ctx.beginPath();
        if(emotion==='smug') { ctx.arc(80, 90, 10, 0, Math.PI, false); }
        else if(emotion==='furious') { ctx.moveTo(70,105); ctx.lineTo(90,105); ctx.rect(70,100,20,10); }
        else if(emotion==='terrified') { ctx.ellipse(80, 110, 10, 15, 0, 0, Math.PI*2); }
        else if(emotion==='serious') { ctx.moveTo(70,105); ctx.lineTo(90,105); }
        else { ctx.arc(80, 90, 15, 0, Math.PI, false); }
        ctx.stroke();

        return canvas.toDataURL();
    }

    // 2. 輔助函式：水平翻轉圖片
    function flipImage(base64) {
        return new Promise((resolve) => {
            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                // 水平翻轉
                ctx.translate(canvas.width, 0);
                ctx.scale(-1, 1);
                ctx.drawImage(img, 0, 0);
                resolve(canvas.toDataURL('image/jpeg', 0.85));
            };
            img.src = base64;
        });
    }

    // 3. 主執行函式
    async function swapAndFlipAllPortraits() {
        if (!confirm(t('msg_confirm_swap'))) return;

        const emotions = ['normal', 'blank', 'serious', 'smug', 'furious', 'terrified'];
        
        // 為了避免讀取到剛寫入的資料，我們先把所有新圖片算好，再一次寫入
        const newImages = {};

        for (let emo of emotions) {
            // 取得目前的 Key
            const p1Key = `avatar_p1_${emo}`;
            const p2Key = `avatar_p2_${emo}`;
            
            const p1Current = globalImageRegistry[p1Key];
            const p2Current = globalImageRegistry[p2Key];
            
            // 產生該表情的「預設圖」字串，用來比對
            const p1Default = getFaceData('p1', emo);
            const p2Default = getFaceData('p2', emo);

            // --- 處理 P1 的新圖片 (來源是 P2) ---
            if (p2Current === p2Default) {
                // 如果 P2 原本是用預設圖，那 P1 就改用 P1 自己的預設圖 (不翻轉)
                newImages[p1Key] = p1Default;
            } else {
                // 如果 P2 是自訂圖，則翻轉後給 P1
                newImages[p1Key] = await flipImage(p2Current);
            }

            // --- 處理 P2 的新圖片 (來源是 P1) ---
            if (p1Current === p1Default) {
                // 如果 P1 原本是用預設圖，那 P2 就改用 P2 自己的預設圖 (不翻轉)
                newImages[p2Key] = p2Default;
            } else {
                // 如果 P1 是自訂圖，則翻轉後給 P2
                newImages[p2Key] = await flipImage(p1Current);
            }
        }

        // 全部計算完畢後，寫入全域註冊表
        Object.assign(globalImageRegistry, newImages);

        // 更新介面
        renderEmotionGrid('p1');
        renderEmotionGrid('p2');
        
        // 如果目前正在顯示預覽圖，也要更新
        ['p1', 'p2'].forEach(id => {
            const currentEmo = document.getElementById(`edit-${id}-emotion`).value;
            selectEmotion(id, currentEmo);
        });

        saveToStorage();
        alert(t('msg_swap_done'));
    }

    function renderEmotionGrid(pid) {
        const grid = document.getElementById(`emotion-grid-${pid}`);
        grid.innerHTML = '';
        EMOTIONS.forEach(emo => {
            const div = document.createElement('div');
            div.className = 'emotion-opt';
            div.title = EMOTION_LABELS[emo];
            div.dataset.emo = emo;
            div.onclick = () => selectEmotion(pid, emo);
            
            const key = `avatar_${pid}_${emo}`;
            div.style.backgroundImage = `url(${globalImageRegistry[key]})`;
            
            grid.appendChild(div);
        });
    }

    function selectEmotion(pid, emo) {
        // [新增] 記錄目前焦點
        lastFocusPid = pid;
        
        document.getElementById(`edit-${pid}-emotion`).value = emo;
        document.querySelectorAll(`#emotion-grid-${pid} .emotion-opt`).forEach(el => {
            el.classList.toggle('active', el.dataset.emo === emo);
        });
    }

    function loadDiagToForm(data) {
        ['p1', 'p2'].forEach(id => {
            const d = data[id];
            document.getElementById(`edit-${id}-active`).checked = d.active;
            if(d.active) {
                document.getElementById(`edit-${id}-name`).value = d.name;
                document.getElementById(`edit-${id}-text`).value = d.dataText;
                document.getElementById(`edit-${id}-size`).value = d.size;
                document.getElementById(`edit-${id}-effect`).value = d.effect;
                // [新增] 載入退場特效，如果舊存檔沒有這個欄位，預設為 direct
                document.getElementById(`edit-${id}-exit`).value = d.exit || 'direct';
                
                selectEmotion(id, d.emotion);
            }
            toggleDiagEdit(id);
        });
    }

    function toggleDiagEdit(id) {
        const active = document.getElementById(`edit-${id}-active`).checked;
        // 簡單的視覺回饋：變灰
        const els = document.querySelectorAll(`#edit-${id}-name, #edit-${id}-text, #edit-${id}-size, #edit-${id}-effect`);
        els.forEach(el => el.disabled = !active);
    }

    function confirmDialogue() {
        // [修改] 增加讀取 exit 欄位
        const getData = (id) => ({
            active: document.getElementById(`edit-${id}-active`).checked,
            name: document.getElementById(`edit-${id}-name`).value,
            dataText: document.getElementById(`edit-${id}-text`).value,
            size: document.getElementById(`edit-${id}-size`).value,
            effect: document.getElementById(`edit-${id}-effect`).value,
            exit: document.getElementById(`edit-${id}-exit`).value, // 新增這行
            emotion: document.getElementById(`edit-${id}-emotion`).value
        });

        const p1Data = getData('p1');
        const p2Data = getData('p2');
        
        if(p1Data.active) lastDiagSettings.p1 = { name: p1Data.name, emotion: p1Data.emotion };
        if(p2Data.active) lastDiagSettings.p2 = { name: p2Data.name, emotion: p2Data.emotion };

        // 注意：這裡不需要再呼叫 startDraft，因為 openDialogueModal 已經幫我們做好了
        
        // 若 draftOperations 已有對話 (編輯模式)，先清空避免重複 push
        if (draftOperations.length > 0 && draftOperations[0].type === 'DIALOGUE') {
            draftOperations = [];
        }

        addOperation({
            type: 'DIALOGUE',
            data: { p1: p1Data, p2: p2Data }
        });

        let desc = "[對話] ";
        if (p2Data.active) desc += `${p2Data.name}: ${p2Data.dataText.substr(0,8)}... `;
        if (p1Data.active) desc += `${p1Data.name}: ${p1Data.dataText.substr(0,8)}...`;
        
        saveDraft(desc);
        document.getElementById('dialogue-modal').style.display = 'none';
        
        document.getElementById('edit-p1-text').value = '';
        document.getElementById('edit-p2-text').value = '';
    }

    // --- 統一的貼上監聽器 (Unified Paste Handler) ---
	document.addEventListener('paste', (e) => {
		const items = (e.clipboardData || e.originalEvent.clipboardData).items;
		let blob = null;

		for (let item of items) {
			if (item.kind === 'file' && item.type.startsWith('image/')) {
				blob = item.getAsFile();
				break;
			}
		}
		if (!blob) return;

		// 1. 情境 A：對話視窗開啟中 -> 處理頭像 (修復邏輯已補回)
		const diagModal = document.getElementById('dialogue-modal');
		if (diagModal && diagModal.style.display === 'flex') {
			const url = URL.createObjectURL(blob);
			const img = new Image();
			img.onload = () => {
				const canvas = document.createElement('canvas');
				const ctx = canvas.getContext('2d');
				
				// 設定頭像儲存尺寸 (正方形)
				const size = 200; 
				canvas.width = size;
				canvas.height = size;

				// 繪製深色背景
				ctx.fillStyle = "#222";
				ctx.fillRect(0, 0, size, size);

				// 計算縮放比例 (Cover 模式：填滿正方形)
				let sWidth = img.width;
				let sHeight = img.height;
				const ratio = Math.max(size / sWidth, size / sHeight);
				const newWidth = sWidth * ratio;
				const newHeight = sHeight * ratio;
				
				// 置中裁切
				const dx = (size - newWidth) / 2;
				const dy = (size - newHeight) / 2;

				ctx.drawImage(img, dx, dy, newWidth, newHeight);

				const base64 = canvas.toDataURL('image/jpeg', 0.85);
				
				// 根據最後點擊的腳色 (p1/p2) 與當前選中的表情 (emotion) 來決定 Key
				const currentEmo = document.getElementById(`edit-${lastFocusPid}-emotion`).value;
				const key = `avatar_${lastFocusPid}_${currentEmo}`;
				
				// 更新全域圖片註冊表
				globalImageRegistry[key] = base64;
				
				// 立即更新編輯器上的預覽圖示
				const activeOpt = document.querySelector(`#emotion-grid-${lastFocusPid} .emotion-opt[data-emo="${currentEmo}"]`);
				if (activeOpt) {
					activeOpt.style.backgroundImage = `url(${base64})`;
				}
				
				// 釋放記憶體
				URL.revokeObjectURL(url);
				
				// 嘗試存檔 (非強制，僅更新 core data 內的 registry)
				saveToStorage();
			};
			img.src = url;
			e.preventDefault();
			return;
		}

		// [新增] 2. 情境 C：卡片清單視窗 (Deck/Grave View) 開啟中 -> 處理指定卡片
		const selectorModal = document.getElementById('card-selector-modal');
		if (selectorModal && selectorModal.style.display === 'flex') {
				// 檢查是否剛好選中了一張牌
				if (selectedCardsInModal.length === 1) {
					const reader = new FileReader();
					reader.onload = (event) => {
						// 呼叫 processImage 並傳入選中的卡片 ID
						processImage(event.target.result, selectedCardsInModal[0]);
					};
					reader.readAsDataURL(blob);
					e.preventDefault();
					return;
				}
		}

		// 3. 情境 B：桌面選取卡片中 -> 處理卡圖
		if (pendingMove && pendingMove.cardIds.length === 1) {
			const reader = new FileReader();
			reader.onload = (event) => {
				processImage(event.target.result); // 不傳參數，預設用 pendingMove
			};
			reader.readAsDataURL(blob);
			e.preventDefault();
			return;
		}
	});
	
	// --- [修正版] Ending 特效函式 (手機字體優化 + 強制靜音) ---
	function triggerEnding() {
		console.log("📺 觸發 CRT 關機特效...");

		// 1. 音樂淡出邏輯 (相容手機版)
		if (typeof globalAudioPlayer !== 'undefined' && !globalAudioPlayer.paused) {
			// 設定 2 秒淡出
			const fadeTime = 2000; 
			const stepTime = 100; // 每 0.1 秒降一次
			const steps = fadeTime / stepTime;
			const volStep = globalAudioPlayer.volume / steps;

			const fadeAudio = setInterval(() => {
				// 嘗試降低音量 (Android/Desktop 有效)
				if (globalAudioPlayer.volume > volStep) {
					try { globalAudioPlayer.volume -= volStep; } catch(e){}
				} else {
					// 結束淡出
					clearInterval(fadeAudio);
					globalAudioPlayer.pause();
					// 恢復音量給下次使用 (try-catch 避免 iOS 報錯)
					try { globalAudioPlayer.volume = 1.0; } catch(e){}
				}
			}, stepTime);

			// [重要] iOS 強制靜音保險：
			// 由於 iOS Safari 忽略 volume 修改，上面的淡出可能無效。
			// 設定一個計時器，時間到直接暫停，確保音樂不會一直播。
			setTimeout(() => {
				if (!globalAudioPlayer.paused) globalAudioPlayer.pause();
			}, fadeTime + 100);
		}

		// 2. 加上 class 觸發 CSS 動畫 (開始關機)
		document.body.classList.add('shutdown-mode');

		// 3. 顯示 FIN 字幕
		setTimeout(() => {
			const overlay = document.getElementById('ending-overlay');
			if (overlay) {
				overlay.style.display = 'flex';
				overlay.style.pointerEvents = 'auto'; // 開啟阻擋
				// 強制 Reflow 觸發 transition
				void overlay.offsetWidth; 
				overlay.style.opacity = 1; 
			}

			// 裝置判斷邏輯
			const isMobile = document.body.classList.contains('mobile-mode');

			if (!isMobile) {
				// [桌機版]：3.5秒後自動重置
				setTimeout(() => {
					resetEnding();
				}, 3500);
			} else {
				// [手機版]：畫面停留在 FIN，音樂已在上面被處理為靜音
				console.log("Mobile mode: Ending screen remains.");
			}

		}, 500); // 等待 CSS animation (0.5s) 跑完
	}

	// 測試用：雙擊螢幕左上角可重置 (隱藏 Ending 回到編輯器)
	// 這方便你在編輯時如果不小心觸發了，可以點回來
	document.addEventListener('dblclick', (e) => {
		if (e.clientX < 50 && e.clientY < 50) {
			resetEnding();
		}
	});

	function resetEnding() {
		// 移除動畫 Class
		document.body.classList.remove('shutdown-mode');
		
		// 隱藏遮罩
		const overlay = document.getElementById('ending-overlay');
		if (overlay) {
			overlay.style.opacity = 0;
			overlay.style.pointerEvents = 'none';
			setTimeout(() => { overlay.style.display = 'none'; }, 1000);
		}

		// [桌機版關鍵]：移除 is-playing，這會讓編輯器介面 (Toolbar, Timeline) 重新出現
		// 使用者此時會停在最後一個步驟，可以直接開始新增 Action Log
		document.body.classList.remove('is-playing');
		updatePlayButtonUI();
	}
	
</script>
<div id="visitor-counter" style="display:none"></div>
<div id="ace-flash-layer"></div>
<div id="mobile-card-viewer" onclick="hideMobileCardZoom()"></div>
<div id="mobile-script-selector">
    <h2 style="color:white; margin:0 0 10px 0;">選擇劇本 (Select Script)</h2>
    <div class="script-list-container" id="script-list-body">
        </div>
    <button id="btn-mobile-start" onclick="confirmMobileScript()" disabled>▶ START</button>
</div>
<div id="ending-overlay">
    <div class="end-title">FIN.</div>
    <div class="end-sub">Thanks for Watching</div>
    
    <div class="end-credits">
        <div class="credit-group">
            <div class="credit-role">Project Lead & Design</div>
            <div class="credit-name">Ether</div>
        </div>
        <div class="credit-group">
            <div class="credit-role">Coding & Implementation</div>
            <div class="credit-name">Google Gemini</div>
        </div>
        <div class="credit-group">
            <div class="credit-role">Music / BGM Assets</div>
            <div class="credit-name">魔王魂 (MaouDamashii)</div>
        </div>
    </div>
</div>
<div id="rps-overlay"></div>
</body>
</html>