<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DM TCG Editor v1.0 - Logic Updated</title>
    <style>
        :root {
            --card-width: 50px;
            --card-height: 70px;
            --bg-color: #dcdcdc;
            --p1-color: #e3f2fd;
            --p2-color: #fce4ec;
            --timeline-width: 320px;
            --highlight-color: #f1c40f;
        }

        * { box-sizing: border-box; }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #toolbar {
            height: 45px;
            background: #2c3e50;
            color: white;
            display: flex;
            align-items: center;
            padding: 0 10px;
            gap: 10px;
            flex-shrink: 0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 50;
        }

        #draft-bar {
            background: #e67e22;
            color: white;
            padding: 5px 10px;
            display: none;
            align-items: center;
            justify-content: space-between;
            font-size: 0.9rem;
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        #draft-bar label {
            display: flex; align-items: center; gap: 5px; cursor: pointer; user-select: none;
            background: rgba(0,0,0,0.1); padding: 2px 8px; border-radius: 4px;
        }

        #point-bar {
            background: #8e44ad;
            color: white;
            padding: 5px 10px;
            display: none;
            align-items: center;
            justify-content: space-between;
            font-size: 0.9rem;
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        #card-action-panel {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(44, 62, 80, 0.95);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            display: none;
            gap: 10px;
            align-items: center;
            z-index: 1000;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            backdrop-filter: blur(5px);
            border: 1px solid #555;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 95vw;
        }
        
        button {
            background: #34495e;
            color: white;
            border: 1px solid #566573;
            padding: 4px 10px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 0.85rem;
            transition: all 0.2s;
        }
        button:hover { background: #4e6479; transform: translateY(-1px); }
        button:active { transform: translateY(1px); }
        
        button.primary { background: #2ecc71; border-color: #27ae60; font-weight: bold; }
        button.primary:hover { background: #27ae60; }
        
        button.danger { background: #c0392b; border-color: #e74c3c; }
        button.danger:hover { background: #e74c3c; }

        input[type="text"], input[type="number"] {
            padding: 4px;
            border-radius: 4px;
            border: 1px solid #ccc;
            font-size: 0.85rem;
        }

        #workspace {
            display: flex;
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        #svg-layer {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			pointer-events: none; 
			z-index: 999; 
			/* ç¢ºä¿æ²’æœ‰å…¶ä»– transform å¹²æ“¾ï¼Œå®ƒæœƒç¹¼æ‰¿çˆ¶å±¤ workspace çš„ scale */
		}
        
        .arrow-line {
            stroke: rgba(231, 76, 60, 0.8);
            stroke-width: 4;
            stroke-dasharray: 10, 5;
            animation: dash 1s linear infinite;
            marker-end: url(#arrowhead);
            fill: none;
        }
        @keyframes dash { to { stroke-dashoffset: -15; } }

        #ability-stack-zone {
            width: 100px;
            background: #bdc3c7;
            border-right: 2px solid #7f8c8d;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            z-index: 10;
        }

        #ability-stack-zone.rotated-view {
            flex-direction: column-reverse;
        }

        .ability-column {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 5px 0;
            overflow-y: auto;
            position: relative;
            gap: 5px;
        }

        #ability-zone-p2 { background: rgba(252, 228, 236, 0.5); }
        #ability-zone-p1 { background: rgba(227, 242, 253, 0.5); }

        #ability-stack-zone:not(.rotated-view) #ability-zone-p2 { border-bottom: 2px dashed #7f8c8d; }
        #ability-stack-zone.rotated-view #ability-zone-p1 { border-bottom: 2px dashed #7f8c8d; }

        .ability-label {
            font-size: 0.7rem;
            font-weight: bold;
            color: #555;
            margin-bottom: 5px;
            opacity: 0.7;
        }

        #game-board-container {
            flex: 1;
            background: #95a5a6;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow: hidden; 
        }

        #main-board {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            background: white;
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
        }

        /* Turn Indicators */
        .turn-bar {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 12px;
            background: #95a5a6;
            z-index: 50;
            transition: all 0.5s ease;
            border-right: 1px solid rgba(0,0,0,0.1);
        }
        
        #player1-area.active-turn .turn-bar {
            background: #3498db;
            box-shadow: 0 0 15px 2px rgba(52, 152, 219, 0.8);
            animation: pulse-blue 2s infinite;
        }
        
        #player2-area.active-turn .turn-bar {
            background: #e91e63;
            box-shadow: 0 0 15px 2px rgba(233, 30, 99, 0.8);
            animation: pulse-red 2s infinite;
        }
        
        @keyframes pulse-blue {
            0% { box-shadow: 0 0 10px 2px rgba(52, 152, 219, 0.5); }
            50% { box-shadow: 0 0 20px 5px rgba(52, 152, 219, 0.9); }
            100% { box-shadow: 0 0 10px 2px rgba(52, 152, 219, 0.5); }
        }

        @keyframes pulse-red {
            0% { box-shadow: 0 0 10px 2px rgba(233, 30, 99, 0.5); }
            50% { box-shadow: 0 0 20px 5px rgba(233, 30, 99, 0.9); }
            100% { box-shadow: 0 0 10px 2px rgba(233, 30, 99, 0.5); }
        }

        #reveal-zone {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            min-width: 200px;
            min-height: 120px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px dashed #f1c40f;
            border-radius: 10px;
            z-index: 300; 
            display: none;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
            padding: 30px 20px 20px 20px; 
            transition: opacity 0.3s;
            box-shadow: 0 0 20px rgba(241, 196, 15, 0.3);
        }
        
        #reveal-zone .zone-label {
            top: 5px;
            left: 10px;
            width: auto;
            transform: none;
            color: #f1c40f;
            text-shadow: none;
            font-size: 1rem;
            pointer-events: none;
        }

        #timeline-panel {
            width: var(--timeline-width);
            background: #ecf0f1;
            border-left: 1px solid #bdc3c7;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            z-index: 20;
        }

        #timeline-header {
            padding: 8px;
            background: #34495e;
            color: white;
            font-weight: bold;
            text-align: center;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
        }

        #action-list {
            flex: 1;
            overflow-y: auto;
            list-style: none;
            padding: 0;
            margin: 0;
            padding-bottom: 20px;
        }

        .timeline-gap {
            height: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            position: relative;
        }
        .timeline-gap:hover::after {
            content: "+";
            background: #3498db;
            color: white;
            width: 20px; height: 20px;
            border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            font-weight: bold;
            font-size: 14px;
            position: absolute;
            z-index: 5;
        }
        .timeline-gap::before {
            content: "";
            height: 2px;
            background: #ccc;
            width: 80%;
            position: absolute;
        }

        .action-item {
            padding: 8px 10px;
            border-bottom: 1px solid #dcdcdc;
            cursor: pointer;
            font-size: 0.85rem;
            display: flex;
            flex-direction: column;
            gap: 5px;
            background: #fdfdfd;
            border-left: 4px solid transparent;
        }
        .action-item:hover { background: #f0f4f7; }
        .action-item.active { background: #e8f6fd; border-left-color: #2980b9;}
        .action-item.editing { background: #fff3e0; border-left-color: #e67e22; }

        .action-item.p1-action { border-left: 4px solid #3498db; background: rgba(52, 152, 219, 0.05); }
        .action-item.p1-action.active { background: rgba(52, 152, 219, 0.2); }
        
        .action-item.p2-action { border-left: 4px solid #e91e63; background: rgba(233, 30, 99, 0.05); }
        .action-item.p2-action.active { background: rgba(233, 30, 99, 0.2); }

        .action-header { display: flex; align-items: center; width: 100%; justify-content: space-between; }
        .action-index { font-weight: bold; margin-right: 6px; min-width: 18px; text-align: right; color: #7f8c8d;}
        .action-desc { flex: 1; white-space: pre-wrap; word-break: break-all; font-weight: 500;}
        
        .action-controls {
            display: flex; gap: 5px; margin-top: 5px; padding-left: 24px; opacity: 0.4; transition: opacity 0.2s;
        }
        .action-item:hover .action-controls, .action-item.active .action-controls { opacity: 1; }
        
        .mini-btn { font-size: 0.75rem; padding: 3px 8px; background: #bdc3c7; border: none; color: #2c3e50; border-radius: 3px; cursor: pointer;}
        .mini-btn:hover { background: #95a5a6; color: white; }
        .mini-btn.play-from { background: #2ecc71; color: white; }
        .mini-btn.play-from:hover { background: #27ae60; }
        .mini-btn.play-step { background: #3498db; color: white; }
        .mini-btn.play-step:hover { background: #2980b9; }
        .mini-btn.edit { background: #f39c12; color: white; }
        .mini-btn.edit:hover { background: #e67e22; }
        .mini-btn.delete-all { background: #c0392b; color: white; font-weight:bold; padding: 2px 6px; border-radius:3px; cursor:pointer; border:none;}

        .icon-btn { background: none; border: none; cursor: pointer; padding: 2px; opacity: 0.5; font-size: 1rem; }
        .icon-btn:hover { opacity: 1; transform: scale(1.1); }
        .icon-btn.delete { color: #c0392b; }

        .player-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 2px;
            position: relative;
            padding-left: 15px; /* Space for turn bar */
        }

        #player2-area {
            background-color: var(--p2-color);
            border-bottom: 2px dashed #999;
        }
        
        #player2-area .bottom-row { order: -1; }
        #player2-area .mana-zone { order: 0; }
        #player2-area .shield-zone { order: 1; }
        #player2-area .battle-zone { order: 2; }
        
        #player1-area { background-color: var(--p1-color); }

        .zone {
            border: 1px solid rgba(0,0,0,0.15);
            margin: 1px;
            display: flex;
            align-items: center;
            position: relative;
            min-height: var(--card-height);
            border-radius: 3px;
        }
        
        .zone.target-highlight {
            background-color: rgba(46, 204, 113, 0.4);
            border: 2px dashed #27ae60;
            box-shadow: inset 0 0 10px rgba(46, 204, 113, 0.5);
            cursor: copy;
            z-index: 100;
        }
        
        /* Zone Glows (New Feature) */
        .zone.glow-red { box-shadow: inset 0 0 20px rgba(255, 0, 0, 0.5); border: 2px solid red; }
        .zone.glow-yellow { box-shadow: inset 0 0 20px rgba(255, 215, 0, 0.5); border: 2px solid gold; }
        .zone.glow-green { box-shadow: inset 0 0 20px rgba(0, 255, 0, 0.5); border: 2px solid lime; }
        .zone.glow-blue { box-shadow: inset 0 0 20px rgba(0, 191, 255, 0.5); border: 2px solid deepskyblue; }
        .zone.glow-black { box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5); border: 2px solid black; }
        .zone.glow-white { box-shadow: inset 0 0 20px rgba(255, 255, 255, 0.8); border: 2px solid white; }
        .zone.glow-rainbow { animation: zone-rainbow 2s linear infinite; }
        @keyframes zone-rainbow {
            0% { border-color: red; box-shadow: inset 0 0 20px rgba(255,0,0,0.5); }
            50% { border-color: blue; box-shadow: inset 0 0 20px rgba(0,255,0,0.5); }
            100% { border-color: red; box-shadow: inset 0 0 20px rgba(255,0,0,0.5); }
        }

        .zone.point-target-highlight {
            background-color: rgba(142, 68, 173, 0.2);
            border: 2px dashed #9b59b6;
            cursor: crosshair;
            z-index: 100;
        }
        .card.point-target-highlight {
            box-shadow: 0 0 10px 5px rgba(155, 89, 182, 0.8);
            z-index: 101;
            cursor: crosshair;
        }
        .card.point-target-selected {
            box-shadow: 0 0 15px 8px #8e44ad;
            border: 2px solid #8e44ad;
        }

        .zone-label {
            position: absolute; font-size: 0.8rem; color: rgba(0,0,0,0.25);
            font-weight: 900; pointer-events: none; z-index: 0; width: 100%; text-align: center;
            top: 50%; transform: translateY(-50%); text-transform: uppercase;
        }

        .bottom-row { display: flex; height: var(--card-height); margin-top: auto; }
        .hand-zone { flex: 1; overflow-x: auto; padding: 2px; scrollbar-width: thin;}
        .side-zone-group { width: 170px; display: flex; gap: 3px; padding-left: 3px; flex-shrink: 0; }
        
        .stacked { flex: 1; justify-content: center; cursor: zoom-in; background: rgba(0,0,0,0.1); border: 1px solid rgba(0,0,0,0.3); }
        .mana-zone { height: calc(var(--card-height) * 0.6); background: rgba(0,0,0,0.05); }
        .shield-zone { height: calc(var(--card-height) * 0.85); justify-content: center; gap: 5px; }
        .battle-zone { flex: 1; background: rgba(255,255,255,0.6); justify-content: center; gap: 4px; padding: 5px; }

        .card-group {
            position: relative;
            /* Changed from fixed width to auto/min-width to support God Link/Puzzle stacking */
            width: auto; 
            min-width: var(--card-width);
            height: var(--card-height);
            margin: 0 5px; /* Increased margin for better separation */
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.3s;
        }

        .card-group:hover {
            z-index: 500;
        }
        .card-group:hover .card {
            transition: top 0.3s, z-index 0s;
        }
        /* Hover Fan-out - modified to respect Puzzle links */
        .card-group:hover .stack-base { top: 0px !important; z-index: 100; }
        /* Only fan out vertical stacks if not puzzling */
        .card-group:hover .stack-top:not(.puzzle-link) { top: -40px !important; z-index: 101; }
        .card-group:hover .stack-shift-up { top: -50px !important; z-index: 101; }
        .card-group:hover .stack-shift-down { top: -30px !important; z-index: 101; }
        .card-group:hover .stack-bottom { top: 40px !important; z-index: 102; box-shadow: 0 0 10px rgba(0,0,0,0.5); }

        .card {
            width: var(--card-width); height: var(--card-height);
            background-color: white; border: 1px solid #333; border-radius: 3px;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            position: relative; font-size: 9px; cursor: pointer;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.4); user-select: none;
            transition: box-shadow 0.2s, border-color 0.2s; 
            z-index: 1; flex-shrink: 0; overflow: hidden;
            will-change: transform, top, left;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }
        
        .card.has-image { border: none; }
        .card.has-image[class*="glow-"] { border: 1px solid transparent; }
        .card.has-image .card-text { display: none; }

        .card.interactive { transition: transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1); }
        .card:hover { z-index: 200; box-shadow: 0 4px 10px rgba(0,0,0,0.3); }
        .card.selected { box-shadow: 0 0 0 3px #f1c40f, 0 0 8px #f1c40f; z-index: 100; }
        .card.face-down { 
            background: #2c3e50;
            background-image: radial-gradient(circle, #34495e 10%, transparent 10%);
            background-size: 15px 15px; border: 1px solid white; color: transparent; 
        }
        
        .card-note {
            position: absolute; top: 1px; left: 2px; right: 2px;
            background: #f1c40f; color: black; font-size: 8px; text-align: center;
            border: 1px solid #d35400; z-index: 5;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
            pointer-events: none; border-radius: 2px; box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }

        /* Stacking classes */
        .stack-base { z-index: 10; position: absolute; }
        .stack-top { z-index: 20; position: absolute; }
        .stack-bottom { z-index: 5; position: absolute; }
        .stack-shift-up { z-index: 20; position: absolute; }
        .stack-shift-down { z-index: 20; position: absolute; }
        .stack-bottom-exposed { z-index: 5; position: absolute; }
        .stack-top-offset { z-index: 20; position: absolute; }
        
        /* New Puzzle/Link Stacking Classes */
        .puzzle-link { /* Generic marker */ }
        .stack-puzzle-top { z-index: 20; position: absolute; }
        .stack-puzzle-bottom { z-index: 20; position: absolute; }
        .stack-puzzle-left { z-index: 20; position: absolute; }
        .stack-puzzle-right { z-index: 20; position: absolute; }

        .glow-red { box-shadow: 0 0 8px 4px rgba(255, 0, 0, 0.8) !important; border-color: red !important; }
        .glow-yellow { box-shadow: 0 0 8px 4px rgba(255, 215, 0, 0.8) !important; border-color: gold !important; }
        .glow-green { box-shadow: 0 0 8px 4px rgba(0, 255, 0, 0.8) !important; border-color: lime !important; }
        .glow-blue { box-shadow: 0 0 8px 4px rgba(0, 191, 255, 0.8) !important; border-color: deepskyblue !important; }
        .glow-black { box-shadow: 0 0 8px 4px rgba(0, 0, 0, 0.8) !important; border-color: black !important; }
        .glow-white { box-shadow: 0 0 8px 4px rgba(255, 255, 255, 0.9) !important; border-color: white !important; }
        .glow-rainbow { animation: rainbow 2s linear infinite !important; }
        
        @keyframes rainbow {
            0% { box-shadow: 0 0 8px 4px rgba(255, 0, 0, 0.8); border-color: red; }
            50% { box-shadow: 0 0 8px 4px rgba(0, 255, 0, 0.8); border-color: blue; }
            100% { box-shadow: 0 0 8px 4px rgba(255, 0, 0, 0.8); border-color: red; }
        }

        .ability-card { width: 80px; height: 35px; flex-direction: row; font-size: 8px; transform: none !important; cursor: pointer; overflow: hidden; }
        .ability-card .card-text { font-size: 8px; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; max-width: 90%; }
        .ability-card .card-power { display: none; }

        .card-power { 
            position: absolute; bottom: 0; left: 0; width: 100%;
            background: rgba(255,255,255,0.9); border-top: 1px solid #000; 
            text-align: center; font-weight: bold; font-size: 9px; color: black;
        }
        .card-text { padding: 2px; text-align: center; line-height: 1.1; font-weight: 500;}

        .count-badge {
            position: absolute; top: -6px; right: -6px;
            background: #e74c3c; color: white;
            border-radius: 50%; width: 20px; height: 20px;
            display: flex; justify-content: center; align-items: center;
            font-size: 10px; font-weight: bold; z-index: 50;
            border: 1px solid white; box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .modal {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); z-index: 2000;
            justify-content: center; align-items: center; backdrop-filter: blur(2px);
        }
        .modal-content {
            background: white; border-radius: 8px; box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            padding: 20px; display: flex; flex-direction: column;
            animation: slideUp 0.3s ease;
        }
        
        #setup-modal { display: none; }
        #setup-modal .modal-content { width: 320px; gap: 15px; }
        .input-group { display: flex; justify-content: space-between; align-items: center; }
        .input-group label { font-weight: bold; font-size: 0.9rem; }
        .input-group input { width: 60px; text-align: center; }

        #card-selector-modal .modal-content { width: 85%; max-width: 900px; height: 85%; }
        #modal-body { flex: 1; overflow-y: auto; display: flex; flex-wrap: wrap; gap: 12px; padding: 15px; background: #f8f9fa; border-radius: 4px; align-content: flex-start; }
        /* Style for cards in selector list that have images */
        #modal-body .card.has-image-icon { background-size: cover; background-position: center; color: transparent; text-shadow: none; }

        #position-selector-modal .modal-content { width: 90%; max-width: 600px; height: auto; max-height: 80vh; display: flex; flex-direction: column; }
		
		/* å®¹å™¨ï¼šç¸®å°é–“è·è®“ç¸«éš™æ„Ÿæ›´æ˜é¡¯ */
        #position-list {
            flex: 1; 
            overflow-y: auto; 
            display: flex; 
            flex-wrap: wrap; 
            gap: 2px;            /* [ä¿®æ”¹] é–“è·ç¸®å°ï¼Œè®“æ’æ§½ç·Šè²¼å¡ç‰‡ */
            padding: 10px; 
            background: #eee; 
            border-radius: 4px; 
            min-height: 0;
            align-content: flex-start;
        }

		/* æ’æ§½ï¼šå¼·åˆ¶è¨­å®šç‚ºæ¥µçª„çš„ç¸«éš™ (ç´„ 14px) */
        .position-slot {
            /* å¼·åˆ¶å›ºå®šå¯¬åº¦ï¼Œä¸è®“ Flex æˆ–å…§å®¹æ’é–‹ */
            width: 14px !important;
            min-width: 14px !important; 
            max-width: 14px !important;
            height: var(--card-height);
            
            /* éš±è—æº¢å‡ºçš„æ–‡å­— (Top/Bottom/+) */
            overflow: hidden; 
            
            background: rgba(0, 0, 0, 0.1); 
            border: 1px dashed #999;
            border-radius: 2px;
            
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s;
            
            /* è®“é€™å€‹å…ƒç´ ä¸æœƒè¢«å£“ç¸®æˆ–æ”¾å¤§ */
            flex-shrink: 0;
            flex-grow: 0;
            
            /* éš±è—æ–‡å­—é¡è‰² */
            color: transparent; 
        }
        
        /* æ»‘é¼ ç§»ä¸Šå»æ™‚ï¼šè®Šå¯¬ã€è®Šè‰²ï¼Œæ–¹ä¾¿æ“ä½œ */
        .position-slot:hover { 
            /* Hover æ™‚å±•é–‹åˆ°ä¸€åŠå¡ç‰‡å¯¬ï¼Œæ–¹ä¾¿ç¢ºèª */
            width: 25px !important; 
            min-width: 25px !important;
            max-width: 25px !important;
            
            background: #3498db; 
            border-color: #2980b9; 
            z-index: 100;
            box-shadow: 0 0 5px rgba(52, 152, 219, 0.8);
            
            /* Hover æ™‚é¡¯ç¤ºä¸€é»æ–‡å­—æç¤º (å¦‚æœé¡è‰²ä¸æ˜¯é€æ˜çš„è©±) */
            /* color: white; */ 
        }

        /* ç‚ºäº†å€åˆ†é ­å°¾ï¼Œæˆ‘å€‘å¯ä»¥åˆ©ç”¨ JS è³¦äºˆçš„ title å±¬æ€§ä¾†åšæ¨£å¼ (é¸ç”¨)
           æˆ–æ˜¯ä¿æŒçµ±ä¸€çš„ç¸«éš™æ¨£å¼ï¼Œè®“ä½¿ç”¨è€…ä¾è³´ç›´è¦º (æœ€å·¦=åº•ï¼Œæœ€å³=é ‚) */
        
        /* 2. åƒè€ƒå¡æ¨£å¼ï¼šå°ºå¯¸åŒå¡ç‰‡ï¼Œä½œç‚ºè¦–è¦ºåƒè€ƒ */
        .position-card-ref {
            width: var(--card-width); 
            height: var(--card-height);
            border: 1px solid #7f8c8d;
            border-radius: 3px;
            background-color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.6rem;
            color: #333;
            pointer-events: none; /* ç¦æ­¢é»æ“Šå¡ç‰‡æœ¬èº«ï¼Œå¼·è¿«é»æ“Šæ’æ§½ */
            flex-shrink: 0;
            background-size: cover;
            background-position: center;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.2);
            overflow: hidden;
            opacity: 0.85;
        }

        /* [é¸ç”¨] åœ¨å¡ç‰‡å³å´åŠ ä¸€å€‹å¾®å°çš„ç®­é ­æŒ‡ç¤ºé †åº */
        .position-card-ref::after {
            content: "âœ";
            position: absolute;
            right: -8px; 
            top: 50%;
            transform: translateY(-50%);
            font-size: 8px;
            color: #999;
            z-index: 5;
            display: none; /* å¦‚æœè¦ºå¾—ç•«é¢å¤ªäº‚å¯ä»¥ä¿æŒéš±è— */
        }
        
        #stack-gui {
            display: grid;
            grid-template-columns: repeat(3, 1fr); /* Changed to 3 columns to fit more options */
            gap: 10px;
            margin-top: 10px;
            overflow-y: auto;
        }
        .stack-option {
            background: #f8f9fa; border: 2px solid #ddd;
            border-radius: 8px; padding: 10px;
            text-align: center; cursor: pointer;
            transition: all 0.2s;
            display: flex; flex-direction: column; align-items: center; gap: 5px;
            font-size: 0.8rem;
        }
        .stack-option:hover { border-color: #3498db; background: #ebf5fb; transform: translateY(-2px); box-shadow: 0 3px 8px rgba(0,0,0,0.1); }
        .stack-icon {
            width: 30px; height: 40px; background: #ccc; border: 1px solid #999;
            position: relative; display: block; margin-bottom: 5px;
        }
        /* Existing Icons */
        .icon-top .child { position: absolute; top:0; left:0; width:100%; height:100%; background:#3498db; border:1px solid white; z-index:2; opacity:0.8; }
        .icon-bottom .child { position: absolute; top:0; left:0; width:100%; height:100%; background:#2c3e50; border:1px solid white; z-index:-1; }
        .icon-up .child { position: absolute; top:-15px; left:0; width:100%; height:100%; background:#e67e22; border:1px solid white; z-index:2; opacity:0.9; }
        .icon-down .child { position: absolute; top:15px; left:0; width:100%; height:100%; background:#9b59b6; border:1px solid white; z-index:2; opacity:0.9; }
        .icon-bottom-exp .child { position: absolute; top:20px; left:0; width:100%; height:100%; background:#27ae60; border:1px solid white; z-index:-1; opacity: 0.9; }
        
        /* New Puzzle Icons */
        .icon-p-top .child { position: absolute; top:-38px; left:0; width:100%; height:100%; background:#e74c3c; border:1px solid white; z-index:2; }
        .icon-p-bottom .child { position: absolute; top:38px; left:0; width:100%; height:100%; background:#e74c3c; border:1px solid white; z-index:2; }
        .icon-p-left .child { position: absolute; top:0; left:-28px; width:100%; height:100%; background:#e74c3c; border:1px solid white; z-index:2; }
        .icon-p-right .child { position: absolute; top:0; left:28px; width:100%; height:100%; background:#e74c3c; border:1px solid white; z-index:2; }

        .rotated-view #main-board { transform: rotate(180deg); }

		/* --- ä¿®æ”¹éƒ¨åˆ†ï¼šå°‡ä½ç½®é¸æ“‡å™¨æ”¹ç‚ºç¶²æ ¼ä½ˆå±€ (ä»¿ç…§ UI A) --- */
        #position-list {
            flex: 1; 
            overflow-y: auto; 
            display: flex; 
            flex-wrap: wrap; /* å…è¨±æ›è¡Œ */
            gap: 8px;        /* é–“è· */
            padding: 15px; 
            background: #eee; 
            border-radius: 4px; 
            min-height: 0;
            align-content: flex-start;
            justify-content: flex-start; /* é å·¦å°é½Šï¼Œç¬¦åˆé–±è®€é †åº */
        }

        /* æ’æ§½æ¨£å¼ï¼šçœ‹èµ·ä¾†åƒä¸€å¼µè™›ç·šå¡ç‰‡ */
        .position-slot {
            width: var(--card-width); 
            height: var(--card-height);
            background: rgba(255, 255, 255, 0.5); 
            border: 2px dashed #999;
            border-radius: 4px;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-size: 0.7rem;
            color: #555;
            cursor: pointer;
            transition: all 0.2s;
            flex-shrink: 0;
            position: relative;
        }
        
        .position-slot:hover { 
            background: #dff9fb; 
            border-color: #2980b9; 
            color: #2980b9; 
            font-weight: bold;
            transform: scale(1.05);
            z-index: 10;
        }
        
        /* åƒè€ƒå¡æ¨£å¼ï¼šé¡¯ç¤ºåœ¨æ’æ§½ä¸­é–“ï¼Œåƒ…ä¾›åƒè€ƒï¼Œä¸å¯é»æ“Š */
        .position-card-ref {
            width: var(--card-width); 
            height: var(--card-height);
            border: 1px solid #ccc;
            border-radius: 3px;
            background-color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.6rem;
            color: #aaa;
            opacity: 0.7; /* ç¨å¾®æ·¡åŒ–ï¼Œå€åˆ†å¯é»æ“Šå€åŸŸ */
            pointer-events: none; /* ç¦æ­¢é»æ“Š */
            flex-shrink: 0;
            background-size: cover;
            background-position: center;
            box-shadow: 1px 1px 2px rgba(0,0,0,0.1);
            overflow: hidden;
            text-align: center;
            padding: 2px;
        }
        
        /* ç‚ºäº†è®“è¦–è¦ºå‹•ç·šæ›´æ¸…æ¥šï¼Œæˆ‘å€‘å¯ä»¥åŠ ä¸€å€‹å°ç®­é ­æˆ–ç·šæ¢ (é¸æ“‡æ€§) */
        .position-card-ref::after {
            content: "â–¶";
            position: absolute;
            right: -12px;
            top: 50%;
            transform: translateY(-50%);
            color: #ccc;
            font-size: 8px;
            display: none; /* æš«æ™‚éš±è—ï¼Œé¿å…å¤ªäº‚ */
        }
		
		/* --- [æ–°å¢] çˆªç—•ç‰¹æ•ˆæ¨£å¼ --- */
		.claw-overlay {
			position: absolute;
			top: 0; left: 0; width: 100%; height: 100%;
			pointer-events: none; /* è®“æ»‘é¼ å¯ä»¥ç©¿é€é»æ“Šå¡ç‰‡ */
			z-index: 50;
			display: flex;
			justify-content: center;
			align-items: center;
			opacity: 0.9;
		}

		.claw-svg {
			width: 130%;  /* åŸæœ¬æ˜¯ 80%ï¼Œæ”¹æˆ 130% è®“å®ƒè¶…å‡ºå¡ç‰‡é‚Šç•Œ */
			height: 130%; /* åŸæœ¬æ˜¯ 80%ï¼Œæ”¹æˆ 130% */
			overflow: visible;
		}

		.claw-path {
			fill: none;
			stroke: #c0392b; /* è¡€ç´…è‰² */
			stroke-width: 8;
			stroke-linecap: round;
			filter: drop-shadow(1px 1px 2px rgba(0,0,0,0.5));
		}

		/* æ’­æ”¾æ™‚çš„å‹•ç•« Class */
		.claw-anim .claw-path {
			stroke-dasharray: 100;
			stroke-dashoffset: 100;
			animation: scratch-anim 0.3s cubic-bezier(0.25, 1, 0.5, 1) forwards;
		}

		/* è®“ä¸‰æ¢çˆªç—•æœ‰æ™‚é–“å·®ï¼Œçœ‹èµ·ä¾†æ›´åƒæŠ“æ“Š */
		.claw-anim .p1 { animation-delay: 0s; }
		.claw-anim .p2 { animation-delay: 0.1s; }
		.claw-anim .p3 { animation-delay: 0.05s; }

		@keyframes scratch-anim {
			to { stroke-dashoffset: 0; }
		}
		
		/* --- [æ–°å¢] å‹åˆ©æ…¶ç¥å‹•ç•« --- */
        #win-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; /* è®“æ»‘é¼ å¯ç©¿é€ */
            z-index: 2000;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.4);
            overflow: hidden;
        }

        .win-text {
            font-size: 5rem;
            font-weight: 900;
            text-transform: uppercase;
            color: #f1c40f;
            text-shadow: 0 0 20px rgba(0,0,0,0.8), 3px 3px 0 #c0392b;
            transform: scale(0);
            animation: win-pop 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }

        .win-sub {
            font-size: 2rem;
            color: white;
            margin-top: 10px;
            opacity: 0;
            animation: slideUp 0.5s ease 0.5s forwards;
            text-shadow: 0 0 5px black;
        }
        
        /* ç°¡å–®çš„å½©å¸¶ç‰¹æ•ˆ (ä½¿ç”¨å½å…ƒç´ æ¨¡æ“¬) */
        .confetti {
            position: absolute;
            width: 10px; height: 10px;
            background-color: #f00;
            animation: confetti-fall 3s linear infinite;
        }

        @keyframes win-pop {
            0% { transform: scale(0) rotate(-15deg); opacity: 0; }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }
        
        @keyframes confetti-fall {
            0% { transform: translateY(-100px) rotate(0deg); opacity: 1; }
            100% { transform: translateY(800px) rotate(720deg); opacity: 0; }
        }
		
		/* èªè¨€é¸å–®æ¨£å¼ */
		#lang-select {
			background: #34495e;
			color: white;
			border: 1px solid #566573;
			padding: 4px 8px;
			border-radius: 4px;
			margin-right: 10px;
			font-size: 0.85rem;
			cursor: pointer;
			outline: none;
		}
		#lang-select:hover {
			background: #4e6479;
		}
		
		/* --- Mobile Mode Styles (Final Fix) --- */
		body.mobile-mode {
			overflow: hidden;
			background-color: #2c3e50; /* æ—é‚Šç•™é»‘é‚Šæˆ–æ·±è‰²åº• */
			margin: 0;
			padding: 0;
			width: 100vw;
			height: 100vh;
			position: relative; /* ä½œç‚ºå®šä½åŸºæº– */
		}

		/* éš±è—ä¸éœ€è¦çš„ä»‹é¢ */
		body.mobile-mode #toolbar, 
		body.mobile-mode #draft-bar, 
		body.mobile-mode #point-bar, 
		body.mobile-mode #card-action-panel, 
		body.mobile-mode #timeline-panel,
		body.mobile-mode #setup-modal,
		body.mobile-mode .turn-bar {
			display: none !important;
		}

		/* é—œéµä¿®æ”¹ï¼šè™›æ“¬ç•«å¸ƒè¨­å®š */
		body.mobile-mode #workspace {
			/* 1. å¼·åˆ¶è¨­å®šä¸€å€‹ã€Œç†æƒ³çš„ã€æ¡Œé¢è§£æåº¦ */
			/* å¯¬åº¦åŒ…å«ï¼šèƒ½åŠ›å€(100px) + æˆ°å ´å€åŸŸ */
			width: 1200px !important; 
			height: 800px !important; /* é€™å€‹é«˜åº¦è¶³ä»¥å®¹ç´ P1 + P2 çš„æ‰€æœ‰å€åŸŸ */
			
			/* 2. çµ•å°å®šä½åœ¨è¢å¹•æ­£ä¸­é–“ */
			position: absolute;
			top: 50%;
			left: 50%;
			
			/* 3. é è¨­å…ˆç½®ä¸­ (ç¸®æ”¾é‚è¼¯æœƒå†è¦†è“‹ transform) */
			transform: translate(-50%, -50%);
			transform-origin: center center;
			
			/* 4. æ’ç‰ˆè¨­å®š */
			display: flex !important;
			flex-direction: row;
			background: #95a5a6;
			box-shadow: 0 0 50px rgba(0,0,0,0.5); /* è®“ç•«å¸ƒçœ‹èµ·ä¾†æ¯”è¼ƒç«‹é«” */
		}

		/* æ¢å¾©èƒ½åŠ›å€çš„æ­£å¸¸é¡¯ç¤º (å› ç‚ºæˆ‘å€‘ç¾åœ¨æ˜¯ç¸®æ”¾æ•´å€‹ç•«å¸ƒï¼Œä¸éœ€è¦è®“å®ƒè®Šçª„) */
		body.mobile-mode #ability-stack-zone {
			display: flex !important;
			width: 100px !important; /* ç¶­æŒé›»è…¦ç‰ˆå¯¬åº¦ */
			flex-shrink: 0;
			height: 100%;
			border-right: 2px solid #7f8c8d;
		}

		body.mobile-mode #game-board-container {
			flex: 1;
			height: 100%;
			display: flex;
			justify-content: center;
			align-items: center;
			overflow: hidden;
		}

		body.mobile-mode #main-board {
			width: 100%;
			height: 100%;
			box-shadow: none;
		}

		/* æ’­æ”¾æŒ‰éˆ•èˆ‡è½‰å‘æç¤º (ç¶­æŒä¸è®Š) */
		#mobile-controls {
			display: none;
			position: fixed; bottom: 20px; right: 20px; z-index: 9999;
		}
		body.mobile-mode #mobile-controls { display: flex; }
		.mobile-btn {
			width: 60px; height: 60px;
			border-radius: 50%; background: rgba(255,255,255,0.8);
			border: 4px solid #3498db; font-size: 24px;
			display: flex; justify-content: center; align-items: center; cursor: pointer;
		}

		#orientation-overlay {
			display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
			background: #2c3e50; color: white; z-index: 10000;
			flex-direction: column; justify-content: center; align-items: center; text-align: center;
		}
		#orientation-overlay .icon { font-size: 50px; margin-bottom: 20px; animation: rotate 2s infinite; }
		@keyframes rotate { 0% {transform: rotate(0deg);} 50% {transform: rotate(-90deg);} 100% {transform: rotate(0deg);} }

        @keyframes slideUp { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
		
		/* --- å‚ç›´é€²åº¦æ¢æ¨£å¼ (ä¿®æ­£ç‰ˆ) --- */
		#playback-slider-container {
			position: fixed;
			/* [ä¿®æ”¹é» 2] æ¡Œæ©Ÿç‰ˆä½ç½®èª¿æ•´ */
			/* Timeline å¯¬åº¦æ˜¯ 320pxï¼Œæˆ‘å€‘è¨­å®š 325px è®“å®ƒå‰›å¥½åœ¨åˆ—è¡¨å·¦å´é‚Šç·£ */
			right: 0px; 
			
			top: 50%;
			transform: translateY(-50%);
			
			/* [ä¿®æ”¹é» 1] é•·åº¦èª¿æ•´ï¼šå®¹å™¨é«˜åº¦è¨­ç‚º 95% è¦–çª—é«˜åº¦ */
			height: 95vh; 
			
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			z-index: 3001; /* ç¢ºä¿åœ¨é˜»æ“‹å±¤ä¹‹ä¸Š */
			gap: 10px;
			pointer-events: none; /* å®¹å™¨æœ¬èº«ä¸æ“‹æ»‘é¼ ï¼Œè®“å…§éƒ¨å…ƒä»¶æ“‹å°±å¥½ */
		}

		/* è®“å…§éƒ¨å…ƒä»¶å¯ä»¥è¢«é»æ“Š */
		#playback-slider-container > * {
			pointer-events: auto;
		}

		/* --- æ–°ç‰ˆé€²åº¦æ¢å€åŸŸæ¨£å¼ (Slider Zone) --- */
		#slider-zone {
			/* æ¡Œæ©Ÿç‰ˆä½ˆå±€è¨­å®š */
			width: 30px; /* å›ºå®šå¯¬åº¦ï¼Œå½¢æˆä¸€å€‹çª„æ¢ */
			background: #2c3e50; /* æ·±è‰²èƒŒæ™¯ï¼Œå€éš”å±•ç¤ºå€èˆ‡åˆ—è¡¨ */
			border-left: 1px solid #34495e;
			border-right: 1px solid #bdc3c7;
			
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			
			position: relative;
			z-index: 20; /* ç¢ºä¿åœ¨æ™®é€šå±¤ç´šä¹‹ä¸Š */
			flex-shrink: 0; /* ç¦æ­¢è¢«å£“ç¸® */
		}

		#slider-tooltip {
			position: absolute;
			/* è®“æç¤ºæ–‡å­—è½‰æ­£ï¼Œä¸¦é¡¯ç¤ºåœ¨æ»‘æ¡¿ä¸Šæ–¹æˆ–æ—é‚Š */
			top: 20px;
			background: rgba(241, 196, 15, 0.9);
			color: #000;
			padding: 2px 6px;
			border-radius: 4px;
			font-size: 0.7rem;
			font-weight: bold;
			pointer-events: none;
			z-index: 25;
			white-space: nowrap;
		}

		#playback-slider {
			-webkit-appearance: none;
			appearance: none;
			
			/* é•·åº¦è¨­å®šï¼š
			   å› ç‚ºæ—‹è½‰äº† 90åº¦ï¼Œé€™è£¡çš„ width æ§åˆ¶çš„æ˜¯è¢å¹•ä¸Šçš„ã€Œå‚ç›´é«˜åº¦ã€ã€‚
			*/
			width: 90vh; 
			
			height: 6px; /* è»Œé“å¯¬åº¦ */
			background: rgba(255, 255, 255, 0.2);
			border-radius: 3px;
			outline: none;
			
			/* [é—œéµä¿®æ”¹] 
			   æ”¹æˆ 90deg (é †æ™‚é‡æ—‹è½‰)ã€‚
			   åŸæœ¬çš„ range æ˜¯ã€Œå·¦å°å³å¤§ã€ã€‚
			   è½‰ 90 åº¦å¾Œè®Šæˆäº†ã€Œä¸Šå°ä¸‹å¤§ã€ï¼Œç¬¦åˆä½ è¦çš„ Top=0%, Bottom=100%ã€‚
			*/
			transform: rotate(90deg); 
			
			cursor: pointer;
		}

		#playback-slider::-webkit-slider-thumb {
			-webkit-appearance: none;
			appearance: none;
			width: 16px;
			height: 16px;
			border-radius: 50%;
			background: #f1c40f;
			cursor: pointer;
			border: 2px solid #fff;
			box-shadow: 0 1px 3px rgba(0,0,0,0.5);
			transition: transform 0.1s;
		}

		#playback-slider::-webkit-slider-thumb:hover {
			transform: scale(1.4);
		}

		/* --- æ‰‹æ©Ÿç‰ˆè¦†å¯« --- */
		body.mobile-mode #playback-slider {
			/* æ‰‹æ©Ÿç‰ˆåŒæ¨£æ”¹ç‚º 90degï¼Œä¸”é•·åº¦è¨­ç‚ºè²«ç©¿è™›æ“¬ç•«å¸ƒ */
			width: 750px; 
			height: 12px;
			/* ç¢ºä¿æ‰‹æ©Ÿç‰ˆä¹Ÿå¥—ç”¨æ­£ç¢ºçš„æ—‹è½‰ */
			transform: rotate(90deg); 
		}

		body.mobile-mode #playback-slider::-webkit-slider-thumb {
			width: 25px;
			height: 25px;
		}
		
		/* --- æ‰‹æ©Ÿç‰ˆæ“ä½œé˜»æ“‹å±¤ --- */
		#mobile-blocker {
			display: none;
		}

		body.mobile-mode #mobile-blocker {
			display: block;
			position: fixed;
			top: 0; 
			left: 0;
			width: 100vw;
			height: 100vh;
			background: transparent; /* é€æ˜ï¼Œçœ‹ä¸åˆ°ä½†æ“‹å¾—åˆ° */
			/* å±¤ç´šè¨­å®šé—œéµï¼š
			   Workspace/Cards z-index ç´„ 100~2000
			   Blocker z-index = 2500 (è“‹ä½å¡ç‰‡)
			   Slider/Controls z-index = 3000 (è“‹ä½ Blocker)
			*/
			z-index: 2500; 
			touch-action: none; /* ç¦æ­¢ä¸‹å±¤çš„è§¸æ§è¡Œç‚º */
		}

		/* ç¢ºä¿é€²åº¦æ¢èˆ‡æ‰‹æ©ŸæŒ‰éˆ•æ°¸é åœ¨é˜»æ“‹å±¤ä¹‹ä¸Š */
		#playback-slider-container, #mobile-controls {
			z-index: 3001 !important;
		}
    </style>
</head>
<body>

<div id="toolbar">
    <div style="font-weight: 800; font-size: 1.1rem; margin-right: 10px; color: #f1c40f;">DM Editor</div>
    
    <select id="lang-select" onchange="changeLanguage(this.value)">
        <option value="zh">ä¸­æ–‡</option>
        <option value="en">English</option>
        <option value="jp">æ—¥æœ¬èª</option>
    </select>

    <button onclick="openSetupModal()" data-i18n="btn_setup">Setup / Clear</button>
    <button onclick="rotateBoard()" data-i18n="btn_rotate">ğŸ”„ æ›äºº (Switch Turn)</button>
    <div style="width: 1px; height: 20px; background: #555; margin: 0 5px;"></div>
    <button onclick="resetBoard(1)" title="é‡ç½® P1 ç›¤é¢" data-i18n="btn_p1_reset">P1 é‡ç½®</button>
    <button onclick="resetBoard(2)" title="é‡ç½® P2 ç›¤é¢" data-i18n="btn_p2_reset">P2 é‡ç½®</button>
    <button onclick="triggerWin(1)" style="background:#f39c12; border-color:#d35400;" data-i18n="btn_p1_win">ğŸ† 1P Win</button>
    <button onclick="triggerWin(2)" style="background:#f39c12; border-color:#d35400;" data-i18n="btn_p2_win">ğŸ† 2P Win</button>
    <div style="flex:1"></div>
    <button onclick="document.getElementById('import-input').click()" data-i18n="btn_import">åŒ¯å…¥ (Import)</button>
    <input type="file" id="import-input" style="display:none" onchange="importData(this)">
    <button onclick="exportData()" data-i18n="btn_export">åŒ¯å‡º (Export)</button>
</div>

<div id="draft-bar">
    <span>âš ï¸ ç·¨è¼¯ä¸­... (å·²ç´¯ç© <span id="draft-count">0</span> å€‹æ“ä½œ)</span>
    <label title="é–‹å•Ÿæ­¤é¸é …å¾Œï¼Œæœ¬æ¬¡ç·¨è¼¯çš„çµæœå°‡æœƒå½±éŸ¿å¾ŒçºŒæ‰€æœ‰æ­¥é©Ÿçš„ç‹€æ…‹ (å¯èƒ½å°è‡´ä¸å¯é æœŸçš„çµæœ)">
        <input type="checkbox" id="propagate-check"> ğŸ”— é€£å‹•æ›´æ–°å¾ŒçºŒ
    </label>
    <div style="display:flex; gap:10px;">
        <button onclick="cancelDraft()" class="danger">å–æ¶ˆ</button>
        <button onclick="saveDraft()" class="primary">ğŸ’¾ å„²å­˜æ­¤æ­¥</button>
    </div>
</div>

<div id="point-bar">
    <span>ğŸ‘‰ æŒ‡å‘æ¨¡å¼ï¼šè«‹é¸æ“‡ç›®æ¨™ (å¯é¸æ“‡ä»»æ„å¡ç‰‡æˆ–å€åŸŸ)</span>
    <div style="display:flex; gap:10px;">
        <span id="point-target-info" style="font-size:0.8rem; align-self:center;"></span>
        <button id="btn-confirm-point" class="primary" style="display:none;" onclick="confirmPointTargets()">âœ… ç¢ºèªæŒ‡å‘</button>
        <button onclick="cancelPointMode()" class="danger">å–æ¶ˆ</button>
    </div>
</div>

<div id="workspace">

	<svg id="svg-layer">
        <defs>
            <marker id="arrowhead" markerWidth="12" markerHeight="12" refX="10" refY="6" orient="auto" markerUnits="userSpaceOnUse">
                <path d="M0,0 L12,6 L0,12" fill="#e74c3c" />
            </marker>
        </defs>
    </svg>
	
    <div id="ability-stack-zone">
        <div id="ability-zone-p2" class="ability-column">
            <div class="ability-label" data-i18n="zone_ability">P2 èƒ½åŠ› (å¾…è™•ç†)</div>
        </div>
        <div id="ability-zone-p1" class="ability-column">
            <div class="ability-label" data-i18n="zone_ability">P1 èƒ½åŠ› (å¾…è™•ç†)</div>
        </div>
    </div>

    <div id="game-board-container">
        <div id="main-board">
            
            <div id="reveal-zone" class="zone" data-zone="reveal-zone">
                <span class="zone-label">å±•ç¤ºå€ (Reveal Zone)</span>
                <button class="mini-btn danger" style="position:absolute; top:5px; right:5px;" onclick="closeRevealZone()">âœ•</button>
            </div>

            <div id="player2-area" class="player-area">
                <div class="turn-bar"></div>
                <div class="battle-zone zone" data-zone="p2-battle" onclick="handleZoneClick('p2-battle')"><span class="zone-label" data-i18n="zone_battle">P2 æˆ°é¬¥å ´</span></div>
                <div class="shield-zone zone" data-zone="p2-shield" onclick="handleZoneClick('p2-shield')"><span class="zone-label" data-i18n="zone_shield">P2 è­·ç›¾å€</span></div>
                <div class="mana-zone zone" data-zone="p2-mana" onclick="handleZoneClick('p2-mana')"><span class="zone-label" data-i18n="zone_mana">P2 é­”åŠ›å€</span></div>
                <div class="bottom-row">
                    <div class="hand-zone zone" data-zone="p2-hand" onclick="handleZoneClick('p2-hand')"><span class="zone-label" data-i18n="zone_hand">P2 æ‰‹ç‰Œ</span></div>
                    <div class="side-zone-group">
                        <div class="hyper-zone zone stacked" data-zone="p2-hyper" onclick="handleZoneClick('p2-hyper')"><span class="zone-label" data-i18n="zone_hyper">è¶…æ¬¡å…ƒ</span></div>
                        <div class="grave-zone zone stacked" data-zone="p2-grave" onclick="handleZoneClick('p2-grave')"><span class="zone-label" data-i18n="zone_grave">å¢“åœ°</span></div>
                        <div class="deck-zone zone stacked" data-zone="p2-deck" onclick="handleZoneClick('p2-deck')"><span class="zone-label" data-i18n="zone_deck">ç‰Œåº«</span></div>
                    </div>
                </div>
            </div>

            <div id="player1-area" class="player-area">
                <div class="turn-bar"></div>
                <div class="battle-zone zone" data-zone="p1-battle" onclick="handleZoneClick('p1-battle')"><span class="zone-label" data-i18n="zone_battle">P1 æˆ°é¬¥å ´</span></div>
                <div class="shield-zone zone" data-zone="p1-shield" onclick="handleZoneClick('p1-shield')"><span class="zone-label" data-i18n="zone_shield">P1 è­·ç›¾å€</span></div>
                <div class="mana-zone zone" data-zone="p1-mana" onclick="handleZoneClick('p1-mana')"><span class="zone-label" data-i18n="zone_mana">P1 é­”åŠ›å€</span></div>
                <div class="bottom-row">
                    <div class="hand-zone zone" data-zone="p1-hand" onclick="handleZoneClick('p1-hand')"><span class="zone-label" data-i18n="zone_hand">P1 æ‰‹ç‰Œ</span></div>
                    <div class="side-zone-group">
                        <div class="deck-zone zone stacked" data-zone="p1-deck" onclick="handleZoneClick('p1-deck')"><span class="zone-label" data-i18n="zone_deck">ç‰Œåº«</span></div>
                        <div class="grave-zone zone stacked" data-zone="p1-grave" onclick="handleZoneClick('p1-grave')"><span class="zone-label" data-i18n="zone_grave">å¢“åœ°</span></div>
                        <div class="hyper-zone zone stacked" data-zone="p1-hyper" onclick="handleZoneClick('p1-hyper')"><span class="zone-label" data-i18n="zone_hyper">è¶…æ¬¡å…ƒ</span></div>
                    </div>
                </div>
            </div>

        </div>
    </div>

	<div id="slider-zone">
        <div id="slider-tooltip">0/0</div>
        <input type="range" id="playback-slider" min="0" max="0" value="0" step="1" oninput="handleSliderChange(this.value)">
    </div>
	
    <div id="timeline-panel">
        <div id="timeline-header">
            <span style="flex:1;">Action Log</span>
            <small style="font-weight:normal; opacity:0.8; margin-right:5px;" id="step-counter">0/0</small>
            <button class="mini-btn delete-all" onclick="deleteAllActions()" title="åˆªé™¤æ‰€æœ‰å‹•ä½œä¸¦é‡æ–°è¨­å®š">ğŸ—‘ï¸é‡è¨­</button>
        </div>
        <ul id="action-list"></ul>
        <div style="padding: 10px; background: #ecf0f1; border-top:1px solid #bdc3c7;">
            <div style="display: flex; gap:5px; justify-content: center; margin-bottom: 5px;">
                <button onclick="prevStep()">â—€</button>
                <button onclick="togglePlay()" id="btn-play">â–¶ æ’­æ”¾</button>
                <button onclick="nextStep()">â–¶</button>
            </div>
        </div>
    </div>
</div>

<div id="card-action-panel">
    <button id="btn-rotate-l" onclick="rotateCard(-90)">â†¶</button>
    <button id="btn-rotate-r" onclick="rotateCard(90)">â†·</button>
    <button id="btn-flip" onclick="flipCard()" data-i18n="act_flip">ç¿»é¢</button>
	<button id="btn-injured" style="display:none; background:#e74c3c; border-color:#c0392b;" onclick="toggleInjured()" data-i18n="act_injured">ğŸ’” å—å‚·</button>
    <button id="btn-glow" onclick="toggleGlow()" data-i18n="act_glow">ğŸ’¡ç™¼å…‰</button>
    <button id="btn-unglow" style="display:none;" onclick="removeGlow()">âœ•</button>
    <button id="btn-copy-ability" onclick="copyToAbility()" data-i18n="act_ability">âš¡èƒ½åŠ›</button>
    <button id="btn-reveal" onclick="revealCards()" data-i18n="act_reveal">ğŸ‘ï¸ å±•ç¤º</button>
    <button id="btn-point" style="display:none; background:#8e44ad; border-color:#9b59b6;" onclick="enterPointMode()" data-i18n="act_point">ğŸ‘‰ æŒ‡å‘</button>
    <button id="btn-end-point" style="display:none; background:#95a5a6; border-color:#7f8c8d;" onclick="endPoint()" data-i18n="act_end_point">ğŸ›‘ çµæŸæŒ‡å‘</button>
    <button onclick="pasteImageMode()" data-i18n="act_paste">ğŸ–¼ï¸ ä¸Šåœ– (Ctrl+V)</button>
    <button id="btn-remove-image" style="display:none; background:#e74c3c;" onclick="removeImage()">âœ• åœ–</button>
    <div style="border-left:1px solid #7f8c8d; height:20px; margin:0 5px;"></div>
    <input type="text" id="rename-input" placeholder="åç¨±..." onkeydown="if(event.key==='Enter') renameCard()" style="width: 80px;">
    <button onclick="renameCard()" data-i18n="act_rename">æ›´å</button>
    <input type="text" id="note-input" placeholder="è¨»è¨˜..." onkeydown="if(event.key==='Enter') addCardNote()" style="width: 80px;">
    <button onclick="addCardNote()" data-i18n="act_note">ğŸ“è¨»è¨˜</button>
    
    <div id="ability-adjust-controls" style="display:none; border-left:1px solid #7f8c8d; height:20px; margin:0 5px;"></div>
    <div id="ability-adjust-buttons" style="display:none; gap:5px; align-items:center;">
        <small>ä½ç§»:</small>
        <button onclick="adjustAbilityCard('panX', -10)">â¬…</button>
        <button onclick="adjustAbilityCard('panX', 10)">â¡</button>
        <button onclick="adjustAbilityCard('panY', -10)">â¬†</button>
        <button onclick="adjustAbilityCard('panY', 10)">â¬‡</button>
        <small>ç¸®æ”¾:</small>
        <button onclick="adjustAbilityCard('scale', 0.1)">+</button>
        <button onclick="adjustAbilityCard('scale', -0.1)">-</button>
    </div>

    <div style="border-left:1px solid #7f8c8d; height:20px; margin:0 5px;"></div>
    <button id="btn-delete-card" class="danger" style="display:none;" onclick="deleteSelectedCard()" data-i18n="act_delete">ğŸ—‘ï¸ åˆªé™¤</button>
    <button class="danger" onclick="cancelSelection()">âœ• (ESC)</button>
</div>

<div id="setup-modal" class="modal">
    <div class="modal-content">
        <h3 style="margin-top:0; text-align:center;">é–‹å±€è¨­å®š</h3>
        <div style="background:#fff3cd; padding:5px; margin-bottom:10px; font-size:0.85rem; border-radius:4px; text-align:center;">
            æ³¨æ„ï¼šé–‹å§‹æ–°å±€æœƒæ¸…é™¤ç•¶å‰æœªåŒ¯å‡ºçš„é€²åº¦ã€‚
        </div>
        <div class="input-group">
            <label>P1 ç‰Œåº«æ•¸:</label>
            <input type="number" id="setup-p1-deck" value="40" min="40" max="60">
        </div>
        <div class="input-group">
            <label>P1 è¶…æ¬¡å…ƒ:</label>
            <input type="number" id="setup-p1-hyper" value="8" min="0" max="8">
        </div>
        <hr style="width:100%; border:0; border-top:1px dashed #ccc;">
        <div class="input-group">
            <label>P2 ç‰Œåº«æ•¸:</label>
            <input type="number" id="setup-p2-deck" value="40" min="40" max="60">
        </div>
        <div class="input-group">
            <label>P2 è¶…æ¬¡å…ƒ:</label>
            <input type="number" id="setup-p2-hyper" value="8" min="0" max="8">
        </div>
        <div style="margin-top:20px; display:flex; justify-content:space-between;">
            <button onclick="clearStorage()" style="background:#7f8c8d;">æ¸…é™¤å­˜æª”</button>
            <button onclick="finishSetup()" class="primary">é–‹å§‹éŠæˆ² (Start)</button>
        </div>
    </div>
</div>

<div id="card-selector-modal" class="modal">
    <div class="modal-content">
        <div style="display:flex; justify-content:space-between; margin-bottom:10px;">
            <span id="modal-title" style="font-weight:bold; font-size:1.2rem;">Zone</span>
            <button onclick="closeSelectorModal()" style="border:none; background:none; font-size:1.5rem;">âœ•</button>
        </div>
        <div id="modal-body"></div>
        <div style="margin-top:15px; display:flex; gap:10px; justify-content:flex-end;">
            <button onclick="actionShuffleZone()" style="background:#8e44ad;">æ´—ç‰Œæ­¤å€</button>
            <button onclick="prepareMove(true)" style="background:#d35400;">æ´—ç‰Œé¸å–ç‰Œä¸¦ç§»å‹•...</button>
            <button onclick="revealFromSelector()" style="background:#3498db;">ğŸ‘ï¸ å±•ç¤º</button>
            <button onclick="prepareMove(false)" style="background:#2980b9;">ç§»å‹•é¸å–ç‰Œ...</button>
        </div>
    </div>
</div>

<div id="position-selector-modal" class="modal">
    <div class="modal-content">
        <div id="pos-modal-title" style="font-weight:bold; font-size:1.2rem; margin-bottom:10px;">å †ç–Šæ“ä½œ</div>
        <div style="margin-bottom:10px; font-size:0.9rem; color:#666;">è«‹é»æ“Šåœ–ç¤ºé¸æ“‡å †ç–Šæ–¹å¼ï¼š</div>
        
        <div id="stack-gui">
            <div class="stack-option" onclick="confirmStackMove('top')">
                <div class="stack-icon icon-top"><div class="child"></div></div>
                <span>ç–Šåœ¨ä¸Šæ–¹<br>(Cover Top)</span>
            </div>
            <div class="stack-option" onclick="confirmStackMove('bottom')">
                <div class="stack-icon icon-bottom"><div class="child"></div></div>
                <span>ç–Šåœ¨ä¸‹æ–¹<br>(Underneath)</span>
            </div>
            <div class="stack-option" onclick="confirmStackMove('puzzle_top')">
                <div class="stack-icon icon-p-top"><div class="child"></div></div>
                <span>æ‹¼åœ¨ä¸Šæ–¹<br>(Puzzle Top)</span>
            </div>
            <div class="stack-option" onclick="confirmStackMove('puzzle_bottom')">
                <div class="stack-icon icon-p-bottom"><div class="child"></div></div>
                <span>æ‹¼åœ¨ä¸‹æ–¹<br>(Puzzle Btm)</span>
            </div>
             <div class="stack-option" onclick="confirmStackMove('puzzle_left')">
                <div class="stack-icon icon-p-left"><div class="child"></div></div>
                <span>æ‹¼åœ¨å·¦é‚Š<br>(Puzzle Left)</span>
            </div>
             <div class="stack-option" onclick="confirmStackMove('puzzle_right')">
                <div class="stack-icon icon-p-right"><div class="child"></div></div>
                <span>æ‹¼åœ¨å³é‚Š<br>(Puzzle Right)</span>
            </div>
            
            <div class="stack-option" onclick="confirmStackMove('shift_up')">
                <div class="stack-icon icon-up"><div class="child"></div></div>
                <span>ä¸Šæ–¹ (éœ²å‡ºåº•)<br>(Shift Up)</span>
            </div>
            <div class="stack-option" onclick="confirmStackMove('shift_down')">
                <div class="stack-icon icon-down"><div class="child"></div></div>
                <span>ä¸Šæ–¹ (éœ²å‡ºé ‚)<br>(Shift Down)</span>
            </div>
            <div class="stack-option" onclick="confirmStackMove('bottom_exposed')">
                <div class="stack-icon icon-bottom-exp"><div class="child"></div></div>
                <span>ä¸‹æ–¹ (éœ²å‡ºåº•)<br>(Bottom Exposed)</span>
            </div>
        </div>
        <div id="position-list" style="display:none;"></div> 
        <div style="margin-top:15px; text-align:right;">
            <button onclick="closePositionModal()" class="danger">å–æ¶ˆ</button>
        </div>
    </div>
</div>

<div id="import-conflict-modal" class="modal">
    <div class="modal-content" style="width: 400px; text-align: center;">
        <h3>ç™¼ç¾å¤–éƒ¨åŠ‡æœ¬</h3>
        <p>ç¶²å€åƒæ•¸åŒ…å«åŠ‡æœ¬æª”ï¼Œä½†åµæ¸¬åˆ°æ‚¨æœ‰æœªå„²å­˜çš„æœ¬åœ°é€²åº¦ã€‚</p>
        <p>è«‹å•è¦å¦‚ä½•è™•ç†ï¼Ÿ</p>
        <div style="display: flex; flex-direction: column; gap: 10px; margin-top: 15px;">
            <button onclick="resolveImportConflict('cancel')" style="padding: 10px;">âŒ ä¸åŒ¯å…¥ (ä½¿ç”¨æœ¬åœ°å­˜æª”)</button>
            <button onclick="resolveImportConflict('save')" style="padding: 10px; background: #2ecc71;">ğŸ’¾ å­˜æª”ç„¶å¾ŒåŒ¯å…¥</button>
            <button onclick="resolveImportConflict('overwrite')" style="padding: 10px; background: #e74c3c;">âš ï¸ ä¸å­˜æª”ç›´æ¥åŒ¯å…¥</button>
        </div>
    </div>
</div>

<div id="mobile-controls">
    <button class="mobile-btn" id="mob-play-btn" onclick="togglePlay()">â–¶</button>
</div>

<div id="orientation-overlay">
    <div class="icon">ğŸ“±</div>
    <h2>è«‹æ—‹è½‰è¢å¹•</h2>
    <p>ç‚ºäº†æœ€ä½³è§€çœ‹é«”é©—ï¼Œè«‹å°‡æ‰‹æ©Ÿè½‰ç‚ºæ©«å‘ã€‚</p>
</div>

<script>
	// --- å¤šèªè¨€è¨­å®š (i18n) ---
    const TRANSLATIONS = {
        'zh': {
            // ... (åŸæœ¬çš„å…§å®¹ä¿ç•™) ...
            
            // [æ–°å¢] Timeline Actions
            'btn_play_from': 'â–¶ å¾æ­¤æ’­æ”¾',
            'btn_play_step': 'ğŸ‘ï¸ æ¼”ç¤ºæ­¤æ­¥',
            'btn_edit_step': 'âœï¸ ç·¨è¼¯',
            'btn_delete_step': 'ğŸ—‘ åˆªé™¤',
            
            // [æ–°å¢] Play Controls
            'btn_play': 'â–¶ æ’­æ”¾',
            'btn_pause': 'â¸ æš«åœ',
            
            // [æ–°å¢] Reveal Zone (HTMLå…§)
            'lbl_reveal_zone': 'å±•ç¤ºå€ (Reveal Zone)',
            
            // [æ–°å¢] JS Messages (Alerts & Confirms)
            'msg_confirm_setup': 'æ³¨æ„ï¼šé–‹å§‹æ–°å±€æœƒæ¸…é™¤ç•¶å‰æœªåŒ¯å‡ºçš„é€²åº¦ã€‚',
            'msg_confirm_clear_storage': 'ç¢ºå®šè¦æ¸…é™¤æ‰€æœ‰è‡ªå‹•å­˜æª”å—ï¼Ÿ',
            'msg_cleared': 'å­˜æª”å·²æ¸…é™¤ã€‚',
            'msg_confirm_delete_all': 'ç¢ºå®šè¦åˆªé™¤æ‰€æœ‰å‹•ä½œä¸¦é‡æ–°é–‹å§‹æ–°å±€å—ï¼Ÿ',
            'msg_init_fail': 'åˆå§‹åŒ–å¤±æ•—: ',
            'msg_storage_full': 'âš ï¸ è‡ªå‹•å­˜æª”å¤±æ•—ï¼šå„²å­˜ç©ºé–“å·²æ»¿ã€‚\n\nå»ºè­°æ‚¨ç«‹å³ã€ŒåŒ¯å‡ºã€ä¿å­˜é€²åº¦ï¼Œå¦å‰‡é—œé–‰è¦–çª—å¾Œè³‡æ–™å°‡æœƒéºå¤±ã€‚',
            'msg_unsaved_draft': 'ç›®å‰æœ‰æœªå„²å­˜çš„è®Šæ›´ï¼Œæ˜¯å¦æ¨æ£„ä¸¦é–‹å§‹æ–°æ­¥é©Ÿï¼Ÿ',
            'msg_unsaved_edit': 'ç›®å‰æœ‰æœªå„²å­˜çš„è®Šæ›´ï¼Œæ˜¯å¦æ¨æ£„ä¸¦ç·¨è¼¯æ­¤æ­¥é©Ÿï¼Ÿ',
            'msg_cannot_del_init': 'ç„¡æ³•åˆªé™¤åˆå§‹ç‹€æ…‹',
            'msg_confirm_del_step': 'ç¢ºå®šåˆªé™¤æ­¤æ­¥é©Ÿï¼Ÿ',
            'msg_replace_img': 'ç¢ºå®šè¦æ›¿æ›æ­¤å¡ç‰‡çš„åœ–ç‰‡å—ï¼Ÿ(é€™å°‡å½±éŸ¿æ‰€æœ‰åŠ‡æœ¬)',
            'msg_remove_img': 'ç¢ºå®šç§»é™¤åœ–ç‰‡ï¼Ÿ',
            'msg_confirm_p1_reset': 'ç¢ºå®šè¦é‡ç½® Player 1 çš„æˆ°å ´èˆ‡é­”åŠ›å€æ–¹å‘å—ï¼Ÿ',
            'msg_confirm_p2_reset': 'ç¢ºå®šè¦é‡ç½® Player 2 çš„æˆ°å ´èˆ‡é­”åŠ›å€æ–¹å‘å—ï¼Ÿ',
            'msg_glow_ability_only': 'åªæœ‰ã€Œå¾…è™•ç†å€ã€çš„å¡ç‰‡å¯ä»¥ä¸‹é”ç™¼å…‰æŒ‡ä»¤ã€‚\n(è‹¥æœ‰è¨­å®šä¾†æºå¡ï¼Œä¾†æºå¡æœƒè‡ªå‹•åŒæ­¥ç™¼å…‰)',
            'msg_injured_battle_only': 'åªæœ‰ã€Œæˆ°é¬¥å€ã€èˆ‡ã€Œè­·ç›¾å€ã€çš„å¡ç‰‡å¯ä»¥æ¨™è¨˜ç‚ºå—å‚·ã€‚',
            'msg_confirm_reveal_close': 'å°‡å±•ç¤ºå€å¡ç‰‡å…¨éƒ¨é€å…¥å¢“åœ°ä¸¦é—œé–‰ï¼Ÿ',
            'msg_select_one_copy': 'è«‹ä¸€æ¬¡é¸æ“‡ä¸€å¼µç‰Œé€²è¡Œè¤‡è£½',
            'msg_confirm_del_card': 'ç¢ºå®šè¦åˆªé™¤é¸å–çš„å¡ç‰‡å—ï¼Ÿ(åƒ…å»ºè­°ç”¨æ–¼èƒ½åŠ›è™•ç†å€)',
            'msg_select_one_point': 'è«‹é¸æ“‡ä¸€å¼µå¡ç‰‡é€²è¡ŒæŒ‡å‘',
            'msg_save_first': 'è«‹å…ˆå„²å­˜ç•¶å‰æ­¥é©Ÿï¼Œå†çµæŸæŒ‡å‘',
            'msg_cant_move_ability': 'èƒ½åŠ›å¾…è™•ç†å€çš„å¡ç‰‡ä¸èƒ½ç§»å‹•',
            'msg_mobile_blocked': 'æ­¤åŠŸèƒ½æœªå°è¡Œå‹•è£ç½®é–‹æ”¾',
            'msg_import_success': 'åŒ¯å…¥æˆåŠŸï¼',
            'msg_import_fail': 'åŒ¯å…¥å¤±æ•—',
            'msg_confirm_import': 'ç¢ºå®šè¦åŒ¯å…¥æ­¤æª”æ¡ˆå—ï¼Ÿ',
            'msg_load_script_fail': 'ç„¡æ³•è¼‰å…¥æŒ‡å®šåŠ‡æœ¬: '
        },
        'en': {
            // ... (åŸæœ¬çš„å…§å®¹ä¿ç•™) ...
            'btn_play_from': 'â–¶ Play From Here',
            'btn_play_step': 'ğŸ‘ï¸ Demo Step',
            'btn_edit_step': 'âœï¸ Edit',
            'btn_delete_step': 'ğŸ—‘ Delete',
            'btn_play': 'â–¶ Play',
            'btn_pause': 'â¸ Pause',
            'lbl_reveal_zone': 'Reveal Zone',
            'msg_confirm_setup': 'Warning: Starting a new game will clear unsaved progress.',
            'msg_confirm_clear_storage': 'Clear all auto-saved data?',
            'msg_cleared': 'Storage cleared.',
            'msg_confirm_delete_all': 'Delete all actions and restart?',
            'msg_init_fail': 'Init failed: ',
            'msg_storage_full': 'âš ï¸ Auto-save failed: Storage full. Please Export your data.',
            'msg_unsaved_draft': 'Discard unsaved changes and start new step?',
            'msg_unsaved_edit': 'Discard unsaved changes and edit this step?',
            'msg_cannot_del_init': 'Cannot delete initial state.',
            'msg_confirm_del_step': 'Delete this step?',
            'msg_replace_img': 'Replace image for this card? (Affects entire script)',
            'msg_remove_img': 'Remove image?',
            'msg_confirm_p1_reset': 'Reset P1 board orientation?',
            'msg_confirm_p2_reset': 'Reset P2 board orientation?',
            'msg_glow_ability_only': 'Glow is only available for cards in Ability Zone.',
            'msg_injured_battle_only': 'Only cards in Battle or Shield zone can be injured.',
            'msg_confirm_reveal_close': 'Send revealed cards to grave and close?',
            'msg_select_one_copy': 'Please select exactly one card to copy.',
            'msg_confirm_del_card': 'Delete selected card? (Recommended for Ability Zone only)',
            'msg_select_one_point': 'Please select one card to point.',
            'msg_save_first': 'Please save current step before ending point mode.',
            'msg_cant_move_ability': 'Cannot move cards in Ability Zone.',
            'msg_mobile_blocked': 'Feature not available on mobile.',
            'msg_import_success': 'Import Successful!',
            'msg_import_fail': 'Import Failed',
            'msg_confirm_import': 'Import this file?',
            'msg_load_script_fail': 'Failed to load script: '
        },
        'jp': {
            // ... (åŸæœ¬çš„å…§å®¹ä¿ç•™) ...
            'btn_play_from': 'â–¶ ã“ã“ã‹ã‚‰å†ç”Ÿ',
            'btn_play_step': 'ğŸ‘ï¸ ã“ã®æ‰‹é †ã‚’ç¢ºèª',
            'btn_edit_step': 'âœï¸ ç·¨é›†',
            'btn_delete_step': 'ğŸ—‘ å‰Šé™¤',
            'btn_play': 'â–¶ å†ç”Ÿ',
            'btn_pause': 'â¸ ä¸€æ™‚åœæ­¢',
            'lbl_reveal_zone': 'å…¬é–‹é ˜åŸŸ (Reveal)',
            'msg_confirm_setup': 'æ³¨æ„ï¼šæ–°ã—ã„ã‚²ãƒ¼ãƒ ã‚’å§‹ã‚ã‚‹ã¨ã€ä¿å­˜ã•ã‚Œã¦ã„ãªã„é€²è¡ŒçŠ¶æ³ã¯æ¶ˆå»ã•ã‚Œã¾ã™ã€‚',
            'msg_confirm_clear_storage': 'è‡ªå‹•ä¿å­˜ãƒ‡ãƒ¼ã‚¿ã‚’ã™ã¹ã¦æ¶ˆå»ã—ã¾ã™ã‹ï¼Ÿ',
            'msg_cleared': 'æ¶ˆå»ã—ã¾ã—ãŸã€‚',
            'msg_confirm_delete_all': 'ã™ã¹ã¦ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’å‰Šé™¤ã—ã¦ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿ',
            'msg_init_fail': 'åˆæœŸåŒ–å¤±æ•—: ',
            'msg_storage_full': 'âš ï¸ è‡ªå‹•ä¿å­˜å¤±æ•—ï¼šå®¹é‡ä¸è¶³ã§ã™ã€‚ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¦ãã ã•ã„ã€‚',
            'msg_unsaved_draft': 'å¤‰æ›´ã‚’ç ´æ£„ã—ã¦æ–°ã—ã„ã‚¹ãƒ†ãƒƒãƒ—ã‚’é–‹å§‹ã—ã¾ã™ã‹ï¼Ÿ',
            'msg_unsaved_edit': 'å¤‰æ›´ã‚’ç ´æ£„ã—ã¦ã“ã®ã‚¹ãƒ†ãƒƒãƒ—ã‚’ç·¨é›†ã—ã¾ã™ã‹ï¼Ÿ',
            'msg_cannot_del_init': 'åˆæœŸçŠ¶æ…‹ã¯å‰Šé™¤ã§ãã¾ã›ã‚“ã€‚',
            'msg_confirm_del_step': 'ã“ã®ã‚¹ãƒ†ãƒƒãƒ—ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ',
            'msg_replace_img': 'ç”»åƒã®å·®ã—æ›¿ãˆã‚’è¡Œã„ã¾ã™ã‹ï¼Ÿï¼ˆã™ã¹ã¦ã®ã‚¹ãƒ†ãƒƒãƒ—ã«å½±éŸ¿ã—ã¾ã™ï¼‰',
            'msg_remove_img': 'ç”»åƒã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ',
            'msg_confirm_p1_reset': 'Player 1 ã®ç›¤é¢ã®å‘ãã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿ',
            'msg_confirm_p2_reset': 'Player 2 ã®ç›¤é¢ã®å‘ãã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿ',
            'msg_glow_ability_only': 'ç™ºå…‰è¨­å®šã¯ã€ŒåŠ¹æœå‡¦ç†ã€ã‚¾ãƒ¼ãƒ³ã®ã‚«ãƒ¼ãƒ‰ã®ã¿å¯èƒ½ã§ã™ã€‚',
            'msg_injured_battle_only': 'è² å‚·ãƒãƒ¼ã‚¯ã¯ãƒãƒˆãƒ«ã‚¾ãƒ¼ãƒ³ã¾ãŸã¯ã‚·ãƒ¼ãƒ«ãƒ‰ã‚¾ãƒ¼ãƒ³ã®ã¿å¯èƒ½ã§ã™ã€‚',
            'msg_confirm_reveal_close': 'å…¬é–‹ã‚«ãƒ¼ãƒ‰ã‚’å¢“åœ°ã«é€ã‚Šã€é–‰ã˜ã¾ã™ã‹ï¼Ÿ',
            'msg_select_one_copy': 'ã‚³ãƒ”ãƒ¼ã™ã‚‹ã‚«ãƒ¼ãƒ‰ã‚’1æšé¸æŠã—ã¦ãã ã•ã„ã€‚',
            'msg_confirm_del_card': 'é¸æŠã—ãŸã‚«ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ',
            'msg_select_one_point': 'å¯¾è±¡ã®ã‚«ãƒ¼ãƒ‰ã‚’1æšé¸æŠã—ã¦ãã ã•ã„ã€‚',
            'msg_save_first': 'ç¾åœ¨ã®ã‚¹ãƒ†ãƒƒãƒ—ã‚’ä¿å­˜ã—ã¦ãã ã•ã„ã€‚',
            'msg_cant_move_ability': 'åŠ¹æœå‡¦ç†ã‚¾ãƒ¼ãƒ³ã®ã‚«ãƒ¼ãƒ‰ã¯ç§»å‹•ã§ãã¾ã›ã‚“ã€‚',
            'msg_mobile_blocked': 'ãƒ¢ãƒã‚¤ãƒ«ç«¯æœ«ã§ã¯åˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚',
            'msg_import_success': 'ã‚¤ãƒ³ãƒãƒ¼ãƒˆæˆåŠŸï¼',
            'msg_import_fail': 'ã‚¤ãƒ³ãƒãƒ¼ãƒˆå¤±æ•—',
            'msg_confirm_import': 'ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã™ã‹ï¼Ÿ',
            'msg_load_script_fail': 'ã‚¹ã‚¯ãƒªãƒ—ãƒˆã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: '
        }
    };

    let currentLang = 'zh';

    // ç”¨æ–¼å–å¾—æ­£ç¢ºçš„æ’­æ”¾æŒ‰éˆ•æ–‡å­—
    function getPlayButtonText() {
        return playInterval ? t('btn_pause') : t('btn_play');
    }

    // æ›´æ–°æ’­æ”¾æŒ‰éˆ• UI çš„å°ˆç”¨å‡½å¼
    function updatePlayButtonUI() {
        const text = getPlayButtonText();
        const deskBtn = document.getElementById('btn-play');
        const mobBtn = document.getElementById('mob-play-btn');
        
        if(deskBtn) deskBtn.innerText = text;
        if(mobBtn) mobBtn.innerText = playInterval ? "â¸" : "â–¶"; // æ‰‹æ©Ÿç‰ˆç¶­æŒç¬¦è™Ÿå°±å¥½ï¼Œæ¯”è¼ƒç°¡æ½”
    }

    function changeLanguage(lang) {
        currentLang = lang;
        const dict = TRANSLATIONS[lang];
        if (!dict) return;

        // 1. æ›´æ–°éœæ…‹æ¨™ç±¤
        document.querySelectorAll('[data-i18n]').forEach(el => {
            const key = el.getAttribute('data-i18n');
            if (dict[key]) {
                if (el.tagName === 'INPUT' && el.type === 'button') {
                    el.value = dict[key];
                } else {
                    el.innerText = dict[key];
                }
            }
        });

        // 2. æ›´æ–° Play æŒ‰éˆ• (éœ€åˆ¤æ–·ç•¶å‰æ˜¯æš«åœé‚„æ˜¯æ’­æ”¾)
        updatePlayButtonUI();

        // 3. é‡ç¹ª Timeline (è®“å‹•ä½œåˆ—è¡¨çš„æŒ‰éˆ•è®Šæˆæ–°èªè¨€)
        renderTimeline();
        
        // 4. æ›´æ–° Reveal Zone (å¦‚æœæœ‰æ‰“é–‹)
        const revealZone = document.getElementById('reveal-zone');
        if (revealZone && revealZone.style.display !== 'none') {
            const label = revealZone.querySelector('.zone-label');
            if(label) label.innerText = t('lbl_reveal_zone');
        }
        
        if (isDrafting) updateDraftBar();
        if (isPointing) updatePointInfo();
    }
    
    // è¼”åŠ©å‡½å¼ï¼šçµ¦ JS å…§éƒ¨ä½¿ç”¨çš„ç¿»è­¯
    function t(key) {
        return TRANSLATIONS[currentLang][key] || key;
    }

    class Card {
        constructor(id, ownerId, text, zone) {
            this.id = id;
            this.ownerId = ownerId;
            this.text = text;
            this.zone = zone;
            this.faceUp = false;
            this.rotation = 0; 
            this.power = 0;
            this.image = null;
            this.isHyper = false;
            this.glow = null; 
            this.parentId = null; 
            this.stackType = null; // top, bottom, shift_up, puzzle_right, etc.
            this.note = "";
            this.imageKey = 'img_' + id;
            this.backImageKey = 'img_back_' + id;
            this.sourceId = null; // New: Link to source card (for Ability cards)
        }
    }

    class GameState {
        constructor() {
            this.cards = [];
            this.turnPlayer = 1;
            // Removed phase per requirement
            this.globalRotation = false; 
            this.cardIdCounter = 1;
        }
    }

    class Action {
        constructor(description) {
            this.id = Date.now() + Math.random();
            this.description = description;
            this.operations = []; 
        }
    }

    let history = [];
    let currentIndex = -1;
    let initialState = null;
    let isDrafting = false;
    let draftOperations = []; 
    let insertIndex = -1; 
    let tempState = null; 
    let selectedCardsInModal = []; 
    let pendingMove = null; 
    let playInterval = null;
    let lastRenderedState = null;
    let editModeType = 'INSERT';
    
    let isPointing = false;
    let pointerId = null;
    let pointTargets = []; 
    let currentStackTargetId = null;
	
	let lastAnimatedStep = -1; // [è£œä¸Šé€™è¡Œ] ç”¨æ–¼è¨˜éŒ„å‹•ç•«ç‹€æ…‹ï¼Œé¿å…é‡è¤‡æ’­æ”¾
	let winOverlayTimeout = null; // [æ–°å¢] ç”¨ä¾†è¨˜éŒ„å‹åˆ©ç•«é¢çš„è‡ªå‹•é—œé–‰è¨ˆæ™‚å™¨
    
    let globalImageRegistry = {}; 
    let globalAbilityStyleRegistry = {}; 
    let storageQuotaExceeded = false; 
    let hasAlertedQuota = false;    
    let pendingImportData = null;

    const STORAGE_KEY = 'dm_editor_data_v1'; // Updated Key
    const STORAGE_EXPIRY = 7 * 24 * 60 * 60 * 1000; 

	document.addEventListener('keydown', (e) => {
        // è™•ç† Ctrl+Z (æˆ– Mac çš„ Cmd+Z)
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {
            if (isDrafting) {
                e.preventDefault(); // é˜»æ­¢ç€è¦½å™¨åŸæœ¬çš„å¾©åŸå‹•ä½œ
                undoLastDraftOp();
                return;
            }
        }

        // è™•ç† ESC
        if (e.key === 'Escape') {
            const cardModal = document.getElementById('card-selector-modal');
            const posModal = document.getElementById('position-selector-modal');
            
            if (posModal && posModal.style.display === 'flex') {
                closePositionModal();
            } else if (cardModal && cardModal.style.display === 'flex') {
                closeSelectorModal();
            } else if (isPointing) {
                cancelPointMode();
            } else {
                cancelSelection();
            }
        }
    });  
  
    // Paste Image Handling
    document.addEventListener('paste', (e) => {
        if (!pendingMove || pendingMove.cardIds.length !== 1) return;
        
        const items = (e.clipboardData || e.originalEvent.clipboardData).items;
        for (let index in items) {
            const item = items[index];
            if (item.kind === 'file' && item.type.startsWith('image/')) {
                const blob = item.getAsFile();
                const reader = new FileReader();
                reader.onload = (event) => {
                    processImage(event.target.result);
                };
                reader.readAsDataURL(blob);
                break;
            }
        }
    });
    
    function pasteImageMode() {
        if (!pendingMove || pendingMove.cardIds.length !== 1) {
            alert("è«‹å…ˆé¸æ“‡ä¸€å¼µå¡ç‰‡ï¼Œç„¶å¾ŒæŒ‰ä¸‹ Ctrl+V è²¼ä¸Šåœ–ç‰‡");
            return;
        }
        window.focus();
    }
    
    function processImage(dataUrl) {
        const img = new Image();
        img.onload = () => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const targetW = 100;
            const targetH = 140;
            canvas.width = targetW;
            canvas.height = targetH;
            ctx.drawImage(img, 0, 0, targetW, targetH);
            const compressedBase64 = canvas.toDataURL('image/jpeg', 0.8);
            updateCardImageGlobal(pendingMove.cardIds[0], compressedBase64);
        };
        img.src = dataUrl;
    }
    
    function updateCardImageGlobal(cardId, base64) {
        if(!confirm(t('msg_replace_img'))) return;
        
        const state = getCurrentDisplayState();
        const targetCard = state.cards.find(c => c.id === cardId);
        if(!targetCard) return;

        if (!targetCard.imageKey) {
            targetCard.imageKey = 'img_' + targetCard.id;
            targetCard.backImageKey = 'img_back_' + targetCard.id;
        }

        let keyToUpdate = targetCard.imageKey;
        if (targetCard.isHyper && !targetCard.faceUp) {
             keyToUpdate = targetCard.backImageKey;
        }

        globalImageRegistry[keyToUpdate] = base64;

        const setFlag = (s) => {
            const c = s.cards.find(x => x.id === cardId);
            if(c) {
                if (!c.imageKey) {
                    c.imageKey = 'img_' + c.id;
                    c.backImageKey = 'img_back_' + c.id;
                }
                c.image = true; 
            }
            
            s.cards.forEach(other => {
                if (!other.imageKey && other.id === cardId) { 
                     other.imageKey = 'img_' + other.id; 
                }
                
                if (other.imageKey === keyToUpdate || other.backImageKey === keyToUpdate) {
                    other.image = true;
                }
            });
        };
        
        setFlag(initialState);
        history.forEach(h => setFlag(h.state));
        if (tempState) setFlag(tempState);
        
        renderUI();
        saveToStorage();
    }
    
    function removeImage() {
        if (!pendingMove || pendingMove.cardIds.length !== 1) return;
        const cardId = pendingMove.cardIds[0];
        const state = getCurrentDisplayState();
        const card = state.cards.find(c => c.id === cardId);
        if(!card) return;

        if (!card.imageKey) {
            card.imageKey = 'img_' + card.id;
            card.backImageKey = 'img_back_' + card.id;
        }

        let keyToUpdate = card.imageKey;
        if (card.isHyper && !card.faceUp) {
             keyToUpdate = card.backImageKey;
        }
        
        if(!confirm(t('msg_remove_img'))) return;
        
        delete globalImageRegistry[keyToUpdate];

        const unsetFlag = (s) => {
            const c = s.cards.find(x => x.id === cardId);
            if(c) c.image = false;
            
            s.cards.forEach(other => {
                if (other.imageKey === keyToUpdate || other.backImageKey === keyToUpdate) {
                    other.image = false;
                }
            });
        };

        unsetFlag(initialState);
        history.forEach(h => unsetFlag(h.state));
        if (tempState) unsetFlag(tempState);

        saveToStorage();
        renderUI();
    }

    function cloneState(state) {
        return JSON.parse(JSON.stringify(state));
    }

    function openSetupModal() {
        const modal = document.getElementById('setup-modal');
        if(modal) modal.style.display = 'flex';
    }

    function clearStorage() {
        if(confirm(t('msg_confirm_clear_storage'))) {
            localStorage.removeItem(STORAGE_KEY);
            alert(t('msg_cleared'));
            location.reload();
        }
    }
    
    function deleteAllActions() {
        if(!confirm(t('msg_confirm_delete_all'))) return;
        
        history = [];
        initialState = null;
        currentIndex = -1;
        draftOperations = [];
        isDrafting = false;
        
        localStorage.removeItem(STORAGE_KEY);
        storageQuotaExceeded = false;
        hasAlertedQuota = false;

        document.getElementById('action-list').innerHTML = '';
        document.getElementById('step-counter').innerText = '0/0';
        updateDraftBar();
        
        openSetupModal();
    }

    function finishSetup() {
        try {
            const getVal = (id, def) => {
                const el = document.getElementById(id);
                if(!el) return def;
                const val = parseInt(el.value);
                return isNaN(val) ? def : val;
            };

            const p1d = getVal('setup-p1-deck', 40);
            const p1h = getVal('setup-p1-hyper', 8);
            const p2d = getVal('setup-p2-deck', 40);
            const p2h = getVal('setup-p2-hyper', 8);
            
            initGame({p1d, p1h, p2d, p2h});
            document.getElementById('setup-modal').style.display = 'none';
        } catch (e) {
            console.error(e);
            alert(t('msg_init_fail') + e.message)
        }
    }

    function initGame(config) {
        const state = new GameState();
        globalImageRegistry = {}; 
        globalAbilityStyleRegistry = {};
        
        if(!config) config = {p1d:40, p1h:8, p2d:40, p2h:8};

        const zones = [
            {id: 'p1-deck', count: config.p1d, prefix: 'C'}, {id: 'p1-hyper', count: config.p1h, prefix: 'H', hyper:true},
            {id: 'p2-deck', count: config.p2d, prefix: 'C'}, {id: 'p2-hyper', count: config.p2h, prefix: 'H', hyper:true}
        ];
        
        state.cards = []; 
        
        zones.forEach(z => {
            for(let i=0; i<z.count; i++) {
                let c = new Card(state.cardIdCounter++, z.id.startsWith('p1')?1:2, `${z.prefix}-${i+1}`, z.id);
                if(z.hyper) { c.isHyper=true; c.faceUp=true; }
                state.cards.push(c);
            }
        });

        initialState = cloneState(state);
        history = [];
        let initAct = new Action('éŠæˆ²é–‹å§‹');
        initAct.operations.push({type: 'INIT'});
        history.push({ action: initAct, state: initialState });
        currentIndex = 0;

        isDrafting = false;
        draftOperations = [];
        updateDraftBar();
        renderUI();
        saveToStorage();
    }

	function saveToStorage() {
        // --- [æ–°å¢] æ‰‹æ©Ÿæ’­æ”¾æ¨¡å¼ä¸‹ï¼Œçµ•å°ä¸è¦å­˜æª” ---
        // é€™æ¨£å¯ä»¥ç¢ºä¿è§€çœ‹ Script æ™‚ï¼Œä¸æœƒè¦†è“‹æ‰ä½¿ç”¨è€…åŸæœ¬çš„ç·¨è¼¯é€²åº¦
        if (document.body.classList.contains('mobile-mode')) return;
        // ----------------------------------------

        try {
            const data = {
                timestamp: Date.now(),
                history: history,
                initialState: initialState,
                currentIndex: currentIndex,
                imageRegistry: globalImageRegistry,
                abilityRegistry: globalAbilityStyleRegistry 
            };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
            if (storageQuotaExceeded) {
                storageQuotaExceeded = false;
                hasAlertedQuota = false;
            }
        } catch(e) {
            console.warn("Storage save failed (Quota?)", e);
            storageQuotaExceeded = true;
            if (!hasAlertedQuota) {
                alert(t('msg_storage_full'));
                hasAlertedQuota = true;
            }
        }
    }

    function loadFromStorage() {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return false;
        try {
            const data = JSON.parse(raw);
            if (!data || !data.history || !data.initialState) return false;
            if (data.timestamp && (Date.now() - data.timestamp > STORAGE_EXPIRY)) {
                localStorage.removeItem(STORAGE_KEY);
                return false;
            }
            
            history = data.history;
            initialState = data.initialState;
            currentIndex = (typeof data.currentIndex === 'number' && data.currentIndex >= -1 && data.currentIndex < history.length) 
                           ? data.currentIndex 
                           : (history.length - 1);
                           
            globalImageRegistry = data.imageRegistry || {}; 
            globalAbilityStyleRegistry = data.abilityRegistry || {}; 
            
            try { renderUI(); } catch(e) {}
            return true;
        } catch (e) {
            return false;
        }
    }

    function getCurrentDisplayState() {
        return isDrafting ? tempState : ((currentIndex >= 0 && currentIndex < history.length) ? history[currentIndex].state : initialState);
    }

    function startDraftAtEnd() {
        startDraft(history.length);
    }

	function startDraft(index) {
        if (isDrafting) {
            if(!confirm(t('msg_unsaved_draft'))) return;
        }
        
        isDrafting = true;
        insertIndex = index;
        draftOperations = [];
        editModeType = 'INSERT';
        
        let baseIndex = index - 1;
        if (baseIndex < 0) baseIndex = 0; 
        
        tempState = cloneState(history[baseIndex].state);

        // --- [æ–°å¢] æ¸…é™¤ä¸Šä¸€å±€çš„å—å‚·ç‹€æ…‹ (ä¸ç¹¼æ‰¿) ---
        // é€™æ¨£æ–°æ­¥é©Ÿé–‹å§‹æ™‚ï¼Œå¡ç‰‡æœƒæ¢å¾©ä¹¾æ·¨
        tempState.cards.forEach(c => {
             if(c.isInjured) c.isInjured = false;
        });
        // ------------------------------------------
        
        updateDraftBar();
        renderUI();
    }

    function editAction(index) {
        if (isDrafting) {
            if(!confirm(t('msg_unsaved_edit'))) return;
        }
        
        isDrafting = true;
        insertIndex = index; 
        editModeType = 'EDIT';
        
        let baseIndex = index - 1;
        if (baseIndex < 0) {
            tempState = cloneState(initialState);
        } else {
            tempState = cloneState(history[baseIndex].state);
        }
        
        const actionToEdit = history[index].action;
        draftOperations = [...actionToEdit.operations];
        
        draftOperations.forEach(op => applyOperation(tempState, op));
        
        updateDraftBar();
        renderUI();
    }

    function addOperation(op) {
        if (!isDrafting) startDraftAtEnd();
        applyOperation(tempState, op);
        draftOperations.push(op);
        updateDraftBar();
        renderUI();
    }

	// --- æ–°å¢åŠŸèƒ½: é‚„åŸä¸Šä¸€æ­¥ (Ctrl+Z) ---
    function undoLastDraftOp() {
        if (!isDrafting) return;
        if (draftOperations.length === 0) return;

        // 1. ç§»é™¤ Draft ä¸­çš„æœ€å¾Œä¸€å€‹æ“ä½œ
        draftOperations.pop();

        // 2. é‡æ–°è¨ˆç®— tempState
        // å¿…é ˆå¾ Draft é–‹å§‹å‰çš„ç‹€æ…‹ (Base State) é‡æ–°å¥—ç”¨å‰©é¤˜çš„æ“ä½œ
        let baseIndex = insertIndex - 1;
        let baseState;
        
        if (baseIndex < 0) {
            baseState = cloneState(initialState);
        } else {
            // å–å‡ºé€²å…¥ç·¨è¼¯æ¨¡å¼å‰çš„ç‹€æ…‹å¿«ç…§
            baseState = cloneState(history[baseIndex].state);
        }

        // é‡ç½® tempState ç‚ºåˆå§‹ç‹€æ…‹
        tempState = baseState;

        // ä¾åºé‡æ–°åŸ·è¡Œå‰©é¤˜çš„æ‰€æœ‰æ“ä½œ
        draftOperations.forEach(op => applyOperation(tempState, op));

        // 3. æ›´æ–°ä»‹é¢
        updateDraftBar();
        renderUI();
        
        // è‹¥å‰›å¥½é‚„åŸäº†ç§»å‹•æ“ä½œï¼Œå–æ¶ˆç›®å‰çš„é¸å–ç‹€æ…‹ä»¥é¿å… UI éŒ¯äº‚
        cancelSelection(); 
    }
	
    function saveDraft(customDesc) {
        if (draftOperations.length === 0) {
            isDrafting = false;
            updateDraftBar();
            renderUI();
            return;
        }

        let desc = customDesc;
        if (!desc && editModeType === 'EDIT' && insertIndex < history.length) {
             desc = history[insertIndex].action.description;
        }
        if (!desc) {
            const opCount = draftOperations.length;
            const firstOp = draftOperations[0];
            let map = {
                'MOVE': 'ç§»å‹•', 'SHUFFLE': 'æ´—ç‰Œ', 'ROTATE': 'æ—‹è½‰è¦–è§’', 
                'ROTATE_CARD': 'æ—‹è½‰å¡ç‰‡', 'FLIP_CARD': 'ç¿»è½‰å¡ç‰‡', 'RENAME_CARD': 'æ›´å', 
                'RESET_BOARD': 'é‡ç½®ç›¤é¢', 'SET_GLOW': 'è¨­å®šç™¼å…‰', 'CREATE_ABILITY': 'ç”¢ç”Ÿèƒ½åŠ›', 'DELETE_CARD': 'åˆªé™¤å¡ç‰‡',
                'POINT': 'æŒ‡å‘', 'ATTACK': 'æ”»æ“Š', 'ADD_NOTE': 'æ–°å¢è¨»è¨˜', 'ADJUST_STYLE': 'èª¿æ•´æ¨£å¼', 'SWITCH_TURN': 'æ›äºº'
            };
            let typeDesc = map[firstOp.type] || 'æ“ä½œ';
            if (firstOp.type === 'POINT') {
                desc = firstOp.desc || 'æŒ‡å‘';
            } else if (firstOp.type === 'ATTACK') {
                desc = firstOp.desc || 'æ”»æ“Šå®£è¨€';
            } else {
                desc = `${typeDesc} ç­‰ ${opCount} å€‹å‹•ä½œ`;
            }
        }

        const newAction = new Action(desc);
        newAction.operations = [...draftOperations];
        const finalState = cloneState(tempState);
        const newItem = { action: newAction, state: finalState };

        const propagate = document.getElementById('propagate-check').checked;

        const head = history.slice(0, insertIndex);
        let tail = [];
        
        if (editModeType === 'EDIT') {
            tail = history.slice(insertIndex + 1);
        } else {
            tail = history.slice(insertIndex);
        }

        if (propagate) {
            let runningState = cloneState(finalState);
            tail = tail.map(item => {
                try {
                    item.action.operations.forEach(op => applyOperation(runningState, op));
                } catch(e) { console.error("Propagate Error", e); }
                return { action: item.action, state: cloneState(runningState) };
            });
        }

        history = [...head, newItem, ...tail];

        isDrafting = false;
        currentIndex = insertIndex; 
        insertIndex = -1;
        draftOperations = [];
        updateDraftBar();
        renderUI();
        saveToStorage();
    }

    function cancelDraft() {
        isDrafting = false;
        draftOperations = [];
        cancelSelection();
        updateDraftBar();
        if(currentIndex >= history.length) currentIndex = history.length - 1;
        renderUI();
    }

    function updateDraftBar() {
        const bar = document.getElementById('draft-bar');
        if (isDrafting) {
            bar.style.display = 'flex';
            // ä½¿ç”¨ t() ç¿»è­¯æŒ‰éˆ•
            const saveBtn = bar.querySelector('.primary');
            const cancelBtn = bar.querySelector('.danger');
            // æ³¨æ„ï¼šé€™è£¡å‡è¨­ä½ çš„ HTML æŒ‰éˆ•çµæ§‹æ²’è®Šï¼Œå»ºè­°çµ¦æŒ‰éˆ•åŠ ä¸Š ID æˆ– data-i18n æœƒæ›´ç©©
            // ç°¡å–®ç¤ºç¯„ï¼š
            document.querySelector('#draft-bar button.primary').innerText = t('btn_save_step');
            document.querySelector('#draft-bar button.danger').innerText = t('btn_cancel_draft');
            document.getElementById('draft-count').innerText = draftOperations.length;
        } else {
            bar.style.display = 'none';
        }
    }

    function deleteAction(index) {
        if (index === 0) return alert(t('msg_cannot_del_init'));
        if (!confirm(t('msg_confirm_del_step'))) return;

        const head = history.slice(0, index);
        let tail = history.slice(index + 1);
        
        history = [...head, ...tail];

        lastRenderedState = null; 
        if (currentIndex >= history.length) currentIndex = history.length - 1;
        
        cancelSelection(); 
        renderUI();
        saveToStorage();
    }

function applyOperation(state, op) {
        if (op.type === 'PASS') return;
        
        // --- æ–°å¢: ç”¨æ–¼åˆ‡æ–·é€£çµçš„æ“ä½œ ---
        if (op.type === 'BREAK_LINKS') {
            const { cardIds } = op;
            state.cards.forEach(c => {
                if (cardIds.includes(c.id)) {
                    c.parentId = null;
                    c.stackType = null;
                }
                if (c.parentId && cardIds.includes(c.parentId)) {
                    c.parentId = null;
                    c.stackType = null;
                }
            });
        }
        // --- [æ–°å¢] å‹åˆ©ç‹€æ…‹ ---
        else if (op.type === 'GAME_WIN') {
            const { winnerId } = op;
            state.winner = winnerId; // åœ¨ç‹€æ…‹ä¸­è¨˜éŒ„è´å®¶
        }
        // ----------------------
        else if (op.type === 'MOVE') {
            const { cardIds, toZone, faceUp, shuffleSelection, insertIndex, stackTargetId, stackType } = op;
            let movingCards = state.cards.filter(c => cardIds.includes(c.id));
            
            if(shuffleSelection) movingCards.sort(() => Math.random() - 0.5); 
            
            state.cards = state.cards.filter(c => !cardIds.includes(c.id));
            movingCards.forEach(c => {
                c.zone = toZone;
                c.parentId = null;
                c.stackType = null;
                if (faceUp !== undefined) c.faceUp = faceUp;
                if (toZone.includes('hand') || toZone.includes('deck')) c.rotation = 0; 
                if (stackTargetId) {
                    c.parentId = stackTargetId;
                    c.stackType = stackType;
                }
            });

            if (insertIndex !== undefined && insertIndex !== -1) {
                let zoneCards = state.cards.filter(c => c.zone === toZone);
                let otherCards = state.cards.filter(c => c.zone !== toZone);
                zoneCards.splice(insertIndex, 0, ...movingCards);
                state.cards = [...otherCards, ...zoneCards];
            } else {
                state.cards.push(...movingCards);
            }

        } else if (op.type === 'SHUFFLE') {
            const { zoneId, order } = op; 
            let zoneCards = state.cards.filter(c => c.zone === zoneId);
            let otherCards = state.cards.filter(c => c.zone !== zoneId);
            if (order) {
                zoneCards = order.map(id => state.cards.find(c => c.id === id)).filter(c=>c);
            } else {
                zoneCards.sort(() => Math.random() - 0.5);
            }
            state.cards = [...otherCards, ...zoneCards];

        } else if (op.type === 'ROTATE' || op.type === 'SWITCH_TURN') {
            state.turnPlayer = state.turnPlayer === 1 ? 2 : 1;
        } 
        else if (op.type === 'ROTATE_CARD') {
            const { cardIds, deg, finalRotation } = op;
            state.cards.forEach(c => {
                if (cardIds.includes(c.id)) {
                    if (finalRotation !== undefined) c.rotation = finalRotation;
                    else c.rotation = (c.rotation + deg) % 360;
                }
            });
        }
        else if (op.type === 'FLIP_CARD') {
            const { cardIds, finalFaceUp } = op;
            state.cards.forEach(c => {
                if (cardIds.includes(c.id)) {
                    if (finalFaceUp !== undefined) c.faceUp = finalFaceUp;
                    else c.faceUp = !c.faceUp;
                }
            });
        }
        else if (op.type === 'RENAME_CARD') {
            const { cardIds, text } = op;
            const targets = state.cards.filter(c => cardIds.includes(c.id));
            targets.forEach(target => {
                 state.cards.forEach(c => {
                     if (c.imageKey === target.imageKey) {
                         c.text = text;
                     }
                 });
            });
        }
        else if (op.type === 'RESET_BOARD') {
            const { playerId } = op;
            state.cards.forEach(c => {
                if (c.zone.includes(`p${playerId}-battle`)) {
                    c.rotation = 0;
                }
                else if (c.zone.includes(`p${playerId}-mana`)) {
                    c.rotation = 180;
                }
            });
        }
        else if (op.type === 'SET_GLOW') {
            const { cardIds, color } = op;
            state.cards.forEach(c => {
                if (cardIds.includes(c.id)) {
                    if (c.zone.includes('ability')) {
                        c.glow = color;
                        if (c.sourceId) {
                            const source = state.cards.find(s => s.id === c.sourceId);
                            if (source) {
                                source.glow = color;
                            }
                        }
                    }
                }
            });
        }
        else if (op.type === 'INJURED') {
            const { cardIds, setInjured } = op;
            state.cards.forEach(c => {
                if (cardIds.includes(c.id)) {
                    c.isInjured = setInjured;
                }
            });
        }
        else if (op.type === 'CREATE_ABILITY') {
            const { sourceCardId, targetZone, newId } = op;
            const source = state.cards.find(c => c.id === sourceCardId);
            if (source) {
                let idToUse = newId;
                if (!idToUse) {
                     idToUse = state.cards.reduce((max, c) => Math.max(max, c.id), 0) + 1;
                }
                const newCard = new Card(idToUse, source.ownerId, source.text + " (Eff)", targetZone);
                newCard.faceUp = true;
                newCard.rotation = 0;
                
                newCard.imageKey = source.imageKey; 
                newCard.backImageKey = source.backImageKey;
                newCard.image = source.image; 
                newCard.text = source.text;
                newCard.sourceId = source.id; 
                
                state.cards.push(newCard);
            }
        }
        else if (op.type === 'DELETE_CARD') {
            const { cardIds } = op;
            cardIds.forEach(id => {
               const c = state.cards.find(x => x.id === id);
               if (c && c.zone.includes('ability') && c.sourceId) {
                   const source = state.cards.find(s => s.id === c.sourceId);
                   if (source) source.glow = null;
               }
            });
            state.cards = state.cards.filter(c => !cardIds.includes(c.id));
        }
        else if (op.type === 'POINT') { }
        else if (op.type === 'ATTACK') {
            const { attackerId } = op;
            const card = state.cards.find(c => c.id === attackerId);
            if(card) {
                card.rotation = 90; 
            }
        }
        else if (op.type === 'ADD_NOTE') {
            const { cardIds, note } = op;
            state.cards.forEach(c => {
                if(cardIds.includes(c.id)) c.note = note;
            });
        }
        else if (op.type === 'ADJUST_STYLE') {
            const { cardIds, key, val, isDelta } = op;
            state.cards.forEach(c => {
                if(cardIds.includes(c.id)) {
                    if (isDelta) c[key] += val;
                    else c[key] = val;
                }
            });
        }
    }
	
	
function finishMove(toZone, insertIdx, stackTargetId = null, stackType = null) {
        if (!pendingMove) return;

        // --- START: ç§»å‹•å‰å…ˆåˆ‡æ–·èˆŠé€£çµ ---
        const state = getCurrentDisplayState();
        // æª¢æŸ¥è¢«ç§»å‹•çš„å¡ç‰‡ä¸­ï¼Œæ˜¯å¦æœ‰ä»»ä½•ä¸€å¼µå±¬æ–¼å †ç–Šçµæ§‹(æœ‰çˆ¶å¡ æˆ– æœ‰å­å¡)
        const needsBreak = pendingMove.cardIds.some(id => {
            const c = state.cards.find(x => x.id === id);
            if (!c) return false;
            // 1. æˆ‘æ˜¯å­å¡ (é€£è‘—åˆ¥äºº)
            if (c.parentId) return true;
            // 2. æˆ‘æ˜¯çˆ¶å¡ (åˆ¥äººé€£è‘—æˆ‘)
            const isParent = state.cards.some(child => child.parentId === c.id);
            if (isParent) return true;
            return false;
        });

        if (needsBreak) {
            // åœ¨ç”¢ç”Ÿ MOVE å‹•ä½œå‰ï¼Œå…ˆæ’å…¥ä¸€å€‹ BREAK_LINKS å‹•ä½œ
            addOperation({ type: 'BREAK_LINKS', cardIds: [...pendingMove.cardIds] });
        }
        // --- END: ç§»å‹•å‰å…ˆåˆ‡æ–·èˆŠé€£çµ ---
        
        let finalCardIds = [...pendingMove.cardIds];
        if (pendingMove.shuffle) {
            finalCardIds.sort(() => Math.random() - 0.5);
        }

        let faceUp = true;
        if (toZone.includes('shield') || toZone.includes('deck')) faceUp = false;
        if (toZone.includes('hand') && toZone.includes('p2')) faceUp = true;

        addOperation({
            type: 'MOVE',
            cardIds: finalCardIds, 
            toZone: toZone,
            faceUp: faceUp,
            shuffleSelection: false, 
            insertIndex: insertIdx,
            stackTargetId: stackTargetId,
            stackType: stackType
        });

        cancelSelection();
        closeSelectorModal();
        closePositionModal();
    }

    function actionShuffleZone() {
        const zoneId = document.getElementById('modal-title').getAttribute('data-zone-id');
        if(!zoneId) return;
        
        const state = getCurrentDisplayState();
        const cards = getCardsInZone(state, zoneId);
        const ids = cards.map(c => c.id);
        ids.sort(() => Math.random() - 0.5); 
        
        addOperation({ type: 'SHUFFLE', zoneId: zoneId, order: ids });
        closeSelectorModal();
    }

    function rotateCard(deg) {
        if (!pendingMove) return;
        addOperation({ type: 'ROTATE_CARD', cardIds: pendingMove.cardIds, deg: deg });
    }

    function flipCard() {
        if (!pendingMove) return;
        const state = getCurrentDisplayState();
        const card = state.cards.find(c => c.id === pendingMove.cardIds[0]);
        const targetFace = !card.faceUp;
        addOperation({ type: 'FLIP_CARD', cardIds: pendingMove.cardIds, finalFaceUp: targetFace });
    }

    function renameCard() {
        if (!pendingMove || pendingMove.cardIds.length === 0) return;
        
        const text = document.getElementById('rename-input').value;
        const state = getCurrentDisplayState();
        
        const targetKeys = new Set();
        pendingMove.cardIds.forEach(id => {
            const c = state.cards.find(x => x.id === id);
            if(c) {
                if(c.imageKey) targetKeys.add(c.imageKey);
                if(c.backImageKey) targetKeys.add(c.backImageKey);
            }
        });

        const applyRename = (cardList) => {
            cardList.forEach(c => {
                const isTarget = pendingMove.cardIds.includes(c.id) || 
                                 (c.imageKey && targetKeys.has(c.imageKey)) ||
                                 (c.backImageKey && targetKeys.has(c.backImageKey));
                if (isTarget) {
                    c.text = text;
                }
            });
        };

        applyRename(initialState.cards);
        history.forEach(h => { if(h.state) applyRename(h.state.cards); });
        if(tempState) applyRename(tempState.cards);
        
        renderUI();
        saveToStorage();
    }
    
    function addCardNote() {
        if (!pendingMove) return;
        const note = document.getElementById('note-input').value;
        addOperation({ type: 'ADD_NOTE', cardIds: pendingMove.cardIds, note: note });
    }
    
    function adjustAbilityCard(key, val) {
        if (!pendingMove || pendingMove.cardIds.length === 0) return;
        
        const state = getCurrentDisplayState();
        const targetIds = pendingMove.cardIds;
        
        const keysToUpdate = new Set();
        targetIds.forEach(id => {
            const c = state.cards.find(card => card.id === id);
            if (c) {
                if (c.imageKey) keysToUpdate.add(c.imageKey);
                else if (c.backImageKey) keysToUpdate.add(c.backImageKey);
            }
        });

        if (keysToUpdate.size === 0) return;

        keysToUpdate.forEach(imgKey => {
            let currentStyle = globalAbilityStyleRegistry[imgKey] || { x: 50, y: 50, scale: 1 };
            let newStyle = { ...currentStyle };

            if (key === 'panX') newStyle.x += val;
            else if (key === 'panY') newStyle.y += val;
            else if (key === 'scale') newStyle.scale += val;

            globalAbilityStyleRegistry[imgKey] = newStyle;
        });

        renderUI();
        saveToStorage();
    }
    
    function resetBoard(playerId) {
        if(!confirm(playerId === 1 ? t('msg_confirm_p1_reset') : t('msg_confirm_p2_reset'))) return;
        addOperation({ type: 'RESET_BOARD', playerId: playerId });
    }

    function toggleGlow() {
        if (!pendingMove) return;
        const state = getCurrentDisplayState();
        
        // Strict Check: Only Ability Zone cards can trigger Glow
        const invalid = pendingMove.cardIds.some(id => {
            const c = state.cards.find(x => x.id === id);
            return !c || !c.zone.includes('ability');
        });

        if (invalid) {
            alert(t('msg_glow_ability_only'));
            return;
        }

        const colors = ['red', 'yellow', 'green', 'blue', 'black', 'white', 'rainbow', null];
        const firstId = pendingMove.cardIds[0];
        const card = state.cards.find(c => c.id === firstId);
        let currentGlow = card ? card.glow : null;
        let idx = colors.indexOf(currentGlow);
        if (idx === -1) idx = 7; 
        let nextColor = colors[(idx + 1) % colors.length];
        
        addOperation({ type: 'SET_GLOW', cardIds: pendingMove.cardIds, color: nextColor });
    }

    function removeGlow() {
        if (!pendingMove) return;
        // Same strict check for removing glow manually via UI
        const state = getCurrentDisplayState();
        const invalid = pendingMove.cardIds.some(id => {
            const c = state.cards.find(x => x.id === id);
            return !c || !c.zone.includes('ability');
        });
        
        if (invalid) {
             alert("åªæœ‰ã€Œå¾…è™•ç†å€ã€çš„å¡ç‰‡å¯ä»¥æ“ä½œç™¼å…‰ç‹€æ…‹ã€‚");
             return;
        }

        addOperation({ type: 'SET_GLOW', cardIds: pendingMove.cardIds, color: null });
    }
    
    function revealCards() {
        if(!pendingMove) return;
        finishMove('reveal-zone', undefined);
    }
    
    function revealFromSelector() {
        if(selectedCardsInModal.length === 0) return;
        pendingMove = { cardIds: [...selectedCardsInModal], shuffle: false };
        closeSelectorModal();
        finishMove('reveal-zone', undefined);
    }
    
    function closeRevealZone() {
        if(confirm(t('msg_confirm_reveal_close'))) {
             const state = getCurrentDisplayState();
             const cards = state.cards.filter(c => c.zone === 'reveal-zone');
             const p1Cards = cards.filter(c => c.ownerId === 1).map(c=>c.id);
             const p2Cards = cards.filter(c => c.ownerId === 2).map(c=>c.id);
             
             if (!isDrafting) startDraftAtEnd();
             
             if(p1Cards.length > 0) {
                 addOperation({
                    type: 'MOVE',
                    cardIds: p1Cards,
                    toZone: 'p1-grave',
                    faceUp: true,
                    shuffleSelection: false
                 });
             }
             if(p2Cards.length > 0) {
                 addOperation({
                    type: 'MOVE',
                    cardIds: p2Cards,
                    toZone: 'p2-grave',
                    faceUp: true,
                    shuffleSelection: false
                 });
             }
             saveDraft("çµæŸå±•ç¤º (End Reveal)");
        }
    }

    function endPoint() {
        if (isDrafting) {
            alert("è«‹å…ˆå„²å­˜ç•¶å‰æ­¥é©Ÿï¼Œå†çµæŸæŒ‡å‘");
            return;
        }
        startDraftAtEnd();
        addOperation({ type: 'PASS' });
        saveDraft("çµæŸæŒ‡å‘ (End Pointing)");
    }
	
	// --- [æ–°å¢] è§¸ç™¼å‹åˆ© ---
    function triggerWin(winnerId) {
        if (!isDrafting) startDraftAtEnd();
        
        addOperation({ 
            type: 'GAME_WIN', 
            winnerId: winnerId 
        });
        
        saveDraft(`Player ${winnerId} ç²å‹!!`);
    }
	
	// --- [æ–°å¢] åˆ‡æ›å—å‚·ç‹€æ…‹ ---
    function toggleInjured() {
        if (!pendingMove) return;
        
        // æª¢æŸ¥æ˜¯å¦ç¬¦åˆå€åŸŸé™åˆ¶ (åƒ…æˆ°é¬¥å€èˆ‡è­·ç›¾å€)
        const state = getCurrentDisplayState();
        const validZones = ['p1-battle', 'p2-battle', 'p1-shield', 'p2-shield'];
        const isValid = pendingMove.cardIds.every(id => {
            const c = state.cards.find(x => x.id === id);
            return c && validZones.includes(c.zone);
        });

        if (!isValid) {
            alert("åªæœ‰ã€Œæˆ°é¬¥å€ã€èˆ‡ã€Œè­·ç›¾å€ã€çš„å¡ç‰‡å¯ä»¥æ¨™è¨˜ç‚ºå—å‚·ã€‚");
            return;
        }

        // åˆ¤æ–·æ˜¯è¦å…¨éƒ¨åŠ å—å‚·ï¼Œé‚„æ˜¯å…¨éƒ¨å–æ¶ˆ (è‹¥å…¶ä¸­ä¸€å¼µå·²å—å‚·ï¼Œå‰‡è¦–ç‚ºè¦å–æ¶ˆ)
        const hasInjured = pendingMove.cardIds.some(id => {
            const c = state.cards.find(x => x.id === id);
            return c.isInjured;
        });

        addOperation({ 
            type: 'INJURED', 
            cardIds: pendingMove.cardIds, 
            setInjured: !hasInjured // å¦‚æœæœ‰äººå—å‚·å°±å…¨éƒ¨å–æ¶ˆï¼Œå¦å‰‡å…¨éƒ¨è¨­ç‚ºå—å‚·
        });
    }

    function copyToAbility() {
        if (!pendingMove) return;
        if (pendingMove.cardIds.length !== 1) return alert("è«‹ä¸€æ¬¡é¸æ“‡ä¸€å¼µç‰Œé€²è¡Œè¤‡è£½");
        
        const state = getCurrentDisplayState();
        const card = state.cards.find(c => c.id === pendingMove.cardIds[0]);
        if (!card) return;
        
        const targetZone = card.ownerId === 1 ? 'p1-ability' : 'p2-ability';
        const newId = state.cards.reduce((max, c) => Math.max(max, c.id), 0) + 1; 
        
        addOperation({ type: 'CREATE_ABILITY', sourceCardId: card.id, targetZone: targetZone, newId: newId });
    }

    function deleteSelectedCard() {
        if (!pendingMove) return;
        if(!confirm("ç¢ºå®šè¦åˆªé™¤é¸å–çš„å¡ç‰‡å—ï¼Ÿ(åƒ…å»ºè­°ç”¨æ–¼èƒ½åŠ›è™•ç†å€)")) return;
        
        addOperation({ type: 'DELETE_CARD', cardIds: pendingMove.cardIds });
        cancelSelection();
    }

    // --- Point Mode Logic ---
    function enterPointMode() {
        if (!pendingMove || pendingMove.cardIds.length !== 1) return alert("è«‹é¸æ“‡ä¸€å¼µå¡ç‰‡é€²è¡ŒæŒ‡å‘");
        pointerId = pendingMove.cardIds[0];
        isPointing = true;
        pointTargets = [];
        
        document.getElementById('card-action-panel').style.display = 'none';
        document.getElementById('point-bar').style.display = 'flex';
        updatePointInfo();
        document.querySelectorAll('.zone').forEach(el => el.classList.add('point-target-highlight'));
        renderUI(); 
    }

    function cancelPointMode() {
        isPointing = false;
        pointerId = null;
        pointTargets = [];
        document.getElementById('point-bar').style.display = 'none';
        document.querySelectorAll('.point-target-highlight').forEach(el => el.classList.remove('point-target-highlight'));
        document.querySelectorAll('.point-target-selected').forEach(el => el.classList.remove('point-target-selected'));
        cancelSelection(); 
    }

	function handlePointClick(zoneId, cardId) {
        if (!isPointing) return;
        
        // [ä¿®æ”¹] å…è¨±æŒ‡å‘ ç‰Œåº«(Deck)ã€è¶…æ¬¡å…ƒ(Hyper)ã€å¢“åœ°(Grave) ä¸‰ç¨®å€åŸŸ
        if (!cardId && (zoneId.includes('deck') || zoneId.includes('hyper') || zoneId.includes('grave'))) {
             let zoneName = "å€åŸŸ";
             if(zoneId.includes('deck')) zoneName = "ç©å®¶/ç‰Œåº«";
             if(zoneId.includes('hyper')) zoneName = "è¶…æ¬¡å…ƒå€";
             if(zoneId.includes('grave')) zoneName = "å¢“åœ°å€";

             if (confirm(`ç¢ºèªæŒ‡å‘ ${zoneName}?`)) {
                 finishPoint('ZONE', null); // é€™è£¡ä½¿ç”¨ 'ZONE' é¡å‹ï¼Œæœƒå‚³å…¥ null idsï¼Œéœ€åœ¨ finishPoint è™•ç†æˆ–ç›´æ¥ç”¨ DOM
             }
             return;
        }
        
        if (cardId) {
            if (pointTargets.includes(cardId)) {
                pointTargets = pointTargets.filter(id => id !== cardId);
            } else {
                pointTargets.push(cardId);
            }
            updatePointInfo();
            renderUI(); 
        }
    }

    function updatePointInfo() {
        const btn = document.getElementById('btn-confirm-point');
        const info = document.getElementById('point-target-info');
        if (pointTargets.length > 0) {
            info.innerText = `å·²é¸æ“‡ ${pointTargets.length} å€‹ç›®æ¨™`;
            btn.style.display = 'block';
        } else {
            info.innerText = "è«‹é»æ“Šç›®æ¨™...";
            btn.style.display = 'none';
        }
    }

    function confirmPointTargets() {
        if (pointTargets.length === 0) return;
        finishPoint('CARD', pointTargets);
    }

    function finishPoint(type, targetIds) {
        const state = getCurrentDisplayState();
        const pointer = state.cards.find(c => c.id === pointerId);
        let desc = `[æŒ‡å‘] ${pointer.text} æŒ‡å‘ `;
        if (type === 'PLAYER') desc += 'ç©å®¶/ç‰Œåº«';
        else if (type === 'CARD') desc += `${targetIds.length} å€‹ç›®æ¨™`;

        addOperation({
            type: 'POINT',
            attackerId: pointerId,
            targetType: type,
            targetIds: targetIds,
            desc: desc
        });
        cancelPointMode();
    }

    function handleZoneClick(zoneId) {
        if (isPointing) {
            handlePointClick(zoneId, null); 
            return;
        }

        if (pendingMove) {
            const state = getCurrentDisplayState();
            // FILTER: Prevent moving Ability cards
            const hasAbilityCard = pendingMove.cardIds.some(id => {
                const c = state.cards.find(card => card.id === id);
                return c && c.zone.includes('ability');
            });
            if(hasAbilityCard) {
                alert("èƒ½åŠ›å¾…è™•ç†å€çš„å¡ç‰‡ä¸èƒ½ç§»å‹•");
                return;
            }

            if (isStackZone(zoneId)) {
                openPositionSelector(zoneId, pendingMove);
            } else {
                finishMove(zoneId, undefined);
            }
            return;
        }
        openSelectorModal(zoneId);
    }
    
    document.addEventListener('click', (e) => {
        if (e.target.closest('.card') || e.target.closest('.zone') || e.target.closest('button') || e.target.closest('input') || e.target.closest('.modal')) return;
        if (!isPointing) cancelSelection();
    });

    function cancelSelection() {
        if (pendingMove) {
            pendingMove = null;
            document.querySelectorAll('.zone').forEach(el => el.classList.remove('target-highlight'));
            document.querySelectorAll('.card.selected').forEach(el => el.classList.remove('selected'));
            document.getElementById('card-action-panel').style.display = 'none';
        }
    }

    function isStackZone(zid) {
        return zid.includes('deck') || zid.includes('shield') || zid.includes('hyper');
    }

	function handleCardSingleClick(e, cardId) {
        e.stopPropagation(); 
        
        if (isPointing) {
            handlePointClick(null, cardId);
            return;
        }

        if (pendingMove) {
            // å¦‚æœé»æ“Šå·²é¸å–çš„å¡ç‰‡ -> å–æ¶ˆé¸å–è©²å¼µ
            if (pendingMove.cardIds.includes(cardId)) {
                 pendingMove.cardIds = pendingMove.cardIds.filter(id => id !== cardId);
                 if (pendingMove.cardIds.length === 0) {
                     cancelSelection();
                     return;
                 }
                 updateSelectionUI();
                 return;
            }
            
            const state = getCurrentDisplayState();
            const targetCard = state.cards.find(c => c.id === cardId);
            
            // å¦‚æœé»æ“Šåˆ¥å¼µå¡ -> è¦–ç‚ºè¦åœ¨ç›®æ¨™å¡ä¸Šé€²è¡Œå †ç–Š (é™¤äº†ç‰¹å®šå€åŸŸå¤–)
            if (targetCard && !targetCard.zone.includes('deck') && !targetCard.zone.includes('grave') && !targetCard.zone.includes('ability')) {
                openStackingModal(targetCard);
                return;
            }
        }
        
        // å–®ç´”é¸å–ï¼Œä¸åŸ·è¡Œä»»ä½•å‹•ä½œ
        if (!pendingMove) {
            pendingMove = { cardIds: [cardId], shuffle: false };
        } else {
            pendingMove.cardIds.push(cardId);
        }
        updateSelectionUI();
    }

    function openStackingModal(targetCard) {
        const modal = document.getElementById('position-selector-modal');
        const list = document.getElementById('position-list');
        list.innerHTML = '';
        
        document.getElementById('pos-modal-title').innerText = `å †ç–Šæ“ä½œ: ç›®æ¨™ [${targetCard.text}]`;
        document.getElementById('position-list').style.display = 'none';
        document.getElementById('stack-gui').style.display = 'grid';
        
        window.confirmStackMove = (type) => {
            finishMove(targetCard.zone, undefined, targetCard.id, type);
        };
        modal.style.display = 'flex';
    }

    function updateSelectionUI() {
        document.querySelectorAll('.card.selected').forEach(el => el.classList.remove('selected'));
        
        if (pendingMove && pendingMove.cardIds.length > 0) {
            const state = getCurrentDisplayState();
            
            let allAbility = true;
            let allRevealed = true;
            
			// --- [æ–°å¢] æª¢æŸ¥æ˜¯å¦ç‚ºæˆ°é¬¥æˆ–è­·ç›¾å€ ---
            let isBattleOrShield = true;
            pendingMove.cardIds.forEach(id => {
                const c = state.cards.find(card => card.id === id);
                if (!c) return;
                const z = c.zone;
                if (!z.includes('battle') && !z.includes('shield')) {
                    isBattleOrShield = false;
                }
            });
            document.getElementById('btn-injured').style.display = isBattleOrShield ? 'block' : 'none';
            // ------------------------------------
            
            // UI Filtering Logic (Req 6)
            document.getElementById('btn-delete-card').style.display = (allAbility || allRevealed) ? 'block' : 'none';
            document.getElementById('btn-point').style.display = 'block';
            document.getElementById('btn-end-point').style.display = 'block'; 

            const firstCard = state.cards.find(c => c.id === pendingMove.cardIds[0]);
            
            // Only show Glow buttons for Ability cards
            document.getElementById('btn-glow').style.display = allAbility ? 'block' : 'none';
            document.getElementById('btn-unglow').style.display = (allAbility && firstCard && firstCard.glow) ? 'block' : 'none';
            
            document.getElementById('btn-remove-image').style.display = (firstCard && firstCard.image) ? 'block' : 'none';
            
            document.getElementById('ability-adjust-controls').style.display = allAbility ? 'block' : 'none';
            document.getElementById('ability-adjust-buttons').style.display = allAbility ? 'flex' : 'none';

            // Hide standard move buttons if Ability card (can't move them)
            // Note: The UI panel buttons are mostly actions, move happens by clicking zones.
            // We handled zone click prevention in handleZoneClick.

            const panel = document.getElementById('card-action-panel');
            panel.style.display = 'flex';
            
            if (pendingMove.cardIds.length === 1 && firstCard) {
                document.getElementById('rename-input').value = firstCard.text;
                document.getElementById('note-input').value = firstCard.note || "";
            } else {
                document.getElementById('rename-input').value = '';
                document.getElementById('note-input').value = '';
            }
            
            document.querySelectorAll('.zone').forEach(el => el.classList.add('target-highlight'));
        } else {
            document.getElementById('card-action-panel').style.display = 'none';
        }
        
        renderUI(); 
    }

    function getCardPositions() {
        const positions = {};
        document.querySelectorAll('.card').forEach(el => {
            if(el.dataset.id) {
                const rect = el.getBoundingClientRect();
                positions[el.dataset.id] = { top: rect.top, left: rect.left, width: rect.width, height: rect.height };
            }
        });
        document.querySelectorAll('.zone').forEach(el => {
            if(el.dataset.zone) {
                const rect = el.getBoundingClientRect();
                positions['ZONE_' + el.dataset.zone] = { top: rect.top, left: rect.left, width: rect.width, height: rect.height };
            }
        });
        return positions;
    }

    function getCardsInZone(state, zoneName) {
        return state.cards.filter(c => c.zone === zoneName);
    }

    function getZoneName(zoneId) {
        return zoneId.toUpperCase(); 
    }

	function renderUI() {
        const firstPositions = getCardPositions();
        const state = getCurrentDisplayState();
        
        let winOverlay = document.getElementById('win-overlay');
        if (!winOverlay) {
            winOverlay = document.createElement('div');
            winOverlay.id = 'win-overlay';
            document.body.appendChild(winOverlay);
        }

        const board = document.getElementById('game-board-container');
        const abilityZone = document.getElementById('ability-stack-zone');
        
        const p1Area = document.getElementById('player1-area');
        const p2Area = document.getElementById('player2-area');
        
        if (p1Area && p2Area) {
            p1Area.classList.remove('active-turn');
            p2Area.classList.remove('active-turn');
            if (state.turnPlayer === 1) p1Area.classList.add('active-turn');
            else p2Area.classList.add('active-turn');
        }
        
        if (state.globalRotation) {
            board.classList.add('rotated-view');
            abilityZone.classList.add('rotated-view');
        } else {
            board.classList.remove('rotated-view');
            abilityZone.classList.remove('rotated-view');
        }

        document.querySelectorAll('.zone, .ability-column').forEach(el => {
            const label = el.querySelector('.zone-label, .ability-label');
            el.innerHTML = '';
            if(label) el.appendChild(label);
            el.classList.remove('target-highlight');
            el.classList.remove('point-target-highlight'); 
            el.className = el.className.replace(/\bglow-\S+/g, '');
        });
        
        const revealZoneEl = document.getElementById('reveal-zone');
        const revealCards = state.cards.filter(c => c.zone === 'reveal-zone');
        if (revealCards.length > 0) {
            revealZoneEl.style.display = 'flex';
            // ä¿®æ”¹é€™è£¡ï¼šä½¿ç”¨ t() å’Œ data-i18n
            revealZoneEl.innerHTML = `
                <span class="zone-label" data-i18n="lbl_reveal_zone">${t('lbl_reveal_zone')}</span>
                <button class="mini-btn danger" style="position:absolute; top:5px; right:5px;" onclick="closeRevealZone()">âœ•</button>
            `;
            revealCards.forEach(c => revealZoneEl.appendChild(createCardElement(c)));
        } else {
            revealZoneEl.style.display = 'none';
            revealZoneEl.innerHTML = '';
        }

        if (pendingMove) document.querySelectorAll('.zone').forEach(el => el.classList.add('target-highlight'));
        if (isPointing) document.querySelectorAll('.zone').forEach(el => el.classList.add('point-target-highlight'));

        const zoneMap = {};
        const childMap = {}; 
        const rootCards = []; 

        state.cards.forEach(card => {
            if (card.zone === 'reveal-zone') return;
            if(!zoneMap[card.zone]) zoneMap[card.zone] = [];
            zoneMap[card.zone].push(card);
            if (card.parentId) {
                if (!childMap[card.parentId]) childMap[card.parentId] = [];
                childMap[card.parentId].push(card);
            } else {
                rootCards.push(card);
            }
        });

        ['p1-deck', 'p1-grave', 'p1-hyper', 'p2-deck', 'p2-grave', 'p2-hyper'].forEach(zid => {
            const cards = zoneMap[zid] || [];
            const glowingCard = cards.find(c => c.glow);
            if (glowingCard) {
                const zoneEl = document.querySelector(`.zone[data-zone="${zid}"]`);
                if (zoneEl) zoneEl.classList.add(`glow-${glowingCard.glow}`);
            }
        });

        const stackedZones = ['p1-deck', 'p1-grave', 'p1-hyper', 'p2-deck', 'p2-grave', 'p2-hyper', 'p1-shield', 'p2-shield'];

		const renderCardTree = (card, container) => {
            const isSpreadZone = !stackedZones.includes(card.zone) || card.zone.includes('shield');
            if (isSpreadZone) {
                let bounds = { minX: 0, maxX: 0, minY: 0, maxY: 0 };
                const measureTree = (c, x, y) => {
                    if (x < bounds.minX) bounds.minX = x;
                    if (x > bounds.maxX) bounds.maxX = x;
                    if (y < bounds.minY) bounds.minY = y;
                    if (y > bounds.maxY) bounds.maxY = y;
                    const children = childMap[c.id] || [];
                    children.forEach(child => {
                        let dx = 0, dy = 0;
                        if (child.stackType === 'puzzle_left') dx = -50;
                        else if (child.stackType === 'puzzle_right') dx = 50;
                        else if (child.stackType === 'puzzle_top') dy = -70;
                        else if (child.stackType === 'puzzle_bottom') dy = 70;
                        else if (child.stackType === 'shift_up') dy = -25;
                        else if (child.stackType === 'shift_down') dy = 25;
                        else if (child.stackType === 'bottom_exposed') dy = 20;
                        measureTree(child, x + dx, y + dy);
                    });
                };
                measureTree(card, 0, 0);
                const groupDiv = document.createElement('div');
                groupDiv.className = 'card-group';
                const totalW = (bounds.maxX - bounds.minX) + 50; 
                const totalH = (bounds.maxY - bounds.minY) + 70; 
                groupDiv.style.width = `${totalW}px`;
                groupDiv.style.height = `${totalH}px`;
                groupDiv.style.position = 'relative'; 
                groupDiv.style.margin = '5px'; 
                container.appendChild(groupDiv);
                
                const baseOffsetX = -bounds.minX;
                const baseOffsetY = -bounds.minY;

                const renderNode = (currentCard, offsetX, offsetY, zVal, depth) => {
                    const cardEl = createCardElement(currentCard);
                    let newOffsetX = offsetX;
                    let newOffsetY = offsetY;
                    let newZ = zVal;
                    let className = '';
                    if (depth === 0) {
                        className = 'stack-base';
                        newZ = 10;
                    } else {
                        if (currentCard.stackType === 'top') { className = 'stack-top'; newZ += 1; }
                        else if (currentCard.stackType === 'bottom') { className = 'stack-bottom'; newZ -= 1; }
                        else if (currentCard.stackType === 'shift_up') { className = 'stack-shift-up'; newOffsetY -= 25; newZ += 1; }
                        else if (currentCard.stackType === 'shift_down') { className = 'stack-shift-down'; newOffsetY += 25; newZ += 1; }
                        else if (currentCard.stackType === 'bottom_exposed') { className = 'stack-bottom-exposed'; newOffsetY += 20; newZ -= 1; }
                        else if (currentCard.stackType === 'puzzle_top') { className = 'stack-puzzle-top'; newOffsetY -= 70; }
                        else if (currentCard.stackType === 'puzzle_bottom') { className = 'stack-puzzle-bottom'; newOffsetY += 70; }
                        else if (currentCard.stackType === 'puzzle_left') { className = 'stack-puzzle-left'; newOffsetX -= 50; }
                        else if (currentCard.stackType === 'puzzle_right') { className = 'stack-puzzle-right'; newOffsetX += 50; }
                    }
                    if (className) cardEl.classList.add(className);
                    cardEl.style.position = 'absolute';
                    cardEl.style.left = `${newOffsetX}px`;
                    cardEl.style.top = `${newOffsetY}px`;
                    cardEl.style.zIndex = newZ;
                    if (currentCard.stackType && currentCard.stackType.includes('puzzle')) {
                         cardEl.style.transform = `rotate(${currentCard.rotation}deg)`;
                    }
                    groupDiv.appendChild(cardEl);
                    const children = childMap[currentCard.id] || [];
                    children.forEach(child => renderNode(child, newOffsetX, newOffsetY, newZ, depth + 1));
                };
                renderNode(card, baseOffsetX, baseOffsetY, 10, 0);
            }
        };

        Object.keys(zoneMap).forEach(zoneId => {
            const cardsInZone = zoneMap[zoneId];
            if (zoneId.includes('ability')) {
                const zoneEl = document.getElementById(zoneId === 'p1-ability' ? 'ability-zone-p1' : 'ability-zone-p2');
                cardsInZone.forEach(card => zoneEl.appendChild(createCardElement(card)));
                return;
            }
            const zoneEl = document.querySelector(`.zone[data-zone="${zoneId}"]`);
            if (!zoneEl) return;
            if (stackedZones.includes(zoneId) && !zoneId.includes('shield')) {
                if (cardsInZone.length > 0) {
                    const topCard = cardsInZone[cardsInZone.length - 1];
                    zoneEl.appendChild(createCardElement(topCard));
                }
                const badge = document.createElement('div');
                badge.className = 'count-badge';
                badge.innerText = cardsInZone.length;
                zoneEl.appendChild(badge);
            } else {
                const roots = rootCards.filter(c => c.zone === zoneId);
                roots.forEach(root => renderCardTree(root, zoneEl));
            }
        });

        renderTimeline();
        renderArrows(); 

        requestAnimationFrame(() => {
            const lastPositions = getCardPositions();
            Object.keys(lastPositions).forEach(id => {
                if (id.startsWith('ZONE_')) return;
                const cardEl = document.querySelector(`.card[data-id="${id}"]`);
                if (!cardEl) return;
                let start = firstPositions[id];
                if (!start && lastRenderedState) {
                    const prevCard = lastRenderedState.cards.find(c => c.id == id);
                    if (prevCard) start = firstPositions['ZONE_' + prevCard.zone];
                }
                if (start) {
                    const last = lastPositions[id];
                    const deltaX = start.left - last.left;
                    const deltaY = start.top - last.top;
                    if (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1) {
                        const cardData = state.cards.find(c => c.id == id);
                        const rotation = cardData ? cardData.rotation : 0;
                        const isAbility = cardData && cardData.zone.includes('ability');
                        if (cardData && cardData.stackType && cardData.stackType.includes('puzzle')) {
                             // skip
                        } else {
                            cardEl.style.transition = 'none';
                            cardEl.style.transform = `translate(${deltaX}px, ${deltaY}px) rotate(${isAbility?0:rotation}deg)`;
                            requestAnimationFrame(() => {
                                cardEl.style.transition = 'transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1)';
                                cardEl.style.transform = `translate(0, 0) rotate(${isAbility?0:rotation}deg)`;
                            });
                        }
                    }
                }
            });
            lastRenderedState = cloneState(state);

            if (currentIndex >= 0 && history[currentIndex]) {
                if (currentIndex !== lastAnimatedStep) {
                    const lastAction = history[currentIndex].action;
                    const winOverlay = document.getElementById('win-overlay');

                    // --- [ä¿®æ­£ 1] ç²¾æº–æ¸…é™¤å‹åˆ©å‹•ç•«ï¼Œä¸å½±éŸ¿æ’­æ”¾å™¨ ---
                    if (winOverlay) {
                        winOverlay.style.display = 'none';
                        if (winOverlayTimeout) {
                            clearTimeout(winOverlayTimeout);
                            winOverlayTimeout = null;
                        }
                    }
                    // ------------------------------------------

                    const createOp = lastAction.operations.find(op => op.type === 'CREATE_ABILITY');
                    if (createOp) {
                        setTimeout(() => {
                            animateAbilityFly(createOp.sourceCardId, createOp.newId);
                        }, 50);
                    }
                    
                    const winOp = lastAction.operations.find(op => op.type === 'GAME_WIN');
                    if (winOp && winOverlay) {
                        const winnerId = winOp.winnerId;
                        winOverlay.style.display = 'flex';
                        
                        const colors = ['#f00', '#0f0', '#00f', '#ff0', '#f0f', '#0ff'];
                        let confettiHtml = '';
                        for(let i=0; i<30; i++) {
                            const left = Math.random() * 100;
                            const delay = Math.random() * 1;
                            const bg = colors[Math.floor(Math.random()*colors.length)];
                            confettiHtml += `<div class="confetti" style="left:${left}%; animation-delay:${delay}s; background:${bg};"></div>`;
                        }

                        winOverlay.innerHTML = `
                            ${confettiHtml}
                            <div class="win-text">PLAYER ${winnerId} WIN!!</div>
                            <div class="win-sub">Congratulations</div>
                        `;
                        
                        // --- [ä¿®æ­£ 2] è¨˜éŒ„ Timer ID ---
                        winOverlayTimeout = setTimeout(() => {
                            winOverlay.style.display = 'none';
                            winOverlayTimeout = null;
                        }, 3000);
                        // ----------------------------
                    }

                    lastAnimatedStep = currentIndex;
                }
            }
        });
		
		updateSliderUI();
		// [æ–°å¢] åŒæ­¥æ²å‹• Actions åˆ—è¡¨ (åƒ…åœ¨éæ‰‹æ©Ÿæ¨¡å¼æˆ–æœ‰åˆ—è¡¨æ™‚åŸ·è¡Œ)
        if (!document.body.classList.contains('mobile-mode')) {
             scrollToActiveStep();
        }
    }

    function createCardElement(card) {
        const el = document.createElement('div');
        el.className = `card ${card.faceUp ? '' : 'face-down'}`; 
        el.dataset.id = card.id; 
        
		// --- [æ–°å¢] æ¸²æŸ“å—å‚·çˆªç—• ---
        if (card.isInjured) {
            const clawDiv = document.createElement('div');
            // å¦‚æœæ˜¯ç·¨è¼¯ä¸­(isDrafting) -> é¡¯ç¤ºéœæ…‹ (ä¸åŠ  anim class)
            // å¦‚æœæ˜¯æ’­æ”¾ä¸­ -> åŠ å…¥ claw-anim class è§¸ç™¼å‹•ç•«
            // æ³¨æ„ï¼šé€™è£¡æˆ‘å€‘ç°¡å–®åˆ¤æ–·ï¼Œåªè¦ä¸æ˜¯ç·¨è¼¯æ¨¡å¼ï¼Œå°±è¦–ç‚ºæ’­æ”¾æ¨¡å¼ï¼Œè®“å®ƒå‹•èµ·ä¾†
            // è‹¥å¸Œæœ›æ¯æ¬¡æ›æ­¥æ‰å‹•ï¼Œå¯æ­é… lastAnimatedStep åˆ¤æ–·ï¼Œä½†å…¨åŸŸåŒæ­¥æ’­æ”¾æ¯”è¼ƒç°¡å–®æš´åŠ›ä¸”çˆ½å¿«
            
            const animClass = isDrafting ? '' : 'claw-anim';
            
            clawDiv.className = `claw-overlay ${animClass}`;
            clawDiv.innerHTML = `
                <svg class="claw-svg" viewBox="0 0 100 100">
                    <path class="claw-path p1" d="M20,20 Q50,50 80,80" />
                    <path class="claw-path p2" d="M30,10 Q60,40 90,70" />
                    <path class="claw-path p3" d="M10,30 Q40,60 70,90" />
                </svg>
            `;
            el.appendChild(clawDiv);
        }
		
        // Visual Glow (only applied if property exists, logic handles source sync)
        if (card.glow) el.classList.add(`glow-${card.glow}`);
        
        if (card.image && (card.faceUp || card.isHyper)) {
            const imageSrc = globalImageRegistry[card.imageKey];
            if (imageSrc) {
                el.style.backgroundImage = `url(${imageSrc})`;
                el.classList.add('has-image');
                
                if (card.zone.includes('ability')) {
                    const style = globalAbilityStyleRegistry ? (globalAbilityStyleRegistry[card.imageKey] || { x: 50, y: 50, scale: 1 }) : { x: 50, y: 50, scale: 1 };
                    el.style.backgroundPosition = `${style.x}% ${style.y}%`;
                    el.style.backgroundSize = `${100 * style.scale}%`;
                } else {
                     el.style.backgroundSize = 'cover';
                     el.style.backgroundPosition = 'center';
                     el.style.backgroundRepeat = 'no-repeat';
                }
            }
        }

        if (card.zone.includes('ability')) {
            el.classList.add('ability-card');
            if (!card.faceUp) el.className = `card ability-card`; 
        } else {
            // Apply rotation, unless it's a puzzle piece (handled in renderNode)
            if (!card.stackType || !card.stackType.includes('puzzle')) {
                el.style.transform = `rotate(${card.rotation}deg)`;
            }
        }
        
        if (pendingMove && pendingMove.cardIds.includes(card.id)) {
            el.classList.add('selected');
            if (!card.zone.includes('ability') && el.classList.contains('selected')) {
               // Only offset if not puzzle
               if (!card.stackType || !card.stackType.includes('puzzle')) {
                   el.style.transform = `rotate(${card.rotation}deg) translateY(-5px)`;
               }
            }
        }
        
        if (isPointing && pointTargets.includes(card.id)) {
            el.classList.add('point-target-selected');
        }
        
        if (card.note) {
            const noteEl = document.createElement('div');
            noteEl.className = 'card-note';
            noteEl.innerText = card.note;
            noteEl.title = card.note; 
            el.appendChild(noteEl);
        }

        if (card.faceUp || card.zone.includes('ability')) {
            const contentDiv = document.createElement('div');
            contentDiv.style.marginTop = card.note ? '10px' : '0';
            contentDiv.innerHTML = `<div class="card-text">${card.text}</div>`;
            if (card.power > 0) contentDiv.innerHTML += `<div class="card-power">${card.power}</div>`;
            el.appendChild(contentDiv);
        }
        
        const isViewerZone = card.zone.includes('deck') || card.zone.includes('grave') || card.zone.includes('hyper');
        
        if (!isViewerZone) {
             el.onclick = (e) => handleCardSingleClick(e, card.id);
        } else {
             el.onclick = (e) => {
                 e.stopPropagation(); 
                 handleZoneClick(card.zone);
             };
        }
        
        setTimeout(() => el.classList.add('interactive'), 0);
        return el;
    }

    function renderArrows() {
        const svg = document.getElementById('svg-layer');
        const workspace = document.getElementById('workspace');
        
        // é˜²å‘†ï¼šå¦‚æœ SVG é‚„æ˜¯ä¸åœ¨ workspace è£¡é¢ï¼Œå¼·åˆ¶æŠŠå®ƒç§»é€²å»
        if (svg && workspace && svg.parentNode !== workspace) {
            workspace.insertBefore(svg, workspace.firstChild);
        }

        // æ¸…ç©ºä¸¦é‡ç¹ª Marker å®šç¾©
        svg.innerHTML = `
            <defs>
                <marker id="arrowhead" markerWidth="12" markerHeight="12" refX="10" refY="6" orient="auto" markerUnits="userSpaceOnUse">
                    <path d="M0,0 L12,6 L0,12" fill="#e74c3c" />
                </marker>
            </defs>
        `;
        
        // å–å¾—ç•¶å‰çš„æ“ä½œæ­¥é©Ÿ
        let ops = [];
        if (isDrafting) {
            ops = draftOperations;
        } else if (currentIndex >= 0 && history[currentIndex]) {
            ops = history[currentIndex].action.operations;
        }

        if (!ops || ops.length === 0) return;

        // --- æ ¸å¿ƒä¿®æ”¹ï¼šè¨ˆç®—åº§æ¨™è½‰æ›æ¯”ä¾‹ ---
        // æˆ‘å€‘éœ€è¦ç®—å‡ºã€Œè¢å¹•åƒç´ ã€è½‰æˆã€Œç•«å¸ƒå…§éƒ¨åƒç´ ã€çš„æ¯”ä¾‹
        // workspace.getBoundingClientRect() å–å¾—çš„æ˜¯ç¸®æ”¾å¾Œ(è¢å¹•ä¸Š)çš„å°ºå¯¸
        // workspace.offsetWidth å–å¾—çš„æ˜¯åŸå§‹æ’ç‰ˆ(å…§éƒ¨)çš„å°ºå¯¸ (æ‰‹æ©Ÿç‰ˆå›ºå®šç‚º 1200)
        
        const wsRect = workspace.getBoundingClientRect();
        const scaleX = wsRect.width / workspace.offsetWidth;
        const scaleY = wsRect.height / workspace.offsetHeight;
        
        // ç•«å¸ƒåœ¨è¢å¹•ä¸Šçš„å·¦ä¸Šè§’èµ·é»
        const offsetX = wsRect.left;
        const offsetY = wsRect.top;

        // è½‰æ›å‡½å¼ï¼šå°‡è¢å¹•åº§æ¨™ (Screen Coords) è½‰ç‚º ç•«å¸ƒåº§æ¨™ (Local Coords)
        const toLocal = (rect) => {
            // 1. ç®—å‡ºå…ƒç´ çš„ä¸­å¿ƒé» (è¢å¹•åº§æ¨™)
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            // 2. æ¸›å»ç•«å¸ƒèµ·é»ï¼Œä¸¦é™¤ä»¥ç¸®æ”¾æ¯”ä¾‹
            return {
                x: (centerX - offsetX) / scaleX,
                y: (centerY - offsetY) / scaleY
            };
        };

        const pointOps = ops.filter(o => o.type === 'POINT' || o.type === 'ATTACK'); 
        
        pointOps.forEach(op => {
            const attacker = document.querySelector(`.card[data-id="${op.attackerId}"]`);
            if (!attacker) return;
            
            let targetEls = [];
            if (op.targetType === 'CARD' || op.targetType === 'CREATURE' || op.targetType === 'SHIELD') {
                if (Array.isArray(op.targetIds)) {
                    op.targetIds.forEach(tid => {
                        const el = document.querySelector(`.card[data-id="${tid}"]`);
                        if(el) targetEls.push(el);
                    });
                }
            } else if (op.targetType === 'PLAYER') {
                const attackerOwner = attacker.closest('.player-area').id.includes('player1') ? 1 : 2;
                const oppId = attackerOwner === 1 ? 2 : 1;
                const deck = document.querySelector(`.deck-zone[data-zone="p${oppId}-deck"]`);
                if(deck) targetEls.push(deck);
            }
            
            // ä½¿ç”¨è½‰æ›å‡½å¼è¨ˆç®—èµ·é»
            const startPoint = toLocal(attacker.getBoundingClientRect());
            
            targetEls.forEach(target => {
                const endPoint = toLocal(target.getBoundingClientRect());
                const isSelf = (target === attacker);
                
                if (isSelf) {
                    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    const r = 40; 
                    const d = `M ${startPoint.x},${startPoint.y} C ${startPoint.x+r*2},${startPoint.y-r*2} ${startPoint.x-r*2},${startPoint.y-r*2} ${startPoint.x},${startPoint.y}`;
                    path.setAttribute("d", d);
                    path.setAttribute("class", "arrow-line");
                    path.setAttribute("fill", "none");
                    svg.appendChild(path);
                } else {
                    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    line.setAttribute("x1", startPoint.x);
                    line.setAttribute("y1", startPoint.y);
                    line.setAttribute("x2", endPoint.x);
                    line.setAttribute("y2", endPoint.y);
                    line.setAttribute("class", "arrow-line");
                    svg.appendChild(line);
                }
            });
        });
    }

    function renderTimeline() {
        const list = document.getElementById('action-list');
        list.innerHTML = '';
        
        history.forEach((item, index) => {
            const gap = document.createElement('div');
            gap.className = 'timeline-gap';
            gap.title = "æ’å…¥æ–°æ­¥é©Ÿ";
            gap.onclick = () => startDraft(index);
            list.appendChild(gap);

            const li = document.createElement('li');
            
            let colorClass = '';
            if (item.action.operations && item.action.operations.length > 0) {
                const op = item.action.operations.find(o => o.cardIds && o.cardIds.length > 0);
                if (op) {
                    const cardId = op.cardIds[0];
                    const card = item.state.cards.find(c => c.id === cardId);
                    if (card) {
                        if (card.ownerId === 1) colorClass = 'p1-action';
                        else if (card.ownerId === 2) colorClass = 'p2-action';
                    }
                }
            }

            li.className = `action-item ${index === currentIndex ? 'active' : ''} ${colorClass}`;
            
            // åœ¨ renderTimeline å…§ï¼Œä¿®æ”¹ generating controls çš„éƒ¨åˆ†ï¼š

            const delBtn = `<button class="icon-btn delete" onclick="event.stopPropagation(); deleteAction(${index})" title="${t('btn_delete_step')}">ğŸ—‘</button>`;
            
            // æ³¨æ„ï¼šé€™è£¡åŠ å…¥äº† data-i18n å±¬æ€§
            const editBtn = `<button class="mini-btn edit" onclick="event.stopPropagation(); editAction(${index})" data-i18n="btn_edit_step">${t('btn_edit_step')}</button>`;
            
            const controls = `
                <div class="action-controls">
                    <button class="mini-btn play-from" onclick="event.stopPropagation(); playFromStep(${index})" data-i18n="btn_play_from">${t('btn_play_from')}</button>
                    <button class="mini-btn play-step" onclick="event.stopPropagation(); playSingleStep(${index})" data-i18n="btn_play_step">${t('btn_play_step')}</button>
                    ${editBtn}
                    ${delBtn}
                </div>
            `;

            li.onclick = (e) => {
                if(e.target.tagName === 'BUTTON') return;
                currentIndex = index;
                renderUI();
                saveToStorage(); 
            };

            li.innerHTML = `
                <div class="action-header">
                    <span class="action-index">${index}</span>
                    <span class="action-desc">${item.action.description}</span>
                </div>
                ${controls}
            `;
            list.appendChild(li);
        });
        
        const endGap = document.createElement('div');
        endGap.className = 'timeline-gap';
        endGap.onclick = () => startDraftAtEnd();
        list.appendChild(endGap);

        document.getElementById('step-counter').innerText = `${currentIndex}/${history.length-1}`;
    }

    function prevStep() { if (currentIndex > 0) { currentIndex--; renderUI(); saveToStorage(); } }
    function nextStep() { if (currentIndex < history.length - 1) { currentIndex++; renderUI(); saveToStorage(); } }
    
    function playFromStep(idx) { 
        currentIndex = idx; renderUI(); saveToStorage();
        if (!playInterval) togglePlay(); 
    }

    function playSingleStep(idx) {
        if (playInterval) togglePlay(); 
        if (idx > 0) {
            currentIndex = idx - 1; renderUI();
            setTimeout(() => { currentIndex = idx; renderUI(); saveToStorage(); }, 500);
        } else {
            currentIndex = 0; renderUI(); saveToStorage();
        }
    }

    function togglePlay() {
        if (playInterval) {
            clearInterval(playInterval); 
            playInterval = null;
        } else {
            playInterval = setInterval(() => {
                if (currentIndex < history.length - 1) { 
                    currentIndex++; 
                    renderUI(); 
                    // saveToStorage(); // æ‰‹æ©Ÿç‰ˆå·²åœ¨ saveToStorage å…§éƒ¨æ“‹ä¸‹ï¼Œé€™é‚Šç…§èˆŠå³å¯
                    if(!document.body.classList.contains('mobile-mode')) saveToStorage();
                } 
                else { togglePlay(); }
            }, 1200);
        }
        // çµ±ä¸€å‘¼å«é€™å€‹æ›´æ–° UI
        updatePlayButtonUI();
    }
    
    function rotateBoard() { addOperation({type: 'ROTATE'}); }
    
    function exportData() {
        const historyToExport = JSON.parse(JSON.stringify(history));
        historyToExport.forEach((item, index) => { if (index > 0) delete item.state; });
        const data = {
            history: historyToExport,
            initialState: initialState,
            currentIndex: currentIndex,
            timestamp: Date.now(),
            imageRegistry: globalImageRegistry,
            abilityRegistry: globalAbilityStyleRegistry 
        };
        const blob = new Blob([JSON.stringify(data,null,2)], {type:"text/plain"});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `dm-script-${Date.now()}.txt`;
        a.click();
    }

    function processGameData(data, resetToStart = false) {
        globalImageRegistry = data.imageRegistry || {}; 
        globalAbilityStyleRegistry = data.abilityRegistry || {}; 
        initialState = data.initialState;
        let loadedHistory = data.history;
        if (!loadedHistory[0].state) loadedHistory[0].state = cloneState(initialState);
        for (let i = 1; i < loadedHistory.length; i++) {
            if (!loadedHistory[i].state) {
                const prevState = loadedHistory[i-1].state;
                const newState = cloneState(prevState);
                const ops = loadedHistory[i].action.operations;
                ops.forEach(op => applyOperation(newState, op));
                loadedHistory[i].state = newState;
            }
        }
        history = loadedHistory;
        currentIndex = resetToStart ? 0 : (data.currentIndex || 0);
        storageQuotaExceeded = false;
        hasAlertedQuota = false;
        lastRenderedState = null; 
        renderUI();
        saveToStorage();
    }

    function resolveImportConflict(choice) {
        document.getElementById('import-conflict-modal').style.display = 'none';
        if (choice === 'cancel') { pendingImportData = null; return; }
        if (choice === 'save') exportData(); 
        if (choice === 'save' || choice === 'overwrite') {
            if (pendingImportData) {
                try { processGameData(pendingImportData, true); alert(t('msg_import_success')); } 
                catch(e) { alert(t('msg_import_fail')); }
            }
        }
        pendingImportData = null;
    }

    function importData(input) {
        const file = input.files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const data = JSON.parse(e.target.result);
                if(!data.history || !data.initialState) throw new Error("Invalid format");
                if(confirm("ç¢ºå®šè¦åŒ¯å…¥æ­¤æª”æ¡ˆå—ï¼Ÿ")) {
                    processGameData(data);
                    alert("åŒ¯å…¥æˆåŠŸï¼");
                }
            } catch(err) { alert("åŒ¯å…¥å¤±æ•—"); console.error(err); }
            input.value = ''; 
        };
        reader.readAsText(file);
    }

    function openSelectorModal(zoneId) {
        const state = getCurrentDisplayState();
        const cards = getCardsInZone(state, zoneId);
        const body = document.getElementById('modal-body');
        body.innerHTML = '';
        selectedCardsInModal = [];
        const title = document.getElementById('modal-title');
        title.innerText = `${getZoneName(zoneId)} (${cards.length})`;
        title.setAttribute('data-zone-id', zoneId); 
        
        cards.forEach((card, index) => {
            const el = document.createElement('div');
            el.className = 'card';
            
            // Req 2: Render Image in List
            if (card.image && (globalImageRegistry[card.imageKey] || globalImageRegistry[card.backImageKey])) {
                const imgKey = card.imageKey || card.backImageKey;
                el.style.backgroundImage = `url(${globalImageRegistry[imgKey]})`;
                el.classList.add('has-image-icon');
            }

            el.innerHTML += `<div style="position:absolute; top:2px; left:2px; font-size:10px; color:#888; font-weight:bold; z-index:10;">#${index+1}</div>
                            <div class="card-text">${card.text}</div>`;
            el.onclick = () => {
                if (selectedCardsInModal.includes(card.id)) {
                    selectedCardsInModal = selectedCardsInModal.filter(id=>id!==card.id);
                    el.classList.remove('selected');
                } else {
                    selectedCardsInModal.push(card.id);
                    el.classList.add('selected');
                }
            };
            body.appendChild(el);
        });
        document.getElementById('card-selector-modal').style.display = 'flex';
    }
    function closeSelectorModal() { document.getElementById('card-selector-modal').style.display = 'none'; }
    function prepareMove(shuffle) {
        if(selectedCardsInModal.length===0) return;
        pendingMove = { cardIds: [...selectedCardsInModal], shuffle };
        closeSelectorModal();
        updateSelectionUI();
    }

	function openPositionSelector(zoneId, moveData) {
        const modal = document.getElementById('position-selector-modal');
        const list = document.getElementById('position-list');
        const gui = document.getElementById('stack-gui');
        
        // æ¨™é¡Œèˆ‡æ¨¡å¼åˆ‡æ›
        document.getElementById('pos-modal-title').innerText = "æ’å…¥ä½ç½®é¸æ“‡ (é»æ“Šè™›ç·šæ¡†)";
        gui.style.display = 'none';
        list.style.display = 'flex'; 
        list.innerHTML = ''; 
        
        const state = getCurrentDisplayState();
        const cards = getCardsInZone(state, zoneId);

        // --- æ ¸å¿ƒé‚è¼¯ï¼šäº¤éŒ¯ç”Ÿæˆ [æ’æ§½] èˆ‡ [åƒè€ƒå¡] ---
        
        // 1. å…ˆæ”¾æœ€é ‚éƒ¨çš„æ’æ§½ (Index 0)
        list.appendChild(createSlotElement(0, "é ‚", zoneId));
        
        for (let i = 0; i < cards.length; i++) {
            const card = cards[i];
            
            // 2. æ”¾å…¥åƒè€ƒå¡ç‰‡ (Visual)
            const refCard = document.createElement('div');
            refCard.className = 'position-card-ref';
            
            // è™•ç†åœ–ç‰‡èˆ‡æ–‡å­—
            if (card.image && (globalImageRegistry[card.imageKey] || globalImageRegistry[card.backImageKey])) {
                const imgKey = card.imageKey || card.backImageKey;
                refCard.style.backgroundImage = `url(${globalImageRegistry[imgKey]})`;
                refCard.classList.add('has-image-icon');
                refCard.innerHTML = `<span style="display:none;">${card.text}</span>`; // éš±è—æ–‡å­—ä½†ä¿ç•™çµæ§‹
            } else {
                refCard.innerHTML = `<span style="padding:2px; word-break:break-all; line-height:1;">${card.text}</span>`;
            }
            
            // å·¦ä¸Šè§’åŠ å…¥åºè™Ÿï¼Œæ–¹ä¾¿å°ç…§
            const idxBadge = document.createElement('div');
            idxBadge.style.cssText = "position:absolute; top:0; left:0; background:rgba(0,0,0,0.6); color:white; font-size:8px; padding:1px 3px; border-bottom-right-radius:3px;";
            idxBadge.innerText = i + 1;
            refCard.appendChild(idxBadge);
            
            list.appendChild(refCard);

            // 3. æ”¾å…¥è©²å¡ç‰‡ä¹‹å¾Œçš„æ’æ§½ (Index i+1)
            // å¦‚æœæ˜¯æœ€å¾Œä¸€å¼µï¼Œæ¨™ç¤ºç‚ºã€Œåº•ã€
            const isTop = (i === cards.length - 1);
            list.appendChild(createSlotElement(i + 1, isTop ? "åº•" : "", zoneId, isTop));
        }

        modal.style.display = 'flex';
    }

    // å»ºç«‹æ’æ§½çš„è¼”åŠ©å‡½å¼
    function createSlotElement(index, text, zoneId, isTop) {
        const div = document.createElement('div');
        div.className = 'position-slot';
        
        // å¦‚æœæœ‰å‚³å…¥æ–‡å­—(åº•/é ‚)å°±é¡¯ç¤ºæ–‡å­—ï¼Œå¦å‰‡é¡¯ç¤ºä¸€å€‹ '+'
        if (text) {
            div.innerHTML = `<span style="font-weight:bold; ${isTop ? 'color:#e74c3c;' : ''}">${text}</span>`;
        } else {
            div.innerHTML = `<span style="opacity:0.3; font-size:1.2rem;">+</span>`;
        }
        
        div.title = `æ’å…¥è‡³ç¬¬ ${index} å¼µç‰Œçš„ä½ç½®`;
        div.onclick = () => finishMove(zoneId, index);
        return div;
    }

    function closePositionModal() {
        document.getElementById('position-selector-modal').style.display = 'none';
    }

    window.addEventListener('beforeunload', (e) => {
        if (storageQuotaExceeded) {
            e.preventDefault();
            e.returnValue = 'å„²å­˜ç©ºé–“å·²æ»¿ï¼Œæ‚¨çš„è³‡æ–™å¯èƒ½å°šæœªå„²å­˜ã€‚å»ºè­°å…ˆåŒ¯å‡ºè³‡æ–™ã€‚';
            return e.returnValue;
        }
    });

// --- æ–°å¢çš„æ‰‹æ©Ÿç«¯é‚è¼¯ ---

    function isMobileDevice() {
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }

    function initMobileMode(scriptUrl) {
        // 1. è¨­å®šæ¨£å¼ç‚ºæ‰‹æ©Ÿæ¨¡å¼
        document.body.classList.add('mobile-mode');
        
        // 2. è¼‰å…¥è³‡æ–™ (å¼·åˆ¶è¦†è“‹ï¼Œä¸æª¢æŸ¥ LocalStorage)
        fetch(scriptUrl)
            .then(res => { if(!res.ok) throw new Error(res.status); return res.json(); })
            .then(data => {
                if(!data.history || !data.initialState) throw new Error("Invalid script");
                
                // å¼·åˆ¶è¼‰å…¥ä¸¦é‡ç½®åˆ°é–‹é ­
                processGameData(data, true);
                
                // 3. å•Ÿå‹•æ–¹å‘åµæ¸¬ç›£è½
                window.addEventListener('resize', handleOrientation);
                window.addEventListener('orientationchange', handleOrientation);
                
                // åˆæ¬¡æª¢æŸ¥æ–¹å‘
                handleOrientation();
            })
            .catch(e => {
                alert("ç„¡æ³•è¼‰å…¥åŠ‡æœ¬: " + e.message);
            });
    }

function handleOrientation() {
        const overlay = document.getElementById('orientation-overlay');
        const playBtn = document.getElementById('mob-play-btn');
        
        // åˆ¤æ–·æ˜¯å¦ç‚ºæ©«å‘
        const isLandscape = window.innerWidth > window.innerHeight;

        if (isLandscape) {
            overlay.style.display = 'none';
            if (!playInterval) togglePlay();
            
            // --- é—œéµä¿®æ”¹ï¼šåŸ·è¡Œè‡ªå‹•ç¸®æ”¾ ---
            setTimeout(autoScaleBoard, 100); // å»¶é²ä¸€ä¸‹ç­‰å¾…ç€è¦½å™¨è½‰å‘å®Œæˆ
            // ---------------------------
        } else {
            overlay.style.display = 'flex';
            if (playInterval) togglePlay();
        }
        
        if (playBtn) playBtn.innerText = playInterval ? "â¸" : "â–¶";
    }

    function autoScaleBoard() {
        const workspace = document.getElementById('workspace');
        if (!workspace) return;

        // 1. å®šç¾©æˆ‘å€‘åœ¨ CSS ä¸­è¨­å®šçš„ã€Œè™›æ“¬ç•«å¸ƒã€å°ºå¯¸
        const VIRTUAL_WIDTH = 1200;
        const VIRTUAL_HEIGHT = 800;

        // 2. å–å¾—ç•¶å‰æ‰‹æ©Ÿè¢å¹•çš„å¯¦éš›å¯ç”¨å°ºå¯¸
        const screenW = window.innerWidth;
        const screenH = window.innerHeight;

        // 3. è¨ˆç®—ç¸®æ”¾æ¯”ä¾‹ï¼šå– å¯¬åº¦æ¯” èˆ‡ é«˜åº¦æ¯” çš„æœ€å°å€¼
        // é€™æ¨£å¯ä»¥ç¢ºä¿ç•«å¸ƒå®Œå…¨é¡¯ç¤º (Contain æ¨¡å¼)
        const scaleW = screenW / VIRTUAL_WIDTH;
        const scaleH = screenH / VIRTUAL_HEIGHT;
        let scale = Math.min(scaleW, scaleH);

        // ç¨å¾®ç•™ä¸€é»é»é‚Šè· (98%) é¿å…ç·Šè²¼é‚Šç·£
        scale = scale * 0.98;

        // 4. æ‡‰ç”¨ç¸®æ”¾
        // æ³¨æ„ï¼šå› ç‚ºæˆ‘å€‘ç”¨äº† absolute + top:50% + left:50%ï¼Œ
        // æ‰€ä»¥ transform å¿…é ˆä¿ç•™ translate(-50%, -50%) æ‰èƒ½ç¶­æŒç½®ä¸­
        workspace.style.transform = `translate(-50%, -50%) scale(${scale})`;
    }

    // ç›£è½è½‰å‘èˆ‡è¦–çª—è®ŠåŒ–
    window.addEventListener('resize', () => {
        if(document.body.classList.contains('mobile-mode')) {
             requestAnimationFrame(() => {
                 const isLandscape = window.innerWidth > window.innerHeight;
                 if(isLandscape) autoScaleBoard();
             });
        }
    });

    // æ”¹å¯« togglePlay ä»¥åŒæ­¥æ›´æ–°æ‰‹æ©Ÿç‰ˆæŒ‰éˆ•æ–‡å­—
    const originalTogglePlay = togglePlay;
    togglePlay = function() {
        // å‘¼å«åŸæœ¬çš„é‚è¼¯
        originalTogglePlay();
        
        // æ›´æ–°æ‰‹æ©Ÿç‰ˆæŒ‰éˆ•
        const mobBtn = document.getElementById('mob-play-btn');
        const deskBtn = document.getElementById('btn-play');
        
        const icon = playInterval ? "â¸" : "â–¶";
        if(mobBtn) mobBtn.innerText = icon;
        // ä¿æŒé›»è…¦ç‰ˆæŒ‰éˆ•æ–‡å­—åŒæ­¥ (å¦‚æœ togglePlay å…§éƒ¨æœ‰æ”¹æ–‡å­—ï¼Œé€™è£¡åªæ˜¯é›™ä¿éšª)
        // æ³¨æ„ï¼šåŸç‰ˆ togglePlay å·²ç¶“æœ‰æ”¹ deskBtn æ–‡å­—ï¼Œæ‰€ä»¥é€™é‚Šä¸»è¦æ˜¯é‡å° mobBtn
    };

    // --- Main Entry Point ---
    window.onload = function() {
        const urlParams = new URLSearchParams(window.location.search);
        const scriptUrl = urlParams.get('scriptUrl');
        const isMobile = isMobileDevice();

        if (isMobile) {
            // --- æ‰‹æ©Ÿç‰ˆé‚è¼¯ ---
            if (!scriptUrl) {
                // æƒ…å¢ƒ A: æ‰‹æ©Ÿä¸”ç„¡åƒæ•¸ -> æ¸…ç©ºç•«é¢ä¸¦æç¤º
                document.body.innerHTML = '';
                document.body.style.backgroundColor = 'white';
                alert(t('msg_mobile_blocked'));
            } else {
                // æƒ…å¢ƒ B: æ‰‹æ©Ÿä¸”æœ‰åƒæ•¸ -> é€²å…¥è§€æˆ°æ¨¡å¼
                initMobileMode(scriptUrl);
            }
        } else {
            // --- é›»è…¦ç‰ˆé‚è¼¯ (ç¶­æŒåŸæ¨£) ---
            const hasLocalData = loadFromStorage();
            
            if (scriptUrl) {
                console.log("Found scriptUrl:", scriptUrl);
                fetch(scriptUrl)
                    .then(res => { if(!res.ok) throw new Error(res.status); return res.json(); })
                    .then(data => {
                        if(!data.history || !data.initialState) throw new Error("Invalid script");
                        if (hasLocalData) {
                            pendingImportData = data;
                            document.getElementById('import-conflict-modal').style.display = 'flex';
                        } else {
                            processGameData(data, true);
                        }
                        // æ¸…é™¤ URL é¿å…é‡æ–°æ•´ç†é‡è¤‡è§¸ç™¼ (é›»è…¦ç‰ˆè¡Œç‚º)
                        window.history.replaceState({}, document.title, window.location.pathname);
                    })
                    .catch(e => {
                        alert("ç„¡æ³•è¼‰å…¥æŒ‡å®šåŠ‡æœ¬: " + e.message);
                        if(!hasLocalData) openSetupModal();
                    });
            } else {
                if (!hasLocalData) openSetupModal();
            }
        }
    };
	
	// --- é€²åº¦æ¢æ§åˆ¶å‡½å¼ ---

    function handleSliderChange(val) {
        const step = parseInt(val);
        // å¦‚æœæ­£åœ¨æ’­æ”¾ï¼Œå…ˆæš«åœä»¥å…è¡çªï¼Œæˆ–è€…ä¿æŒæ’­æ”¾ä½†è·³è½‰
        // é€™è£¡é¸æ“‡ç›´æ¥è·³è½‰ä¸¦æ›´æ–°ç•«é¢
        currentIndex = step;
        renderUI();
        
        // åªæœ‰åœ¨éæ‰‹æ©Ÿæ¨¡å¼æ‰å­˜æª”ï¼Œé¿å…è¦†è“‹
        if(!document.body.classList.contains('mobile-mode')) {
            saveToStorage();
        }
    }

    function updateSliderUI() {
        const slider = document.getElementById('playback-slider');
        const tooltip = document.getElementById('slider-tooltip');
        
        if (slider && history.length > 0) {
            // è¨­å®šæœ€å¤§å€¼ç‚ºæ­·å²ç´€éŒ„é•·åº¦
            slider.max = history.length - 1;
            
            // è¨­å®šç•¶å‰å€¼
            slider.value = currentIndex;
            
            // æ›´æ–°æ–‡å­—æç¤º (ä¾‹å¦‚: 5/120)
            tooltip.innerText = `${currentIndex}/${history.length - 1}`;
            
            // è¦–è¦ºå„ªåŒ–ï¼šæ ¹æ“šé€²åº¦æ”¹è®Šè»Œé“èƒŒæ™¯é¡è‰² (å·²è®€éƒ¨åˆ†äº®ï¼Œæœªè®€éƒ¨åˆ†æš—)
            const percent = (currentIndex / (history.length - 1)) * 100;
            slider.style.background = `linear-gradient(to right, #3498db ${percent}%, rgba(255,255,255,0.3) ${percent}%)`;
        }
    }
	
	function scrollToActiveStep() {
        // 1. æ‰¾åˆ°ç›®å‰è¢«æ¨™è¨˜ç‚º active çš„æ­¥é©Ÿé …ç›®
        const activeItem = document.querySelector('.action-item.active');
        const listContainer = document.getElementById('action-list');
        
        if (activeItem && listContainer) {
            // 2. è¨ˆç®—æ²å‹•ä½ç½®ï¼Œè®“è©²é …ç›®å‡ºç¾åœ¨åˆ—è¡¨è¦–çª—çš„ä¸­é–“
            // ä½¿ç”¨ scrollIntoView æ˜¯æœ€ç°¡å–®çš„ API
            // block: 'center' æœƒç›¡é‡å°‡è©²å…ƒç´ ç½®ä¸­
            // behavior: 'auto' ç¬é–“è·³è½‰ï¼Œé¿å…æ‹–æ›³é€²åº¦æ¢æ™‚ç•«é¢æ™ƒå‹•å¤ªå²å®³
            activeItem.scrollIntoView({ block: 'center', behavior: 'auto' });
        }
    }
	
</script>
<div id="mobile-blocker"></div>
</body>
</html>